<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview of Physics Modules · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li class="current"><a class="toctext" href="Readme.html">Overview of Physics Modules</a><ul class="internal"><li><a class="toctext" href="#AbstractSolutionData-and-Physics-Module-Implementation-1"><code>AbstractSolutionData</code> and Physics Module Implementation</a></li><li><a class="toctext" href="#Levels-of-Functions-1">Levels of Functions</a></li><li><a class="toctext" href="#AbstractSolutionData-implementation-1"><code>AbstractSolutionData</code> implementation</a></li><li><a class="toctext" href="#Input-Options-1">Input Options</a></li><li><a class="toctext" href="#Functors-1">Functors</a></li><li class="toplevel"><a class="toctext" href="#Initialization-of-a-Simulation-1">Initialization of a Simulation</a></li></ul></li><li><a class="toctext" href="misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="advection/advection.html">Introduction</a></li><li><a class="toctext" href="advection/types.html">Datatypes</a></li><li><a class="toctext" href="advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="advection/source.html">Source Term</a></li><li><a class="toctext" href="advection/common.html">Common Functions</a></li><li><a class="toctext" href="advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler/euler.html">Introduction</a></li><li><a class="toctext" href="euler/types.html">Datatypes</a></li><li><a class="toctext" href="euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="euler/source.html">Source Term</a></li><li><a class="toctext" href="euler/common.html">Common Functions</a></li><li><a class="toctext" href="euler/conversion.html">Conversion</a></li><li><a class="toctext" href="euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="euler/boundary_functional.html">Boundary Functions</a></li><li><a class="toctext" href="euler/misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady.html">Unsteady</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li><a href="Readme.html">Overview of Physics Modules</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/325daf26b829d161827e7b7b4d6cdf7739b7b375/docs/src/solver/Readme.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Overview-of-Physics-Modules-1" href="#Overview-of-Physics-Modules-1">Overview of Physics Modules</a></h1><h2><a class="nav-anchor" id="AbstractSolutionData-and-Physics-Module-Implementation-1" href="#AbstractSolutionData-and-Physics-Module-Implementation-1"><code>AbstractSolutionData</code> and Physics Module Implementation</a></h2><p>This document describes some best practices for implementing a physics module. These practices are not required, but have proven to be useful for producing organized, readable, and reusable code.</p><h2><a class="nav-anchor" id="Levels-of-Functions-1" href="#Levels-of-Functions-1">Levels of Functions</a></h2><p>It is useful to divide functions into 3 catagories, high, mid, and low level functions.  The purpose of high level functions is to decide which method of performing an operation should be used and call other functions to do it. For example, the Euler physics modules has <code>evalVolumeIntegrals</code> and <code>evalBoundaryIntegrals</code> as high level functions.  There are several different ways of calculating both the volume and boundary integrals.  The options dictionary is used to decide what mid level function to call.  Each mid level function implements a different way of doing the calculation.</p><p>The purpose of mid level functions is to loop over the mesh and call a low level function for each node.  For example, the function <code>getEulerFlux</code> loops over the nodes of the mesh and calls a function to calculate the Euler flux at each node.  Mid level function names usually start with <code>get</code> to indicate that their purpose is to calculate some quantity but don&#39;t do the calculation themselves.</p><p>Low level functions calculate a quantity at a node.  For example, <code>calcEulerFlux</code> calculates the Euler flux at a single node.  Low level function names usually start with <code>calc</code> to indicate that they perform a specific calculation. Often, different discretizations use the same structure of loops, but do a slightly different calculation at each node.  Low level functions are called inside the innermost loop of the code, so it would be too expensive to have if statements to select which low level function to call, so various tricks involving Julia&#39;s multiple dispatch system are used to get the compiler to decide which low level function to call.  These will be described later in this document.</p><p>It is often useful to dispatch to low level functions based on <code>Tdim</code> and <code>var_type</code>.  For this reason the Euler equation implementation of <code>AbstractParamType</code> is</p><pre><code class="language-none">type ParamType{Tdim, var_type, Tsol, Tres, Tmsh} &lt;: AbstractParamType{Tdim}</code></pre><p>The other static parameters are necessary because <code>ParamType</code> has fields of those datatypes.</p><h2><a class="nav-anchor" id="AbstractSolutionData-implementation-1" href="#AbstractSolutionData-implementation-1"><code>AbstractSolutionData</code> implementation</a></h2><p>Each physics module should define and export a subtype of <code>AbstractSolutionData{Tsol, Tres}</code>. The implementation of <code>AbstractSolutionData{Tsol, Tres}</code> must inherit the <code>Tsol</code> and <code>Tres</code> static parameters, and may have additional static parameters as well. It may also be helpful to define additional abstract types within the physics module to provide different levels of abstractions. For example, the Euler physics module defines:</p><pre><code class="language-none">abstract AbstractEulerData{Tsol, Tres} &lt;: AbstractSolutionData{Tsol, Tres}
abstract EulerData {Tsol, Tdim, Tres, var_type} &lt;: AbstractEulerData{Tsol, Tres}
type EulerData_{Tsol, Tres, Tdim, Tmsh, var_type} &lt;: EulerData{Tsol, Tdim, Tres, var_type}</code></pre><p>The first line is effectively just a name change and may not be necessary. The second line adds the static parameters <code>Tdim</code>, and <code>var_type</code> while inheriting the <code>Tsol</code> and <code>Tres</code> types from <code>AbstractEulerData</code>. <code>Tdim</code> is the dimensionality of the equation, <code>Tres</code> is the datatype of the residual variables, and <code>var_type</code> is a symbol indicating whether the equation is being solved with conservative or entropy variables. The third line defines a concrete type that implements all the features required of an <code>AbstractSolutionData</code>, and adds a static parameter <code>Tmsh</code>, the datatype of the mesh variables.   The additional static parameter is necessary because one field of <code>EulerData_</code> has type <code>Tmsh</code>. Note that there could be multiple implementations of <code>AbstractSolutionData</code> for the Euler equations, perhaps with different fields to store certain data or not. All these implementations will need to have the static parameters <code>Tsol</code>, <code>Tdim</code>, <code>Tres</code>, and <code>var_type</code>, so <code>EulerData</code> is defined as an abstract type,  allowing all implementations to inherit from it. All high level functions involved in evaluating the residual will take in an argument of type <code>EulerData</code>. Only when low level functions need to dispatch based on which implementation is  used would it take in an <code>EulerData_</code> or another implementation.</p><h3><a class="nav-anchor" id="Variable-Conversion-1" href="#Variable-Conversion-1">Variable Conversion</a></h3><p>Some equations can be written in different variables, and need to convert between them.  To do this, it is <code>function convertFromNaturalToWorkingVars{Tsol}(params::ParamType{2, :var_type},                qc::AbstractArray{Tsol,1}, qe::AbstractArray{Tsol,1})</code></p><p>that converts from the &quot;natural&quot; variables in which to write an equation to some other set of variables at a node.  For the Euler equations, the &quot;natural&quot; variables would be the conservative variables, and one example of &quot;other&quot; variables would be the entropy variables.</p><p>It is also sometimes useful to define the opposite conversion, ie. from the working variables to the natural variables.</p><h2><a class="nav-anchor" id="Input-Options-1" href="#Input-Options-1">Input Options</a></h2><p>Many of the components of PDESolver have different options that control how they work and what they do. In order to  provide a unified method of specifying these options, an dictionary  of type <code>Dict{ASCIIString, Any}</code> is read in from a disk file. This dictionary (called <code>opts</code> in function signatures), is passed to all high and mid level functions so they can use values in the dictionary to determine their  control flow. Low level functions need to be extremely efficient, so they cannot have conditional logic, therefore they are not passed the dictionary. Note that retrieving values from a dictionary is very slow compared to accessing the fields of a type, so all values that are accessed repeatedly should be stored  as the field of a type.</p><h2><a class="nav-anchor" id="Functors-1" href="#Functors-1">Functors</a></h2><p>Functors are a trick used to get Julia&#39;s dispatch system to make decisions at compile time rather than runtime.  This is particularly useful for boundary conditions, where the list of mesh faces that have boundary conditions applied is determined at runtime, but having conditional statements that execute for every node on the mesh boundary would be slow.  Instead a construct is used as follows:</p><pre><code class="language-julia">type myBC &lt;: BCType  # create a singleton type
end

function call(obj::myBC, q::AbstractVector, bndryflux::AbstractVector)
  # calculate boundary flux here
end</code></pre><p>This defines a datatype and adds a method to the <code>call</code> function for that type. The call function is what makes a datatype callable like a function.  This method is called as follows:</p><pre><code class="language-julia">functor = myBC()  # construct and object of type myBC
q = rand(4)
bndryflux = zeros(4)
functor(q, bndryflux)  # the Julia compiler turns this into call(functor, q, bndryflux)  </code></pre><p>The way this is used for boundary conditions is through a two level construct where an outer function passes a functor to an inner function.  Julia&#39;s JIT will generate a method of the inner function that is specialized to the functor (this is why it is important that the functor is a datatype).  For example:</p><pre><code class="language-none">function getBCFluxes(mesh, sbp, eqn, opts)

  for i=1:mesh.numBC  # loop over different boundary conditions
    functor_i = mesh.bndry_functor[i]  # get the functor for this boundary condition
    start_index = mesh.bndry_offsets[i]
    end_index = mesh.bndry_offsets[i+1] - 1
    # get data for boundary faces start_index:end_index

    calcBoundaryFlux(functor_i, data for boundary faces start_index:end_index)
  end
end  # end function

  function calcBoundaryFlux(functor_i::BCType, data for boundary faces start_index:end_index)
    for i=1:length(start_index:end_index)
      for j=1:num_nodes_on_face
        # get data for this boundary face node
        functor_i(data for this boundary face node)
      end
    end

  end  # end function</code></pre><p>The benefit of this arrangement is that <code>mesh.numBC</code> different version of calcBoundaryFlux get compiled, one for each functor, and each version knows about the <code>call</code> method that was defined for the functor it is passed.  This two level scheme allows the compiler to make all the decisions about what function to call (ie. the <code>call</code> method of the functor), avoiding any conditional logic at runtime</p><p>This idea is also applicable to the flux functions used by DG methods.</p><h1><a class="nav-anchor" id="Initialization-of-a-Simulation-1" href="#Initialization-of-a-Simulation-1">Initialization of a Simulation</a></h1><p>This section lists an outline of how a simulation gets launched After step 4, the procedure becomes a bit more complicated because there are optional steps. Only the required steps are listed below.</p><ol><li>The options dictionary is read in.  Default values are supplied for any key that is not specified, if a reasonable default value exists.</li><li>Second, the <code>sbp</code> operator is constructed.</li><li>The <code>mesh</code> object is constructed, using the options dictionary and the <code>sbp</code> operator.  Some of the options in the dictionary are used to determine how the mesh gets constructed.  For example, the options dictionary specifies what kind of mesh coloring to do.</li><li>The <code>eqn</code> object is constructed, using the <code>mesh</code>, <code>sbp</code>, and <code>opts</code> objects</li><li>The physics module <code>init</code> function is called, which initializes the physics module and finishes any initialization that <code>mesh</code> and <code>eqn</code> objects require.</li><li>The initial condition is applied to <code>eqn.q_vec</code>.</li><li>A nonlinear solver is called.  Which solver is called and what parameters it uses are determined by the options dictionary.</li><li>Post-processing is done, if required by the options dictionary.</li></ol><footer><hr/><a class="previous" href="../invocation/interactive.html"><span class="direction">Previous</span><span class="title">Interactive Session (experimental)</span></a><a class="next" href="misc.html"><span class="direction">Next</span><span class="title">Assorted Function and Types</span></a></footer></article></body></html>

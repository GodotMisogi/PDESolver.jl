<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview of Physics Modules · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li class="current"><a class="toctext" href="Readme.html">Overview of Physics Modules</a><ul class="internal"><li><a class="toctext" href="#AbstractSolutionData-and-Physics-Module-Implementation-1"><code>AbstractSolutionData</code> and Physics Module Implementation</a></li><li><a class="toctext" href="#Levels-of-Functions-1">Levels of Functions</a></li><li><a class="toctext" href="#AbstractSolutionData-implementation-1"><code>AbstractSolutionData</code> implementation</a></li><li><a class="toctext" href="#Input-Options-1">Input Options</a></li><li><a class="toctext" href="#Functors-1">Functors</a></li><li><a class="toctext" href="#Creating-a-Manufactured-Solution-1">Creating a Manufactured Solution</a></li><li class="toplevel"><a class="toctext" href="#Initialization-of-a-Simulation-1">Initialization of a Simulation</a></li></ul></li><li><a class="toctext" href="misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="advection/advection.html">Introduction</a></li><li><a class="toctext" href="advection/types.html">Datatypes</a></li><li><a class="toctext" href="advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="advection/source.html">Source Term</a></li><li><a class="toctext" href="advection/common.html">Common Functions</a></li><li><a class="toctext" href="advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler/euler.html">Introduction</a></li><li><a class="toctext" href="euler/types.html">Datatypes</a></li><li><a class="toctext" href="euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="euler/source.html">Source Term</a></li><li><a class="toctext" href="euler/common.html">Common Functions</a></li><li><a class="toctext" href="euler/conversion.html">Conversion</a></li><li><a class="toctext" href="euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="euler/misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li><a href="Readme.html">Overview of Physics Modules</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/914c0aa1f5d72a20a5f13329eefa9d22e147e78e/docs/src/solver/Readme.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Overview-of-Physics-Modules-1" href="#Overview-of-Physics-Modules-1">Overview of Physics Modules</a></h1><h2><a class="nav-anchor" id="AbstractSolutionData-and-Physics-Module-Implementation-1" href="#AbstractSolutionData-and-Physics-Module-Implementation-1"><code>AbstractSolutionData</code> and Physics Module Implementation</a></h2><p>This document describes some best practices for implementing a physics module. These practices are not required, but have proven to be useful for producing organized, readable, and reusable code.</p><h2><a class="nav-anchor" id="Levels-of-Functions-1" href="#Levels-of-Functions-1">Levels of Functions</a></h2><p>It is useful to divide functions into 3 catagories, high, mid, and low level functions.  The purpose of high level functions is to decide which method of performing an operation should be used and call other functions to do it. For example, the Euler physics modules has <code>evalVolumeIntegrals</code> and <code>evalBoundaryIntegrals</code> as high level functions.  There are several different ways of calculating both the volume and boundary integrals.  The options dictionary is used to decide what mid level function to call.  Each mid level function implements a different way of doing the calculation.</p><p>The purpose of mid level functions is to loop over the mesh and call a low level function for each node.  For example, the function <code>getEulerFlux</code> loops over the nodes of the mesh and calls a function to calculate the Euler flux at each node.  Mid level function names usually start with <code>get</code> to indicate that their purpose is to calculate some quantity but don&#39;t do the calculation themselves.</p><p>Low level functions calculate a quantity at a node.  For example, <code>calcEulerFlux</code> calculates the Euler flux at a single node.  Low level function names usually start with <code>calc</code> to indicate that they perform a specific calculation. Often, different discretizations use the same structure of loops, but do a slightly different calculation at each node.  Low level functions are called inside the innermost loop of the code, so it would be too expensive to have if statements to select which low level function to call, so various tricks involving Julia&#39;s multiple dispatch system are used to get the compiler to decide which low level function to call.  These will be described later in this document.</p><p>It is often useful to dispatch to low level functions based on <code>Tdim</code> and <code>var_type</code>.  For this reason the Euler equation implementation of <code>AbstractParamType</code> is</p><pre><code class="language-none">type ParamType{Tdim, var_type, Tsol, Tres, Tmsh} &lt;: AbstractParamType{Tdim}</code></pre><p>The other static parameters are necessary because <code>ParamType</code> has fields of those datatypes.</p><h2><a class="nav-anchor" id="AbstractSolutionData-implementation-1" href="#AbstractSolutionData-implementation-1"><code>AbstractSolutionData</code> implementation</a></h2><p>Each physics module should define and export a subtype of <code>AbstractSolutionData{Tsol, Tres}</code>. The implementation of <code>AbstractSolutionData{Tsol, Tres}</code> must inherit the <code>Tsol</code> and <code>Tres</code> static parameters, and may have additional static parameters as well. It may also be helpful to define additional abstract types within the physics module to provide different levels of abstractions. For example, the Euler physics module defines:</p><pre><code class="language-none">abstract AbstractEulerData{Tsol, Tres} &lt;: AbstractSolutionData{Tsol, Tres}
abstract EulerData {Tsol, Tdim, Tres, var_type} &lt;: AbstractEulerData{Tsol, Tres}
type EulerData_{Tsol, Tres, Tdim, Tmsh, var_type} &lt;: EulerData{Tsol, Tdim, Tres, var_type}</code></pre><p>The first line is effectively just a name change and may not be necessary. The second line adds the static parameters <code>Tdim</code>, and <code>var_type</code> while inheriting the <code>Tsol</code> and <code>Tres</code> types from <code>AbstractEulerData</code>. <code>Tdim</code> is the dimensionality of the equation, <code>Tres</code> is the datatype of the residual variables, and <code>var_type</code> is a symbol indicating whether the equation is being solved with conservative or entropy variables. The third line defines a concrete type that implements all the features required of an <code>AbstractSolutionData</code>, and adds a static parameter <code>Tmsh</code>, the datatype of the mesh variables.   The additional static parameter is necessary because one field of <code>EulerData_</code> has type <code>Tmsh</code>. Note that there could be multiple implementations of <code>AbstractSolutionData</code> for the Euler equations, perhaps with different fields to store certain data or not. All these implementations will need to have the static parameters <code>Tsol</code>, <code>Tdim</code>, <code>Tres</code>, and <code>var_type</code>, so <code>EulerData</code> is defined as an abstract type,  allowing all implementations to inherit from it. All high level functions involved in evaluating the residual will take in an argument of type <code>EulerData</code>. Only when low level functions need to dispatch based on which implementation is  used would it take in an <code>EulerData_</code> or another implementation.</p><h3><a class="nav-anchor" id="Variable-Conversion-1" href="#Variable-Conversion-1">Variable Conversion</a></h3><p>Some equations can be written in different variables, and need to convert between them.  To do this, it is <code>function convertFromNaturalToWorkingVars{Tsol}(params::ParamType{2, :var_type},                qc::AbstractArray{Tsol,1}, qe::AbstractArray{Tsol,1})</code></p><p>that converts from the &quot;natural&quot; variables in which to write an equation to some other set of variables at a node.  For the Euler equations, the &quot;natural&quot; variables would be the conservative variables, and one example of &quot;other&quot; variables would be the entropy variables.</p><p>It is also sometimes useful to define the opposite conversion, ie. from the working variables to the natural variables.</p><h2><a class="nav-anchor" id="Input-Options-1" href="#Input-Options-1">Input Options</a></h2><p>Many of the components of PDESolver have different options that control how they work and what they do. In order to  provide a unified method of specifying these options, an dictionary  of type <code>Dict{ASCIIString, Any}</code> is read in from a disk file. This dictionary (called <code>opts</code> in function signatures), is passed to all high and mid level functions so they can use values in the dictionary to determine their  control flow. Low level functions need to be extremely efficient, so they cannot have conditional logic, therefore they are not passed the dictionary. Note that retrieving values from a dictionary is very slow compared to accessing the fields of a type, so all values that are accessed repeatedly should be stored  as the field of a type.</p><h2><a class="nav-anchor" id="Functors-1" href="#Functors-1">Functors</a></h2><p>Functors are a trick used to get Julia&#39;s dispatch system to make decisions at compile time rather than runtime.  This is particularly useful for boundary conditions, where the list of mesh faces that have boundary conditions applied is determined at runtime, but having conditional statements that execute for every node on the mesh boundary would be slow.  Instead a construct is used as follows:</p><pre><code class="language-julia">type myBC &lt;: BCType  # create a singleton type
end

function call(obj::myBC, q::AbstractVector, bndryflux::AbstractVector)
  # calculate boundary flux here
end</code></pre><p>This defines a datatype and adds a method to the <code>call</code> function for that type. The call function is what makes a datatype callable like a function.  This method is called as follows:</p><pre><code class="language-julia">functor = myBC()  # construct and object of type myBC
q = rand(4)
bndryflux = zeros(4)
functor(q, bndryflux)  # the Julia compiler turns this into call(functor, q, bndryflux)  </code></pre><p>The way this is used for boundary conditions is through a two level construct where an outer function passes a functor to an inner function.  Julia&#39;s JIT will generate a method of the inner function that is specialized to the functor (this is why it is important that the functor is a datatype).  For example:</p><pre><code class="language-none">function getBCFluxes(mesh, sbp, eqn, opts)

  for i=1:mesh.numBC  # loop over different boundary conditions
    functor_i = mesh.bndry_functor[i]  # get the functor for this boundary condition
    start_index = mesh.bndry_offsets[i]
    end_index = mesh.bndry_offsets[i+1] - 1
    # get data for boundary faces start_index:end_index

    calcBoundaryFlux(functor_i, data for boundary faces start_index:end_index)
  end
end  # end function

  function calcBoundaryFlux(functor_i::BCType, data for boundary faces start_index:end_index)
    for i=1:length(start_index:end_index)
      for j=1:num_nodes_on_face
        # get data for this boundary face node
        functor_i(data for this boundary face node)
      end
    end

  end  # end function</code></pre><p>The benefit of this arrangement is that <code>mesh.numBC</code> different version of calcBoundaryFlux get compiled, one for each functor, and each version knows about the <code>call</code> method that was defined for the functor it is passed.  This two level scheme allows the compiler to make all the decisions about what function to call (ie. the <code>call</code> method of the functor), avoiding any conditional logic at runtime</p><p>This idea is also applicable to the flux functions used by DG methods.</p><h2><a class="nav-anchor" id="Creating-a-Manufactured-Solution-1" href="#Creating-a-Manufactured-Solution-1">Creating a Manufactured Solution</a></h2><p>Using the Method of Manufactured Solutions is an effective way to verify the correctness of the code.  A guide to deriving the solution can be found <a href="http://prod.sandia.gov/techlib/access-control.cgi/2000/001444.pdf">here</a>.</p><h3><a class="nav-anchor" id="Solution-and-Derivative-Functions-1" href="#Solution-and-Derivative-Functions-1">Solution and Derivative Functions</a></h3><p>For simple equations such as linear advection, the general approach is to define a function that evalutes the manufactured solution and its derivatives at a given point, and from that create the required source term, initial condition, and boundary condition. Most physics modules have a file called <code>common_funcs.jl</code> where the solution and derivative evaluation functions go. Make sure the new function you create has the same signature as the other functions in the file. It is often useful to create different methods of the same function when creating related manufactured solutions for 2D and 3D. If the signature requires an <a href="../interfaces.html#ODLCommonTools.AbstractParamType"><code>AbstractParamType</code></a>, its static parameter can be used to distinguish the methods. Creating two methods of the same function, rather than two different functions, will make it possible to define source terms, boundary conditions, and initial conditions that work for both 2D and 3D.</p><p>For complicated equations such as Euler, it is tedious to construct the  source term, boundary condition, and initial condition from the solution and its derivatives. In this case, it is better to use a symbolic math program to generate expressions for the source term, boundary condition, and initial condition directly. Some symbolic math programs have the option to generate C or Fortran code, which can be easily converted to Julia code.</p><h3><a class="nav-anchor" id="Source-Term-1" href="#Source-Term-1">Source Term</a></h3><p>To create the source term functor, locate the file where the source terms are defined for the physics modules, usually called <code>source.jl</code> and create a new functor and associated <code>call()</code> method (see description of functors above). Make sure the functor object is a subtype of <a href="@ref"><code>SRCType</code></a> and the <code>call()</code> method has the same signature (except for the first argument) as the other call methods in the file. The name of the functor should be <code>SRCfoo</code>, where <code>foo</code> is the name of the  source term.</p><p>For simple equations such as linear advection, the body of the <code>call()</code> function should construct the source term from the functions in <code>common_funcs.jl</code>. For more complicated equations, the code that evalutes the source term at a given point should be placed in the body of the <code>call()</code> function directly.</p><p>Note that the purpose of this function is to evalute the value of the source term, not to do integration of any kind.</p><p>Once the functor is created, it should be added to the list of source terms (usually a Dictionary located at the bottom of the file where the source terms are defined). Consult the physics module documentation for details.</p><h3><a class="nav-anchor" id="Boundary-Condition-1" href="#Boundary-Condition-1">Boundary Condition</a></h3><p>Construction of a boundary term is similar to construction of a source term. Locate the file where the boundary conditions are defined, usually <code>bc.jl</code>, and add a new functor. Make sure the functor type is a subtype of <a href="@ref"><code>BCType</code></a> and the <code>call()</code> method has the same signature (except for the first argument) as the other <code>call()</code> methods in the file. The naming convention for BC functors is <code>fooBC</code>, where <code>foo</code> is the name of the  boundary condition. The body of the <code>call()</code> method should evalute the flux caused by the imposition of the boundary condition (because boundary conditions are imposed weakly). This is typically accomplished by calculating the boundary condition state and then calling a numerical flux function with both the current state and the boundary state.</p><p>For simple equations, the boundary state should construct the boundary state by calling the functions in <code>common_funcs.jl</code>. For more complicated equations, the code to evalute the boundary state should be contained in the <code>call()</code> method body.</p><p>Once the functor is created, it should be added to the list of boundary conditions, usually a dictionary located at the bottom of the file where the boundary conditions are defined. Consults the physical module documentation for details.</p><h3><a class="nav-anchor" id="Initial-condition-1" href="#Initial-condition-1">Initial condition</a></h3><p>Initial conditions are a bit different than boundary conditions and source terms because they do not use functors (functors are unnecessary because ICs are evaluated infrequently). Locate the file where initial conditions are defined, typically <code>ic.jl</code>, and create a new function with the same signature as the the other functions in the file. This function should loop over all elements in the mesh, every node on the element, and use <code>mesh.dofs</code> to assign the solution to proper indices of the supplied vector. The naming convention for IC functions is <code>ICfoo</code>, where <code>foo</code> is the name of the initial condition.</p><p>For simple equations, the solution should be calculated using the functions in <code>common_funcs.jl</code>, otherwise it should be calculated in the initial condition function.</p><p>Initial condition functions are used to calculate errors during post-processing, so it is important for the initial condition function to evaluate the solution at the proper time for unsteady problems.</p><p>After the initial condition function is created, it should be added to the list of initial conditions, usually a dictionary at the bottom of the file where the initial conditions are defined. See the physics module documentation for details.</p><h1><a class="nav-anchor" id="Initialization-of-a-Simulation-1" href="#Initialization-of-a-Simulation-1">Initialization of a Simulation</a></h1><p>This section lists an outline of how a simulation gets launched After step 4, the procedure becomes a bit more complicated because there are optional steps. Only the required steps are listed below.</p><ol><li>The options dictionary is read in.  Default values are supplied for any key that is not specified, if a reasonable default value exists.</li><li>Second, the <code>sbp</code> operator is constructed.</li><li>The <code>mesh</code> object is constructed, using the options dictionary and the <code>sbp</code> operator.  Some of the options in the dictionary are used to determine how the mesh gets constructed.  For example, the options dictionary specifies what kind of mesh coloring to do.</li><li>The <code>eqn</code> object is constructed, using the <code>mesh</code>, <code>sbp</code>, and <code>opts</code> objects</li><li>The physics module <code>init</code> function is called, which initializes the physics module and finishes any initialization that <code>mesh</code> and <code>eqn</code> objects require.</li><li>The initial condition is applied to <code>eqn.q_vec</code>.</li><li>A nonlinear solver is called.  Which solver is called and what parameters it uses are determined by the options dictionary.</li><li>Post-processing is done, if required by the options dictionary.</li></ol><footer><hr/><a class="previous" href="../invocation/interactive.html"><span class="direction">Previous</span><span class="title">Interactive Session (experimental)</span></a><a class="next" href="misc.html"><span class="direction">Next</span><span class="title">Assorted Function and Types</span></a></footer></article></body></html>

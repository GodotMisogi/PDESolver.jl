<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Face Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="advection.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li class="current"><a class="toctext" href="flux.html">Face Integrals</a><ul class="internal"></ul></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Condition</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../euler/euler.html">Introduction</a></li><li><a class="toctext" href="../euler/types.html">Datatypes</a></li><li><a class="toctext" href="../euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../euler/source.html">Source Term</a></li><li><a class="toctext" href="../euler/common.html">Common Functions</a></li><li><a class="toctext" href="../euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../euler/boundary_functional.html">Boundary Functions</a></li><li><a class="toctext" href="../euler/misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady.html">Unsteady</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Advection</li><li><a href="flux.html">Face Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/1a5c67292daa8e7e1df318d1a70eae932a68318b/docs/src/solver/advection/flux.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Advection-Face-Integrals-1" href="#Advection-Face-Integrals-1">Advection Face Integrals</a></h1><p>This page describes the functions that compute the face integrals used by DG schemes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.evalFaceIntegrals" href="#AdvectionEquationMod.evalFaceIntegrals"><code>AdvectionEquationMod.evalFaceIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>AdvectionEquationMod.evalFaceIntegrals</strong></p><p>This function evaluates the interior face integrals for DG methods, using   the flux function from eqn.flux_func.  The solution variables are interpolated   to the faces, the flux computed, and then interpolated back to the   solution points.</p><p>This function also logs some quantities to disk (TODO: move this to   Utils/logging)</p><p>Inputs:     mesh:  an AbstractDGMesh     sbp     eqn     opts</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcFaceFlux" href="#AdvectionEquationMod.calcFaceFlux"><code>AdvectionEquationMod.calcFaceFlux</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function calculates the DG flux between a specified set of faces,   using the solution data at the faces stored in eqn.q_face.   Note that the flux is negated because the face integrals have a    negative sign in the weak form.</p><p>Inputs:</p><pre><code class="language-none">mesh
sbp
eqn
functor: the functor that calculates the flux at a node
interfaces: an array of type Interface that specifies which interfaces
            to calculate the flux for</code></pre><p>Inputs/Outputs:</p><pre><code class="language-none">face_flux: array to store the flux in, numDofPerNode x nnodesPerFace
           x length(interfaces)</code></pre><p>The functor must have the signature:   func( uL, qR, alpha_x, alpha_y, dxidx, nrm, params)</p><p>where uL and uR are the solution values for a node on the left and right   elements, alpha_x and alpha_y are the x and y advection velocities,   dxidx is the scaled mapping jacobian for elementL, and nrm is the face   normal in reference space.  params is eqn.params</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcFaceIntegrals_nopre" href="#AdvectionEquationMod.calcFaceIntegrals_nopre"><code>AdvectionEquationMod.calcFaceIntegrals_nopre</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Compute the face integrals without using eqn.q_face or eqn.flux_face.   The integral is computed directly and res is updated</p><p>Inputs:</p><pre><code class="language-none">mesh
sbp
eqn
opts
flux_func: the flux functor that computes the face flux at a node</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcSharedFaceIntegrals" href="#AdvectionEquationMod.calcSharedFaceIntegrals"><code>AdvectionEquationMod.calcSharedFaceIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Thin wrapper around calcSharedFaceIntegrals_inner.  This function is passed   to finishDataExchange, and internally calls calcSharedFaceIntegrals_inner.   See <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a> for details on the interface and    <a href="flux.html#AdvectionEquationMod.calcSharedFaceIntegrals_inner"><code>calcSharedFaceIntegrals_inner</code></a> for the integral that is computed.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcSharedFaceIntegrals_inner" href="#AdvectionEquationMod.calcSharedFaceIntegrals_inner"><code>AdvectionEquationMod.calcSharedFaceIntegrals_inner</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>AdvectionEquationMod.calcSharedFaceIntegrals</strong></p><p>This function calculates the shared face integrals for the faces shared   with a single peer process.  This function is for   opts[&quot;parallel_type&quot;] == &quot;face&quot; and regular face integrals (ie. not the   entropy-stable face integrals) only.</p><p>Inputs:</p><pre><code class="language-none">mesh
sbp
eqn
opts:
data: a SharedFaceData specifying which faces to compute
functor: the FluxType to use for the face flux</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcSharedFaceIntegrals_inner_nopre" href="#AdvectionEquationMod.calcSharedFaceIntegrals_inner_nopre"><code>AdvectionEquationMod.calcSharedFaceIntegrals_inner_nopre</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Like calcSharedFaceIntegrals_inner_nopre, but it computes the integral one   face at a time rather than computing all the flux, storing it in   eqn.flux_sharedface and then doing the integral</p><p>See <a href="flux.html#AdvectionEquationMod.calcSharedFaceIntegrals_inner"><code>calcSharedFaceIntegrals_inner</code></a> for a description of the arguments</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcSharedFaceIntegrals_element" href="#AdvectionEquationMod.calcSharedFaceIntegrals_element"><code>AdvectionEquationMod.calcSharedFaceIntegrals_element</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Thin wrapper around calcSharedFaceIntegrals_inner.  This function is passed   to finishDataExchange, and internally calls calcSharedFaceIntegrals_inner.   See finishDataExchange for details on the interface and    <a href="flux.html#AdvectionEquationMod.calcSharedFaceIntegrals_inner"><code>calcSharedFaceIntegrals_inner</code></a> for the integral that is computed.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcSharedFaceIntegrals_element_inner" href="#AdvectionEquationMod.calcSharedFaceIntegrals_element_inner"><code>AdvectionEquationMod.calcSharedFaceIntegrals_element_inner</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Like <a href="flux.html#AdvectionEquationMod.calcSharedFaceIntegrals_inner"><code>calcSharedFaceIntegrals_inner</code></a>, but for the case when   opts[&quot;parallel_data&quot;] == element.  This effectively means it has to   interpolate the solution from the elements to the faces and then do the   integral</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcSharedFaceIntegrals_element_inner_nopre" href="#AdvectionEquationMod.calcSharedFaceIntegrals_element_inner_nopre"><code>AdvectionEquationMod.calcSharedFaceIntegrals_element_inner_nopre</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Like <a href="flux.html#AdvectionEquationMod.calcSharedFaceIntegrals_element_inner"><code>calcSharedFaceIntegrals_element_inner</code></a>, but computes the   integral one   face at a time instead of computing the entire flux and then integrating.</p></div></section><footer><hr/><a class="previous" href="volume.html"><span class="direction">Previous</span><span class="title">Volume Integrals</span></a><a class="next" href="bc.html"><span class="direction">Next</span><span class="title">Boundary Integrals</span></a></footer></article></body></html>

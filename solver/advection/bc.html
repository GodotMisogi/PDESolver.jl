<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="advection.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li class="current"><a class="toctext" href="bc.html">Boundary Integrals</a><ul class="internal"><li><a class="toctext" href="#Boundary-Conditions-1">Boundary Conditions</a></li><li><a class="toctext" href="#Numerical-Flux-Functions-1">Numerical Flux Functions</a></li></ul></li><li><a class="toctext" href="ic.html">Initial Condition</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../euler/euler.html">Introduction</a></li><li><a class="toctext" href="../euler/types.html">Datatypes</a></li><li><a class="toctext" href="../euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../euler/source.html">Source Term</a></li><li><a class="toctext" href="../euler/common.html">Common Functions</a></li><li><a class="toctext" href="../euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../euler/misc.html">Misc</a></li><li><a class="toctext" href="../euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Advection</li><li><a href="bc.html">Boundary Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/fec676ef2f392fbd60a91ce35662247f0f295951/docs/src/solver/advection/bc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Advection-Boundary-Integrals-1" href="#Advection-Boundary-Integrals-1">Advection Boundary Integrals</a></h1><p>This page describes the functions that compute the boundary integrals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.evalBoundaryIntegrals" href="#AdvectionEquationMod.evalBoundaryIntegrals"><code>AdvectionEquationMod.evalBoundaryIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Evaluate boundary integrals for advection equation, updating eqn.res with the result.</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code> : Abstract mesh type</li><li> <code>sbp</code>  : Summation-by-parts operator</li><li> <code>eqn</code>  : Advection equation object</li><li> <code>opts</code> : options dictionary</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcBoundaryFlux" href="#AdvectionEquationMod.calcBoundaryFlux"><code>AdvectionEquationMod.calcBoundaryFlux</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function calculates the boundary flux for the portion of the boundary   with a particular boundary condition.  The eqn.q are converted to    conservative variables if needed.  For the DG version, eqn.q_bndry must   already be populated with the q variables interpolated to the boundary</p><p>Inputs:</p><p>mesh : AbstractMesh   sbp : AbstractSBP   eqn : AdvectionEquation   functor : a callable object that calculates the boundary flux at a node   idx_range: the Range describing which Boundaries have the current BC   bndry_facenums:  An array with elements of type Boundary that tell which                    element faces have the boundary condition   Outputs:</p><p>bndryflux : the array to store the boundary flux, corresponds to                bndry_facenums</p><p>note that bndry_facenums and bndryflux must be only the portion of the    their parent arrays that correspond to the Boundaries that have the    current boundary condition applied.</p><p>The functor must have the signature:   functor( q, aux_vars, x, dxidx, nrm, bndryflux_i, eqn.params)   where q are the <em>conservative</em> variables.   where all arguments (except params and nrm) are vectors of values at a node.</p><p>params is the ParamType associated with the the EulerEquation object   nrm = mesh.sbpface.normal[:, current_node]</p><p>This is a mid level function.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcBoundaryFlux_nopre" href="#AdvectionEquationMod.calcBoundaryFlux_nopre"><code>AdvectionEquationMod.calcBoundaryFlux_nopre</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function computes the boundary integrals (and should probably be renamed)   without using eqn.q_bndry of eqn.bndryflux.  eqn.res is updated with   the results.</p><p>See calcBoundaryFlux for the meaning of the arguments</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.BCDict" href="#AdvectionEquationMod.BCDict"><code>AdvectionEquationMod.BCDict</code></a> — <span class="docstring-category">Constant</span>.</div><div><p><strong>AdvectionEquationMod.BCDict</strong></p><p>It stores all the possible boundary condition dictionary options. Whenever a  new boundary condition is created, it should get added to BCDict.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.getBCFunctors" href="#AdvectionEquationMod.getBCFunctors"><code>AdvectionEquationMod.getBCFunctors</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>AdvectionEquationMod.getBCFunctors</strong></p><p>This function uses the opts dictionary to populate mesh.bndry_funcs with the the functors</p><p>This is a high level function.</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code> : Abstract mesh type</li><li> <code>sbp</code>  : Summation-by-parts operator</li><li> <code>eqn</code>  : Advection equation object</li><li> <code>opts</code> : Input dictionary options</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><h2><a class="nav-anchor" id="Boundary-Conditions-1" href="#Boundary-Conditions-1">Boundary Conditions</a></h2><p>This section describes all boundary conditions currently available</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.defaultBC" href="#AdvectionEquationMod.defaultBC"><code>AdvectionEquationMod.defaultBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Default BC to calculate the boundary face integral (no numerical flux   functions)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.exp2xplus2yBC" href="#AdvectionEquationMod.exp2xplus2yBC"><code>AdvectionEquationMod.exp2xplus2yBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.exp2xplus2yBC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_exp2xplus2y to get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.exp3xplusyBC" href="#AdvectionEquationMod.exp3xplusyBC"><code>AdvectionEquationMod.exp3xplusyBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.exp3xplusyBC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_exp3xplusy to get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.exp5xplus4yplus2BC" href="#AdvectionEquationMod.exp5xplus4yplus2BC"><code>AdvectionEquationMod.exp5xplus4yplus2BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.exp5xplus4yplus2BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_exp5xplus4yplus2  to get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.exp5xplusyBC" href="#AdvectionEquationMod.exp5xplusyBC"><code>AdvectionEquationMod.exp5xplusyBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.exp5xplusyBC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_exp5xplusy to get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.exp_xplusyBC" href="#AdvectionEquationMod.exp_xplusyBC"><code>AdvectionEquationMod.exp_xplusyBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.exp_xplusyBC</strong></p><p>Calculates q at the boundary which is equal to exp(x+y). It is a nodal  level function.</p><p><strong>Inputs</strong></p><ul><li> <code>u</code> : Advection variable (eqn.q)</li><li> <code>alpha_x</code> &amp; <code>alpha_y</code> : velocities in the X &amp; Y directions</li><li> <code>coords</code> : Nodal coordinates</li><li> <code>dxidx</code>  : Mapping Jacobian</li><li> <code>nrm</code>    : SBP face-normal vectors</li><li> <code>bndryflux</code> : Flux at the boundary</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.exp_xyBC" href="#AdvectionEquationMod.exp_xyBC"><code>AdvectionEquationMod.exp_xyBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.exp_xyBC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_exp_xy to get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.mms1BC" href="#AdvectionEquationMod.mms1BC"><code>AdvectionEquationMod.mms1BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.mms1BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_mms1 to get   the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.p0BC" href="#AdvectionEquationMod.p0BC"><code>AdvectionEquationMod.p0BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.p0BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_p0 to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.p1BC" href="#AdvectionEquationMod.p1BC"><code>AdvectionEquationMod.p1BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.p1BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_p1 to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.p2BC" href="#AdvectionEquationMod.p2BC"><code>AdvectionEquationMod.p2BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.p2BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_p2 to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.p3BC" href="#AdvectionEquationMod.p3BC"><code>AdvectionEquationMod.p3BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.p3BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_p3 to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.p4BC" href="#AdvectionEquationMod.p4BC"><code>AdvectionEquationMod.p4BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.p4BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_p4 to   get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.p5BC" href="#AdvectionEquationMod.p5BC"><code>AdvectionEquationMod.p5BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.p5BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_p5 to   get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.sinwave_BC" href="#AdvectionEquationMod.sinwave_BC"><code>AdvectionEquationMod.sinwave_BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.sinwave_BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_sinewave to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.sinwave_ampl_BC" href="#AdvectionEquationMod.sinwave_ampl_BC"><code>AdvectionEquationMod.sinwave_ampl_BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.sinwave_ampl_BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_sinewave_ampl to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.sinwavey_BC" href="#AdvectionEquationMod.sinwavey_BC"><code>AdvectionEquationMod.sinwavey_BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.sinwavey_BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_sinewavey to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.sinwavey_pertBC" href="#AdvectionEquationMod.sinwavey_pertBC"><code>AdvectionEquationMod.sinwavey_pertBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.sinwavey_pertBC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_sinewave_pert to   get the boundary state</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.unsteadymmsBC" href="#AdvectionEquationMod.unsteadymmsBC"><code>AdvectionEquationMod.unsteadymmsBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>BC for unsteadymms</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.unsteadypolyBC" href="#AdvectionEquationMod.unsteadypolyBC"><code>AdvectionEquationMod.unsteadypolyBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>BC for unsteadypoly</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.x4BC" href="#AdvectionEquationMod.x4BC"><code>AdvectionEquationMod.x4BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.x4BC</strong></p><p>Uses the Roe solver to calculate the boundary flux using calc_x4 to   get the boundary state.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.x5plusy5BC" href="#AdvectionEquationMod.x5plusy5BC"><code>AdvectionEquationMod.x5plusy5BC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.x5plusy5BC</strong></p><p>Calculates q at the boundary which is equal to x^5 + y^5. It is a nodal  level function.</p><p><strong>Inputs</strong></p><ul><li> <code>u</code> : Advection variable (eqn.q)</li><li> <code>params</code>: the equation ParamType</li><li> <code>coords</code> : Nodal coordinates</li><li> <code>nrm_scaled</code>    : scaled face normal vector in x-y space</li><li> <code>t</code>:  current time value</li></ul><p><strong>Outputs</strong> *  <code>bndryflux</code> : Flux at the boundary</p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.xplusyBC" href="#AdvectionEquationMod.xplusyBC"><code>AdvectionEquationMod.xplusyBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>AdvectionEquationMod.xplusyBC</strong></p><p>Uses Roe solver to calculate the boundary flux using calc_xplusy to get the  boundary state</p></div></section><h2><a class="nav-anchor" id="Numerical-Flux-Functions-1" href="#Numerical-Flux-Functions-1">Numerical Flux Functions</a></h2><p>This section lists the numerical flux functions used to impose the boundary conditions weakly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.RoeSolver-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2},Tsol,Any,Any}" href="#AdvectionEquationMod.RoeSolver-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2},Tsol,Any,Any}"><code>AdvectionEquationMod.RoeSolver</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>AdvectionEquationMod.RoeSolver</strong></p><p>Roe solver for the advection equations. It determines the boundary flux on  each boundary. It is called at the nodal level</p><p><strong>Inputs</strong></p><ul><li> <code>u</code>    : Solution of advection equation at a particular node</li><li> <code>u_bc</code> : Prescribed solution value at the boundary</li><li> <code>params</code>: the equation ParamType object</li><li> <code>nrm</code>  : scaled face normal vector in x-y space</li></ul><p><strong>Outputs</strong></p><ul><li> <code>bndryflux</code> : Boundary flux at the particular node</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.flux1-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2},Any,Any,Any,Any}" href="#AdvectionEquationMod.flux1-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2},Any,Any,Any,Any}"><code>AdvectionEquationMod.flux1</code></a> — <span class="docstring-category">Method</span>.</div><div><p>flux1</p><p>Calculates the boundary flux for the advection equation. It works at the nodal level.</p><p><strong>Inputs</strong></p><ul><li> <code>u_sbp_</code>: The entry from u_sbp for this node</li><li> <code>dxidx</code> : The jacobian for this node</li><li> <code>nrm</code>   : nrm is the normal vector</li><li> <code>net_flux</code>:</li><li> <code>params</code>: the equation ParamType</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><footer><hr/><a class="previous" href="flux.html"><span class="direction">Previous</span><span class="title">Face Integrals</span></a><a class="next" href="ic.html"><span class="direction">Next</span><span class="title">Initial Condition</span></a></footer></article></body></html>

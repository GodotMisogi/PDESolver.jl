<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Functional · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="advection.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Condition</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li class="current"><a class="toctext" href="boundary_functional.html">Boundary Functional</a><ul class="internal"><li><a class="toctext" href="#Functional-Types-1">Functional Types</a></li></ul></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../euler/euler.html">Introduction</a></li><li><a class="toctext" href="../euler/types.html">Datatypes</a></li><li><a class="toctext" href="../euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../euler/source.html">Source Term</a></li><li><a class="toctext" href="../euler/common.html">Common Functions</a></li><li><a class="toctext" href="../euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../euler/misc.html">Misc</a></li><li><a class="toctext" href="../euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Advection</li><li><a href="boundary_functional.html">Boundary Functional</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/solver/advection/boundary_functional.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Boundary Functional</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Advection-Boundary-Functional-1" href="#Advection-Boundary-Functional-1">Advection Boundary Functional</a></h1><p>This page consists of all the functions necessary for computing a boundary functional along the geometric edges of a mesh for the advection equation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcBndryFunctional-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,AdvectionEquationMod.AdvectionData{Tsol,Tres,Tdim} where Tdim where Tres,Any,ODLCommonTools.AbstractIntegralFunctional{Topt}}, Tuple{Tmsh}, Tuple{Topt}, Tuple{Tsol}} where Topt where Tsol where Tmsh" href="#AdvectionEquationMod.calcBndryFunctional-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,AdvectionEquationMod.AdvectionData{Tsol,Tres,Tdim} where Tdim where Tres,Any,ODLCommonTools.AbstractIntegralFunctional{Topt}}, Tuple{Tmsh}, Tuple{Topt}, Tuple{Tsol}} where Topt where Tsol where Tmsh"><code>AdvectionEquationMod.calcBndryFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><p>AdvectionEquationMod.calcBndryfunctional</p><p>This function calculates the functional on a geometric boundary of a the computational space. This is a mid level function that should not be called from outside the module. Depending on the functional being computed, it may be necessary to define another method for this function based on a different boundary functional type.</p><p><strong>Arguments</strong></p><ul><li><p><code>mesh</code> :  Abstract mesh object</p></li><li><p><code>sbp</code>  : Summation-By-Parts operator</p></li><li><p><code>eqn</code>  : Advection equation object</p></li><li><p><code>opts</code> : Options dictionary</p></li><li><p><code>functionalData</code> : Object of the functional being computed</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/advection/boundary_functional.jl#L43-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcBoundaryFunctionalIntegrand-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2} where Tres where Tsol,Any,Any,Any,AdvectionEquationMod.IntegralQData}" href="#AdvectionEquationMod.calcBoundaryFunctionalIntegrand-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2} where Tres where Tsol,Any,Any,Any,AdvectionEquationMod.IntegralQData}"><code>AdvectionEquationMod.calcBoundaryFunctionalIntegrand</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for <a href="boundary_functional.html#AdvectionEquationMod.IntegralQData"><code>IntegralQData</code></a> functional.</p><p>Note that q should be scaled by the length of the normal vector so the   integration works correctly</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/advection/boundary_functional.jl#L212-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.calcBoundaryFunctionalIntegrand-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2} where Tres where Tsol,Any,Any,Any,AdvectionEquationMod.QfluxData}" href="#AdvectionEquationMod.calcBoundaryFunctionalIntegrand-Tuple{AdvectionEquationMod.ParamType{Tsol,Tres,2} where Tres where Tsol,Any,Any,Any,AdvectionEquationMod.QfluxData}"><code>AdvectionEquationMod.calcBoundaryFunctionalIntegrand</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>AdvectionEquationMod.calcBoundaryFunctionalIntegrand</strong></p><p>Computes the integrand for boundary functional at a surface SBP node. Every functional needs to have its own method and the functional type determines which method is called.</p><p><strong>Inputs</strong></p><ul><li><p><code>params</code> : eqn.params object</p></li><li><p><code>nx</code> : X component of face normal vector</p></li><li><p><code>ny</code> : Y component of face normal vector</p></li><li><p><code>q</code>  : Nodal solution variable</p></li><li><p><code>functionalData</code> : Object of the functional being computed</p></li></ul><p><strong>Outputs</strong></p><ul><li><p><code>functional_integrand</code> : Computed integrand at the surface node</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/advection/boundary_functional.jl#L182-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalFunctional-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,AdvectionEquationMod.AdvectionData{Tsol,Tres,Tdim} where Tdim where Tres,Any,ODLCommonTools.AbstractFunctional}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#PDESolver.evalFunctional-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,AdvectionEquationMod.AdvectionData{Tsol,Tres,Tdim} where Tdim where Tres,Any,ODLCommonTools.AbstractFunctional}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>PDESolver.evalFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>AdvectionEquationMod.evalFunctional</strong></p><p>Hight level function that evaluates functionals specified in the options dictionary. The user must call this function for functional evaluation.This function is agnostic which type of a functional is being computed and calls a mid level type specific function for the actual functional evaluation.</p><p><strong>Arguments</strong></p><ul><li><p><code>mesh</code> :  Abstract mesh object</p></li><li><p><code>sbp</code>  : Summation-By-Parts operator</p></li><li><p><code>eqn</code>  : Advection equation object</p></li><li><p><code>opts</code> : Options dictionary</p></li><li><p><code>functionalData</code> : Object of the functional being computed.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/advection/boundary_functional.jl#L5-L20">source</a></section><h2><a class="nav-anchor" id="Functional-Types-1" href="#Functional-Types-1">Functional Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.QfluxData" href="#AdvectionEquationMod.QfluxData"><code>AdvectionEquationMod.QfluxData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>###AdvectionEquationMod.QfluxData</p><p>Data type for storing relevant information pertaining to an a functional or an objective function.</p><p><strong>Members</strong></p><ul><li><p><code>bcnums</code> : boundary condition groups on which the functional is to be                            computed.</p></li><li><p><code>val</code> : Computed value of the functional</p></li><li><p><code>target_qFlux</code> : Target value for the functional qFlux</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/advection/functionals.jl#L5-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="AdvectionEquationMod.IntegralQData" href="#AdvectionEquationMod.IntegralQData"><code>AdvectionEquationMod.IntegralQData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Functional that integrates the solution q over the specified boundary(/ies)</p><p><strong>Fields</strong></p><ul><li><p>bcnums: the boundary condition groups the functional is computed over</p></li><li><p>val: the value of the functional, initially 0.0</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/advection/functionals.jl#L35-L43">source</a></section><footer><hr/><a class="previous" href="adjoint.html"><span class="direction">Previous</span><span class="title">Adjoint</span></a><a class="next" href="../euler/euler.html"><span class="direction">Next</span><span class="title">Introduction</span></a></footer></article></body></html>

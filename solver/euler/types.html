<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Datatypes · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li class="current"><a class="toctext" href="types.html">Datatypes</a><ul class="internal"></ul></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="homotopy.html">Homotopy</a></li><li><a class="toctext" href="homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="types.html">Datatypes</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/solver/euler/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Datatypes</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Euler-Types-1" href="#Euler-Types-1">Euler Types</a></h1><p>This page provides documentations for DataTypes and and simple functions that are defined in the Euler module</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.EulerData_" href="#EulerEquationMod.EulerData_"><code>EulerEquationMod.EulerData_</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.EulerData_</strong></p><p>This type is an implementation of the abstract EulerData.  It is   parameterized by the residual datatype Tres and the mesh datatype Tmsh   because it stores some arrays of those types.  Tres is the &#39;maximum&#39; type of   Tsol and Tmsh, where Tsol is the type of the solution variables.   It is also paramterized by <code>var_type</code>, which should be a symbol describing   the set of variables stored in eqn.q.  Currently supported values are   <code>:conservative</code> and <code>:entropy</code>, which indicate the conservative variables and   the entropy variables described in:</p><p>&#39;A New Finite Element Formulation for   Computational Fluid Dynamics: Part I&#39; by Hughes et al.`</p><p><em>Note</em>: this constructor does not fully populate all fields.  The           [<code>init</code>])@ref) function must be called to finish initialization.</p><p><strong>Static Parameters</strong>:</p><ul><li><p>Tsol : datatype of variables solution variables, ie. the       q vector and array</p></li><li><p>Tres : datatype of residual. ie. eltype(res_vec)</p></li><li><p>Tdim : dimensionality of equation, integer, (2 or 3, currently only 2 is       supported).</p></li><li><p>Tmsh : datatype of mesh related quantities</p></li><li><p>var_type : symbol describing variables used in weak form, (:conservative           or :entropy)</p></li></ul><p><strong>Fields</strong></p><p>This type has many fields, not all of them are documented here.  A few   of the most important ones are:</p><ul><li><p>comm: MPI communicator</p></li><li><p>commsize: size of MPI communicator</p></li><li><p>myrank: MPI rank of this process</p></li></ul><p>When computing the jacobian explicitly (options key <code>calc_jac_explicit</code>),   Tsol and Tres are typically <code>Float64</code>, however node-level operations    sometime use complex numbers or dual numbers.  Also, some operations on   entropy variables require doing parts of the computation with   conservative variables.  To support these use-cases, the fields</p><ul><li><p>params: ParamType object with <code>Tsol</code>, <code>Tres</code>, <code>Tmsh</code>, and <code>var_type</code> matching the equation object</p></li><li><p>params_conservative: ParamType object with <code>Tsol, Tres</code>, and <code>Tmsh</code> matching the <code>EulerData_</code> object, but <code>var_type = :conservative</code></p></li><li><p>params_entropy: similar to <code>param_conservative</code>, but <code>var_type = :entropy</code></p></li><li><p>params_complex: ParamType object with <code>Tmsh</code> and <code>var_type</code> matching the <code>EulerData_</code> object, but <code>Tsol = Tres = Complex128</code> </p></li></ul><p>exist.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L445-L497">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.AbstractEulerData" href="#EulerEquationMod.AbstractEulerData"><code>EulerEquationMod.AbstractEulerData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.AbstractEulerData{Tsol, Tres}</strong></p><p>This abstract type should be the supertype of <em>all</em> solution data objects   that are related to the Euler equations.</p><p>It should be used for specifying the type of a function argument only when   the function does no operations on the solution data object itself, it just   passes it onto other functions that do the work (thus AbstractEulerData   should be used for only the highest level functions).</p><p>Another way of saying say it is that this type should only be used when   the function only needs to ensure that it is solving the Euler equations,   but does not care even a little bit about how.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/EulerEquationMod.jl#L30-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.EulerData" href="#EulerEquationMod.EulerData"><code>EulerEquationMod.EulerData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.EulerData</strong></p><p>This type, although abstract, is the type functions should use for their   input arguments if they do any operations on the solution data object.   It stores all data used in evaluting the Euler Equations.</p><p>It is paramaterized on the types Tsol, the type of the   conservative variables q, and Tdim, the dimension of the equation</p><p>It should have the following fields:</p><pre><code class="language-none">* res_type : datatype of residual (depreciated)
* q  : 3D array holding conservative variables
* q_vec  : vector to assemble q into
* aux_vars : 3D array holding auxiliary variables
* flux_parametric : 4D array [ndof per node, nnodes per element, nelements, Tdim]
         holding the Euler flux in the xi and eta directions
* res  : 3D array holding residual
* res_vec   : vector form of res
* edgestab_alpha : paramater used for edge stabilization, 4d array
* bndryflux : 3D array holding boundary flux data
* stabscale : 2D array holding edge stabilization scale factor
* M : vector holding the mass matrix
* Minv :  vector holding inverse mass matrix
# Minv3D :  3D array holding inverse mass matrix for application to res (not res_vec)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/EulerEquationMod.jl#L144-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ParamType" href="#EulerEquationMod.ParamType"><code>EulerEquationMod.ParamType</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.ParamType</strong></p><p>This type holds the values of any constants or parameters needed during the   computation.  These parameters can be specified in the opts dictionary or   have default values set here.  If there is no reasonable default, values   are initialized to -1</p><p>There are also a bunch of arrays that are used as temporaries by low   level functions (to avoid having to allocate arrays themselves, which is   a performance trap).  In general, this Type is used as a container to pass   around values.</p><p>gamma and R are the independent themodynamic variables</p><p>Whether this type should be immutable or not is an open question</p><p>This type is paramaterized on the dimension of the equation for purposes   of multiple dispatch</p><p><strong>Static Parameters</strong>:</p><ul><li><p>Tdim : dimensionality of the equation, integer, (used for dispatch)</p></li><li><p>var_type : type of variables used used in the weak form, symbol, (used for         dispatch), currently supported values: :conservative, :entropy</p></li><li><p>Tsol : datatype of solution variables q</p></li><li><p>Tres : datatype of residual</p></li><li><p>Tmsh : datatype of mesh related quantities (mapping jacobian etc.)</p></li></ul><p><strong>Fields (with default values)</strong>:</p><ul><li><p>cv  : specific heat constant</p></li><li><p>R : specific gas constant (J/(Kg*K))</p></li><li><p>gamma : ratio of specific heats</p></li><li><p>gamma_1 : gamma - 1</p></li></ul><p><strong>Fields (without default values)</strong>:</p><ul><li><p>Ma  : free stream Mach number</p></li><li><p>Re  : free stream Reynolds number</p></li><li><p>aoa : angle of attack (radians)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L2-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ParamType2" href="#EulerEquationMod.ParamType2"><code>EulerEquationMod.ParamType2</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Useful alias for 2D ParamType</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L834-L836">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ParamType3" href="#EulerEquationMod.ParamType3"><code>EulerEquationMod.ParamType3</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Useful alias for 3D ParamType</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L839-L841">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.cleanup-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,EulerEquationMod.EulerData,Any}" href="#EulerEquationMod.cleanup-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,EulerEquationMod.EulerData,Any}"><code>EulerEquationMod.cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function performs all cleanup activities before the run_physics()   function returns.  The mesh, sbp, eqn, opts are returned by run_physics()   so there is not much cleanup that needs to be done, mostly closing files.</p><p><strong>Inputs/Outputs</strong>:</p><ul><li><p>mesh: an AbstractMesh object</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: the EulerData object</p></li><li><p>opts: the options dictionary</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L913-L925">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getTypeParameters-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh" href="#EulerEquationMod.getTypeParameters-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>EulerEquationMod.getTypeParameters</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getTypeParameters</strong></p><p>Gets the type parameters for mesh and equation objects.</p><p><strong>Input</strong></p><ul><li><p><code>mesh</code> : Object of abstract meshing type.</p></li><li><p><code>eqn</code>  : Euler Equation object.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>Tmsh</code> : Type parameter of the mesh.</p></li><li><p><code>Tsol</code> : Type parameter of the solution array.</p></li><li><p><code>Tres</code> : Type parameter of the residual array.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L935-L950">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.openLoggingFiles-Tuple{Any,Any}" href="#EulerEquationMod.openLoggingFiles-Tuple{Any,Any}"><code>EulerEquationMod.openLoggingFiles</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function opens all used for logging data.  In particular, every data   file that has data appended to it in majorIterationCallback should be   opened here.  Most files are of type BufferedIO, so they must be flushed   periodically.</p><p>This function requires each output to have two keys: &quot;write_outname&quot;   and &quot;write_outname_fname&quot;, where the first has a boolean value that   controls whether or not to write the output, and the second is the   file name (including extension) to write.</p><p>This function contains a list of all possible log files.  Every new   log file must be added to the list</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh: an AbstractMesh (needed for MPI Communicator)</p></li><li><p>opts: options dictionary</p></li></ul><p><strong>Outputs</strong>:</p><ul><li><p>file_dict: dictionary mapping names of files to the file object             ie. opts[&quot;write_entropy_fname&quot;] =&gt; f</p></li></ul><p>Exceptions: this function will throw an exception if any two file names               are the same</p><p>Implementation notes:     When restarting, all files must be appended to.  Currently, files     are appended to in all cases.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L845-L875">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODLCommonTools.getAllTypeParams-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},EulerEquationMod.EulerData_{Tsol,Tres,Tdim,Tmsh,var_type},Any}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}, Tuple{var_type}} where var_type where Tdim where Tres where Tsol where Tmsh" href="#ODLCommonTools.getAllTypeParams-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},EulerEquationMod.EulerData_{Tsol,Tres,Tdim,Tmsh,var_type},Any}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}, Tuple{var_type}} where var_type where Tdim where Tres where Tsol where Tmsh"><code>ODLCommonTools.getAllTypeParams</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getAllTypeParameters</strong></p><p>Gets the type parameters for mesh and equation objects.</p><p><strong>Input</strong></p><ul><li><p><code>mesh</code> : Object of abstract meshing type.</p></li><li><p><code>eqn</code>  : Euler Equation object.</p></li><li><p><code>opts</code> : Options dictionary</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>tuple</code> : Tuple of type parameters. Ordering is same as that of the concrete eqn object within this physics module.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/types.jl#L958-L973">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.PhysicsName" href="#EulerEquationMod.PhysicsName"><code>EulerEquationMod.PhysicsName</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>This physics is named <code>Euler</code></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/EulerEquationMod.jl#L226-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.FaceElementIntegralType" href="#EulerEquationMod.FaceElementIntegralType"><code>EulerEquationMod.FaceElementIntegralType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Functor type for faceElementIntegrals.  These integrals operate on a face,   but require data from the entirety of the elements that make up the   face, rather than data interpolated to the face</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/EulerEquationMod.jl#L173-L177">source</a></section><footer><hr/><a class="previous" href="euler.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="volume.html"><span class="direction">Next</span><span class="title">Volume Integrals</span></a></footer></article></body></html>

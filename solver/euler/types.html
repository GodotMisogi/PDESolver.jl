<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Datatypes · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li class="current"><a class="toctext" href="types.html">Datatypes</a><ul class="internal"></ul></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="types.html">Datatypes</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/7bb2420f78174736b7773818b8d709a9b65eb671/docs/src/solver/euler/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Euler-Types-1" href="#Euler-Types-1">Euler Types</a></h1><p>This page provides documentations for DataTypes and and simple functions that are defined in the Euler module</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.EulerData_" href="#EulerEquationMod.EulerData_"><code>EulerEquationMod.EulerData_</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type is an implimentation of the abstract <a href="types.html#EulerEquationMod.EulerData"><code>EulerData</code></a>.  It is   paramterized by the residual datatype Tres and the mesh datatype Tmsh   because it stores some arrays of those types.  Tres is the &#39;maximum&#39; type of   Tsol and Tmsh, where Tsol is the type of the conservative variables.   It is also paremterized by var_type, which should be a symbol describing   the set of variables stored in eqn.q.  Currently supported values are   :conservative and :entropy, which indicate the conservative variables and   the entropy variables described in:</p><p>&#39;A New Finite Element Formulation for   Computational Fluid Dynamics: Part I&#39; by Hughes et al.`</p><p>Eventually there will be additional implimentations of EulerData,   specifically a 3D one.</p><p><strong>Static Parameters</strong>:</p><ul><li>Tsol : datatype of variables solution variables, ie. the            q vector and array</li><li>Tres : datatype of residual. ie. eltype(res_vec)</li><li>Tdim : dimensionality of equation, integer, (2 or 3, currently only 2 is            supported).</li><li>Tmsh : datatype of mesh related quantities</li><li>var_type : symbol describing variables used in weak form, (:conservative                or :entropy)</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.AbstractEulerData" href="#EulerEquationMod.AbstractEulerData"><code>EulerEquationMod.AbstractEulerData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.AbstractEulerData{Tsol, Tres}</strong></p><p>This abstract type should be the supertype of <em>all</em> solution data objects   that are related to the Euler equations.</p><p>It should be used for specify the type of a function argument only when   the function does no operations on the solution data object itself, it just   passes it onto other functions that do the work (thus AbstractEulerData   should be used for only the highest level functions).</p><p>Another way of saying say it is that this type should only be used when   the function only needs to ensure that it is solving the Euler equations,   but does not care even a little bit about how.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.EulerData" href="#EulerEquationMod.EulerData"><code>EulerEquationMod.EulerData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.EulerData</strong></p><p>This type, although abstract, is the type functions should use for their   input arguments if they do any operations on the solution data object.   It stores all data used in evaluting the Euler Equations.</p><p>It is paramaterized on the types Tsol, the type of the   conservative variables q, and Tdim, the dimension of the equation</p><p>It should have the following fields:    * res_type : datatype of residual (depreciated)     * q  : 3D array holding conservative variables     * q_vec  : vector to assemble q into     * aux_vars : 3D array holding auxiliary variables     * flux_parametric : 4D array [ndof per node, nnodes per element, nelements, Tdim]              holding the Euler flux in the xi and eta directions     * res  : 3D array holding residual     * res_vec   : vector form of res     * edgestab_alpha : paramater used for edge stabilization, 4d array     * bndryflux : 3D array holding boundary flux data     * stabscale : 2D array holding edge stabilization scale factor     * M : vector holding the mass matrix     * Minv :  vector holding inverse mass matrix     # Minv3D :  3D array holding inverse mass matrix for application to res (not res_vec)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.BoundaryForceData" href="#EulerEquationMod.BoundaryForceData"><code>EulerEquationMod.BoundaryForceData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>###EulerEquationMod.BoundaryForceData</p><p>Composite data type for storing data pertaining to the boundaryForce. It holds lift and drag values</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ParamType" href="#EulerEquationMod.ParamType"><code>EulerEquationMod.ParamType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type holds the values of any constants or paramters needed during the   computation.  These paramters can be specified in the opts dictionary or   have default values set here.  If there is no reasonable default, values   are initialized to -1</p><p>There are also a bunch of arrays that are used as temporaries by low   level functions (to avoid having to allocate arrays themselves, which is   a performance trap).  In general, this Type is used as a container to pass   around values.</p><p>gamma and R are the independent themodynamic variables</p><p>Whether this type should be immutable or not is an open question</p><p>This type is paramaterized on the dimension of the equation for purposes   of multiple dispatch</p><p><strong>Static Parameters</strong>:</p><ul><li>Tdim : dimensionality of the equation, integer, (used for dispatch)</li><li>var_type : type of variables used used in the weak form, symbol, (used for              dispatch), currently supported values: :conservative, :entropy</li><li>Tsol : datatype of solution variables q</li><li>Tres : datatype of residual</li><li>Tmsh : datatype of mesh related quantities (mapping jacobian etc.)</li></ul><p><strong>Fields (with default values)</strong>:</p><ul><li>cv  : specific heat constant</li><li>R : specific gas constant (J/(Kg*K))</li><li>gamma : ratio of specific heats</li><li>gamma_1 : gamma - 1</li></ul><p><strong>Fields (without default values)</strong>:</p><ul><li>Ma  : free stream Mach number</li><li>Re  : free stream Reynolds number</li><li>aoa : angle of attack (radians)</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ParamType2" href="#EulerEquationMod.ParamType2"><code>EulerEquationMod.ParamType2</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Useful alias for 2D ParamType</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ParamType3" href="#EulerEquationMod.ParamType3"><code>EulerEquationMod.ParamType3</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Useful alias for 3D ParamType</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.cleanup-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.cleanup-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function performs all cleanup activities before the run_physics()   function returns.  The mesh, sbp, eqn, opts are returned by run_physics()   so there is not much cleanup that needs to be done, mostly closing files.</p><p><strong>Inputs/Outputs</strong>:</p><pre><code class="language-none">* mesh: an AbstractMesh object
* sbp: an SBP operator
* eqn: the EulerData object
* opts: the options dictionary</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.openLoggingFiles-Tuple{Any,Any}" href="#EulerEquationMod.openLoggingFiles-Tuple{Any,Any}"><code>EulerEquationMod.openLoggingFiles</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function opens all used for logging data.  In particular, every data   file that has data appended to it in majorIterationCallback should be   opened here.  Most files are of type BufferedIO, so they must be flushed   periodically.</p><p>This function requires each output to have two keys: &quot;write_outname&quot;   and &quot;write_outname_fname&quot;, where the first has a boolean value that   controls whether or not to write the output, and the second is the   file name (including extension) to write.</p><p>This function contains a list of all possible log files.  Every new   log file must be added to the list</p><p><strong>Inputs</strong>:</p><ul><li>mesh: an AbstractMesh (needed for MPI Communicator)</li><li>opts: options dictionary</li></ul><p><strong>Outputs</strong>:</p><pre><code class="language-none">* file_dict: dictionary mapping names of files to the file object
             ie. opts[&quot;write_entropy_fname&quot;] =&gt; f</code></pre><p>Exceptions: this function will throw an exception if any two file names               are the same</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.DragData" href="#EulerEquationMod.DragData"><code>EulerEquationMod.DragData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.DragData</strong></p><p>Subtype of AbstractOptimizationData. Stores all the information relevant to computing an objective function pertaining to drag. Presently its an empty type</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.FaceElementIntegralType" href="#EulerEquationMod.FaceElementIntegralType"><code>EulerEquationMod.FaceElementIntegralType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Functor type for faceElementIntegrals.  These integrals operate on a face,   but require data from the entirety of the elements that make up the   face, rather than data interpolated to the face</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.LiftData" href="#EulerEquationMod.LiftData"><code>EulerEquationMod.LiftData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.LiftData</strong></p><p>Subtype of AbstractOptimizationData. Stores all the information relevant to computing an objective function pertaining to lift. Presently its an empty type</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.PressureData" href="#EulerEquationMod.PressureData"><code>EulerEquationMod.PressureData</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.PressureData</strong></p><p>Subtype of AbstractOptimizationData. Stores all the information relevant to computing an objective function pertaining to pressure coefficeint</p><p><strong>Members</strong></p><ul><li> <code>targetCp_arr</code> : An array of arrays that stores the target coefficient of                     pressure. length(targetCp_arr) = number of geometric edges                     over which the functional is being computed. Each sub array                     has dimensions (sbpface.numnodes, nfaces) <em>(from calcBoundarFlux                     in bc.jl)</em></li><li> <code>nodal_info</code> : 1D array of indices for one node needed to acces <code>targetCp_arr</code>                   at a particular data point.                   nodal_info[1] = geometric edge number                   nodal_info[2] = sbpface node number                   nodal_info[3] = element face number on the geometric edge</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.createFunctionalData" href="#EulerEquationMod.createFunctionalData"><code>EulerEquationMod.createFunctionalData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>###EulerEquationMod.createFunctionalData</p><p>Creates an object for functional computation. This function needs to be called the same number of times as the number of functionals EXCLUDING the objective function are being computed</p><p><strong>Arguments</strong></p><ul><li><code>mesh</code> : Abstract PUMI mesh</li><li><code>sbp</code>  : Summation-by-parts operator</li><li><code>eqn</code>  : Euler equation object</li><li><code>opts</code> : Options dictionary</li><li><code>functional_number</code> : Which functional object is being generated. Default = 1</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.createObjectiveFunctionalData-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.createObjectiveFunctionalData-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.createObjectiveFunctionalData</code></a> — <span class="docstring-category">Method</span>.</div><div><p>###EulerEquationMod.createObjectiveFunctionalData</p><p>Function for create an object for functional and adjoint computation where the functional is an objective function in an optimization.</p><p><strong>Arguments</strong></p><ul><li><code>mesh</code> : Abstract PUMI mesh</li><li><code>sbp</code>  : Summation-by-parts operator</li><li><code>eqn</code>  : Euler equation object</li><li><code>opts</code> : Options dictionary</li></ul></div></section><footer><hr/><a class="previous" href="euler.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="volume.html"><span class="direction">Next</span><span class="title">Volume Integrals</span></a></footer></article></body></html>

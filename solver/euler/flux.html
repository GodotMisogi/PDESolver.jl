<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Face Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li class="current"><a class="toctext" href="flux.html">Face Integrals</a><ul class="internal"><li><a class="toctext" href="#Entry-Point-1">Entry Point</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Flux-Functors-1">Flux Functors</a></li></ul></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="flux.html">Face Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/25b6184b6ed01517269a185da4b4c0863ad100b1/docs/src/solver/euler/flux.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Face-Integrals-1" href="#Face-Integrals-1">Face Integrals</a></h1><p>This page describes the functions that evaluate the face and shared face integrals.</p><h2><a class="nav-anchor" id="Entry-Point-1" href="#Entry-Point-1">Entry Point</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalFaceIntegrals" href="#EulerEquationMod.evalFaceIntegrals"><code>EulerEquationMod.evalFaceIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>EulerEquationMod.evalFaceIntegrals</strong></p><p>This function evaluates the face integrals in a DG formulation and   updates the residual.  The array eqn.flux_face must already be populated   with the face flux.</p><p><strong>Inputs</strong>:</p><ul><li>mesh: an AbstractDGMesh</li><li>sbp: an SBP operator</li><li>eqn: an EulerData object</li><li>opts: the options dictonary</li></ul><p><strong>Outputs</strong>:</p><pre><code class="language-none">none</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalSharedFaceIntegrals" href="#EulerEquationMod.evalSharedFaceIntegrals"><code>EulerEquationMod.evalSharedFaceIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>EulerEquationMod.evalSharedFaceIntegrals</strong></p><p>This function does the computation that needs the parallel   communication to have finished already, namely the face integrals   for the shared faces</p><p><strong>Inputs</strong>:</p><ul><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li></ul></div></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcFaceFlux-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1},AbstractArray{Tres,3}}" href="#EulerEquationMod.calcFaceFlux-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1},AbstractArray{Tres,3}}"><code>EulerEquationMod.calcFaceFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcFaceFlux</strong></p><p>This function calculates the DG flux between a specified set of faces,   using the solution data at the faces stored in eqn.q_face.   Note that the flux is negated because the face integrals have a   negative sign in the weak form.</p><p>Conservative variables only!</p><p><strong>Inputs</strong>:</p><ul><li>mesh</li><li>sbp</li><li>eqn</li><li>functor: the functor that calculates the flux at a node</li><li>interfaces: an array of type Interface that specifies which interfaces                 to calculate the flux for</li></ul><p><strong>Inputs/Outputs</strong>:    * face_flux: array to store the flux in, numDofPerNode x nnodesPerFace                x length(interfaces)</p><p>The functor must have the signature:</p><p><code>func( uL, qR, aux_vars, dxidx, nrm, flux_j, eqn.params)</code></p><p>where uL and uR are the solution values for a node on the left and right   elements, aux_vars are the auxiliary variables for the node,   dxidx is the scaled mapping jacobian for elementL, and nrm is the face   normal in reference space. flux_j is the array of length numDofPerNode to be   populated with the flux. params is eqn.params.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcFaceIntegral_nopre-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any,ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1}}" href="#EulerEquationMod.calcFaceIntegral_nopre-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any,ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1}}"><code>EulerEquationMod.calcFaceIntegral_nopre</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcFaceFlux-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1},AbstractArray{Tres,3}}"><code>calcFaceFlux</code></a>, but computes the flux for a single element and   then integrates it immediately, updating eqn.res</p><p><strong>Inputs</strong>:    * mesh    * sbp    * eqn    * opts    * functor: a FluxType that evalutes the flux    * interfaces: the vector of <a href="../misc.html#ODLCommonTools.Interface"><code>Interface</code></a>s to compute the integrals for</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceElementIntegrals_element-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T}}" href="#EulerEquationMod.calcSharedFaceElementIntegrals_element-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T}}"><code>EulerEquationMod.calcSharedFaceElementIntegrals_element</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is a thin wrapper around   <a href="flux.html#EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}"><code>calcSharedFaceElementIntegrals_element_inner</code></a>,   presenting the interface needed by <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a>.   See that function for the interface details.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}" href="#EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}"><code>EulerEquationMod.calcSharedFaceElementIntegrals_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function loops over given set of shared faces and computes a face   integral that   uses data from all volume nodes.  See <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a>   for details on the integral performed.</p><p><strong>Inputs</strong>:</p><ul><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>data: a SharedFaceData specifying which shared faces to compute</li><li>face_integral_functor</li><li>flux_functor</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T}}" href="#EulerEquationMod.calcSharedFaceIntegrals-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T}}"><code>EulerEquationMod.calcSharedFaceIntegrals</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is a thin wrapper around calcSharedFaceIntegrals_inner.   It present the interface needed by <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_element-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T}}" href="#EulerEquationMod.calcSharedFaceIntegrals_element-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T}}"><code>EulerEquationMod.calcSharedFaceIntegrals_element</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is a thin wrapper around   <a href="flux.html#EulerEquationMod.calcSharedFaceIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>calcSharedFaceIntegrals_element_inner</code></a>.   It presents the interface required by <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}" href="#EulerEquationMod.calcSharedFaceIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>EulerEquationMod.calcSharedFaceIntegrals_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates the shared face integrals for a given set of faces.   It uses the MPI send and receive buffers that contain the solution for the   elements on the boundary (rather than the data on the faces).  This   enables calculating a sparse jacobian with minimal parallel communication.</p><p><strong>Inputs</strong>:</p><ul><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>data: a SharedFaceData specifying the faces to calculate</li><li>functor: the flux functor</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}" href="#EulerEquationMod.calcSharedFaceIntegrals_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>EulerEquationMod.calcSharedFaceIntegrals_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcSharedFaceIntegrals</strong></p><p>This function calculates the shared face integrals over a given set of   faces.</p><p><strong>Inputs</strong>:</p><ul><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>data: the SharedFaceData specifying which faces to compute</li><li>functor: the FluxType to use for the face flux</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_nopre_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}" href="#EulerEquationMod.calcSharedFaceIntegrals_nopre_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>EulerEquationMod.calcSharedFaceIntegrals_nopre_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcSharedFaceIntegrals_element_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>calcSharedFaceIntegrals_element_inner</code></a>, but performs the integration and   updates eqn.res rather than computing the flux only and storing it in   eqn.flux_sharedface</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_nopre_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}" href="#EulerEquationMod.calcSharedFaceIntegrals_nopre_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>EulerEquationMod.calcSharedFaceIntegrals_nopre_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcSharedFaceIntegrals_inner-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,Utils.SharedFaceData{T},ODLCommonTools.FluxType}"><code>calcSharedFaceIntegrals_inner</code></a>, but performs the integration and   updates eqn.res rather than computing the flux and storing it in   eqn.flux_sharedface</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFaceElementIntegral-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType,SummationByParts.AbstractFace{T<:Number},AbstractArray{ODLCommonTools.Interface,1}}" href="#EulerEquationMod.getFaceElementIntegral-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType,SummationByParts.AbstractFace{T<:Number},AbstractArray{ODLCommonTools.Interface,1}}"><code>EulerEquationMod.getFaceElementIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function loops over interfaces and computes a face integral that   uses data from all volume nodes. See <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a>   for details on the integral performed.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFluxFunctors-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,Any,Any}" href="#EulerEquationMod.getFluxFunctors-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,Any,Any}"><code>EulerEquationMod.getFluxFunctors</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getFluxFunctors</strong></p><p>This function retrieves the flux functors from the dictonary and   stores them to eqn.flux_func.</p><p>Inputs:     mesh: an AbstractDGMesh     sbp     eqn     opts</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.interpolateFace-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,Any,Any,AbstractArray{T,3},AbstractArray{Tsol,4}}" href="#EulerEquationMod.interpolateFace-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,Any,Any,AbstractArray{T,3},AbstractArray{Tsol,4}}"><code>EulerEquationMod.interpolateFace</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.interpolateFace</strong></p><p>This function interpolates the solution values from the internal nodes   to the face flux points of the elements</p><p><strong>Inputs</strong>:</p><ul><li>mesh: an AbstractDGMesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>q: a 3D array of solution values at the nodes, numDofPerNode x        numNodesPerElement x numEl</li></ul><p><strong>Inputs/Outputs</strong>:</p><ul><li>q_face: a 4D array of solution values at each interface,             numDofPerNode x 2 x numfacenodes x numInterface             q_face[:, 1, j, i] stores the q values for elementL of interface             i node j and q_face[:, 2, j, i] stores the values for elementR</li></ul><p>eqn.aux_vars_face is also populated</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.FluxDict" href="#EulerEquationMod.FluxDict"><code>EulerEquationMod.FluxDict</code></a> — <span class="docstring-category">Constant</span>.</div><div><p><strong>EulerEquationMod.FluxDict</strong></p><p>This dictonary maps the names of the fluxes (ASCIIStrings) to the   functor object itself.  All flux functors should be added to the dictionary.</p><p>All fluxes have one method that calculates the flux in a particular direction   at a node.  Some fluxes have an additional method that computes the flux   in several directions at a node in a single function call, which can be   more efficient.  See calcEulerFlux_standard for an example.</p><p>In general, these functors call similarly-named function in bc_solvers.jl.   It is recommened to look at the documentation for those functions.</p><p>TODO: document signature of the functors here</p></div></section><h2><a class="nav-anchor" id="Flux-Functors-1" href="#Flux-Functors-1">Flux Functors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.DucrosFlux" href="#EulerEquationMod.DucrosFlux"><code>EulerEquationMod.DucrosFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_Ducros-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}"><code>calcEulerFlux_Ducros</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.IRFlux" href="#EulerEquationMod.IRFlux"><code>EulerEquationMod.IRFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_IR-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}"><code>calcEulerFlux_IR</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.IRSLFFlux" href="#EulerEquationMod.IRSLFFlux"><code>EulerEquationMod.IRSLFFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_IRSLF-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}"><code>calcEulerFlux_IRSLF</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.RoeFlux" href="#EulerEquationMod.RoeFlux"><code>EulerEquationMod.RoeFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls the <a href="flux_functions.html#EulerEquationMod.RoeSolver"><code>RoeSolver</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.StandardFlux" href="#EulerEquationMod.StandardFlux"><code>EulerEquationMod.StandardFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_standard-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,2},AbstractArray{Tres,2}}"><code>calcEulerFlux_standard</code></a></p></div></section><footer><hr/><a class="previous" href="volume.html"><span class="direction">Previous</span><span class="title">Volume Integrals</span></a><a class="next" href="bc.html"><span class="direction">Next</span><span class="title">Boundary Integrals</span></a></footer></article></body></html>

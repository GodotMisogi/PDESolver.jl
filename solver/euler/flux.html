<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Face Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="volume_diff.html">Volume Integrals Jacobian</a></li><li class="current"><a class="toctext" href="flux.html">Face Integrals</a><ul class="internal"><li><a class="toctext" href="#Entry-Point-1">Entry Point</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#sec:euler_flux_functors-1">Flux Functors</a></li></ul></li><li><a class="toctext" href="flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="homotopy.html">Homotopy</a></li><li><a class="toctext" href="homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="flux.html">Face Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/solver/euler/flux.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Face Integrals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="sec:euler_face_integrals-1" href="#sec:euler_face_integrals-1">Face Integrals</a></h1><p>This page describes the functions that evaluate the face and shared face integrals.</p><h2><a class="nav-anchor" id="Entry-Point-1" href="#Entry-Point-1">Entry Point</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalFaceIntegrals" href="#EulerEquationMod.evalFaceIntegrals"><code>EulerEquationMod.evalFaceIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>EulerEquationMod.evalFaceIntegrals</strong></p><p>This function evaluates the face integrals in a DG formulation and   updates the residual.  The array eqn.flux_face must already be populated   with the face flux.</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh: an AbstractDGMesh</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: an EulerData object</p></li><li><p>opts: the options dictonary</p></li></ul><p><strong>Outputs</strong>:</p><pre><code class="language-none">none</code></pre></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/euler.jl#L847-L865">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalSharedFaceIntegrals" href="#EulerEquationMod.evalSharedFaceIntegrals"><code>EulerEquationMod.evalSharedFaceIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>EulerEquationMod.evalSharedFaceIntegrals</strong></p><p>This function does the computation that needs the parallel   communication to have finished already, namely the face integrals   for the shared faces</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/euler.jl#L925-L938">source</a></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcFaceFlux-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1},AbstractArray{Tres,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcFaceFlux-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1},AbstractArray{Tres,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcFaceFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcFaceFlux</strong></p><p>This function calculates the DG flux between a specified set of faces,   using the solution data at the faces stored in eqn.q_face.   Note that the flux is negated because the face integrals have a   negative sign in the weak form.</p><p>Conservative variables only!</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>functor: the functor that calculates the flux at a node</p></li><li><p>interfaces: an array of type Interface that specifies which interfaces            to calculate the flux for</p></li></ul><p><strong>Inputs/Outputs</strong>:</p><ul><li><p>face_flux: array to store the flux in, numDofPerNode x nnodesPerFace           x length(interfaces)</p></li></ul><p>The functor must have the signature:</p><p><code>func( uL, qR, aux_vars, dxidx, nrm, flux_j, eqn.params)</code></p><p>where uL and uR are the solution values for a node on the left and right   elements, aux_vars are the auxiliary variables for the node,   dxidx is the scaled mapping jacobian for elementL, and nrm is the face   normal in reference space. flux_j is the array of length numDofPerNode to be   populated with the flux. params is eqn.params.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L3-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcFaceIntegral_nopre-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any,ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcFaceIntegral_nopre-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any,ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcFaceIntegral_nopre</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcFaceFlux-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},ODLCommonTools.FluxType,AbstractArray{ODLCommonTools.Interface,1},AbstractArray{Tres,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>calcFaceFlux</code></a>, but computes the flux for a single element and   then integrates it immediately, updating eqn.res</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>functor: a FluxType that evalutes the flux</p></li><li><p>interfaces: the vector of <a href="../misc.html#ODLCommonTools.Interface"><code>Interface</code></a>s to compute the integrals for</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L66-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceElementIntegralsStaggered_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceElementIntegralsStaggered_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceElementIntegralsStaggered_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>calcSharedFaceElementIntegrals_element_inner</code></a>, but for staggered grid.</p><p>data.q_recv is the solution grid data.  This function interpolates it to the   flux grid on the fly.</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh_s: solution grid mesh</p></li><li><p>mesh_f: flux grid mesh</p></li><li><p>sbp_s: SBP operator for solution grid</p></li><li><p>sbp_f: SBP operator for the flux grid</p></li><li><p>opts: options dictionary</p></li><li><p>data: <a href="../../Utils/parallel.html#Utils.SharedFaceData"><code>SharedFaceData</code></a></p></li><li><p>face_integral_functor: <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a></p></li><li><p>flux_functor: <a href="../misc.html#ODLCommonTools.FluxType"><code>FluxType</code></a> passed to face_integral functor</p></li></ul><p><strong>Inputs/Outputs</strong>:</p><pre><code class="language-none">* eqn: equation object (lives on solution grid)</code></pre><p>Aliasing restrictions: none</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L326-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceElementIntegrals_element-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceElementIntegrals_element-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceElementIntegrals_element</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is a thin wrapper around   <a href="flux.html#EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>calcSharedFaceElementIntegrals_element_inner</code></a>,   presenting the interface needed by <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a>.   See that function for the interface details.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L240-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceElementIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceElementIntegrals_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function loops over given set of shared faces and computes a face   integral that   uses data from all volume nodes.  See <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a>   for details on the integral performed.</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>data: a SharedFaceData specifying which shared faces to compute</p></li><li><p>face_integral_functor</p></li><li><p>flux_functor</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L264-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceIntegrals-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceIntegrals</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is a thin wrapper around calcSharedFaceIntegrals_inner.   It present the interface needed by <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L415-L418">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_element-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceIntegrals_element-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceIntegrals_element</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is a thin wrapper around   <a href="flux.html#EulerEquationMod.calcSharedFaceIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>calcSharedFaceIntegrals_element_inner</code></a>.   It presents the interface required by <a href="../../Utils/parallel.html#Utils.finishExchangeData"><code>finishExchangeData</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L547-L551">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceIntegrals_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates the shared face integrals for a given set of faces.   It uses the MPI send and receive buffers that contain the solution for the   elements on the boundary (rather than the data on the faces).  This   enables calculating a sparse jacobian with minimal parallel communication.</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>data: a SharedFaceData specifying the faces to calculate</p></li><li><p>functor: the flux functor</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L568-L583">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceIntegrals_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceIntegrals_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcSharedFaceIntegrals</strong></p><p>This function calculates the shared face integrals over a given set of   faces.</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>data: the SharedFaceData specifying which faces to compute</p></li><li><p>functor: the FluxType to use for the face flux</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L433-L448">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_nopre_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceIntegrals_nopre_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceIntegrals_nopre_element_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcSharedFaceIntegrals_element_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>calcSharedFaceIntegrals_element_inner</code></a>, but performs the integration and   updates eqn.res rather than computing the flux only and storing it in   eqn.flux_sharedface</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L653-L657">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSharedFaceIntegrals_nopre_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh" href="#EulerEquationMod.calcSharedFaceIntegrals_nopre_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>EulerEquationMod.calcSharedFaceIntegrals_nopre_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like <a href="flux.html#EulerEquationMod.calcSharedFaceIntegrals_inner-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type where Tdim where Tres,Any,Utils.SharedFaceData,ODLCommonTools.FluxType}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>calcSharedFaceIntegrals_inner</code></a>, but performs the integration and   updates eqn.res rather than computing the flux and storing it in   eqn.flux_sharedface</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L495-L499">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFaceElementIntegral-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType,SummationByParts.AbstractFace,AbstractArray{ODLCommonTools.Interface,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh" href="#EulerEquationMod.getFaceElementIntegral-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType,SummationByParts.AbstractFace,AbstractArray{ODLCommonTools.Interface,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>EulerEquationMod.getFaceElementIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function loops over interfaces and computes a face integral that   uses data from all volume nodes. See FaceElementIntegralType for details on   the integral performed. This function works on the staggered grid.</p><p>Inputs:     mesh_s: mesh object on solution mesh     mesh_f: mesh object on flux mesh     sbp_s: SBP operator on solution mesh     sbp_f: SBP operator on flux mesh     face_integral_functor: a <a href="solver/euler/@doc"><code>FaceElementIntegralType</code></a> functor     flux_functor: a [<code>FluxType</code>] functor that is passed to face_integral_functor                   to use as the numerical flux function     sbpface: an AbstractFace for the flux grid     interfaces: vector of <a href="solver/euler/@doc"><code>Interfaces</code></a> that the integral will be                 computed for.</p><p>Inputs/Outputs:     eqn: equation object (implicitly lives on solution grid).  eqn.res is           updated with the results.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L162-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFaceElementIntegral-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType,SummationByParts.AbstractFace,AbstractArray{ODLCommonTools.Interface,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh" href="#EulerEquationMod.getFaceElementIntegral-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type} where var_type,EulerEquationMod.FaceElementIntegralType,ODLCommonTools.FluxType,SummationByParts.AbstractFace,AbstractArray{ODLCommonTools.Interface,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>EulerEquationMod.getFaceElementIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function loops over interfaces and computes a face integral that   uses data from all volume nodes. See <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a>   for details on the integral performed.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L126-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFluxFunctors-Tuple{ODLCommonTools.AbstractDGMesh,Any,Any,Any}" href="#EulerEquationMod.getFluxFunctors-Tuple{ODLCommonTools.AbstractDGMesh,Any,Any,Any}"><code>EulerEquationMod.getFluxFunctors</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getFluxFunctors</strong></p><p>This function retrieves the flux functors from the dictonary and   stores them to eqn.flux_func.</p><p>Inputs:     mesh: an AbstractDGMesh     sbp     eqn     opts</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L1008-L1019">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.interpolateFace-Union{Tuple{ODLCommonTools.AbstractDGMesh,Any,Any,Any,AbstractArray{T,3} where T,AbstractArray{Tsol,4}}, Tuple{Tsol}} where Tsol" href="#EulerEquationMod.interpolateFace-Union{Tuple{ODLCommonTools.AbstractDGMesh,Any,Any,Any,AbstractArray{T,3} where T,AbstractArray{Tsol,4}}, Tuple{Tsol}} where Tsol"><code>EulerEquationMod.interpolateFace</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.interpolateFace</strong></p><p>This function interpolates the solution values from the internal nodes   to the face flux points of the elements</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh: an AbstractDGMesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>q: a 3D array of solution values at the nodes, numDofPerNode x   numNodesPerElement x numEl</p></li></ul><p><strong>Inputs/Outputs</strong>:</p><ul><li><p>q_face: a 4D array of solution values at each interface,        numDofPerNode x 2 x numfacenodes x numInterface        q_face[:, 1, j, i] stores the q values for elementL of interface        i node j and q_face[:, 2, j, i] stores the values for elementR</p></li></ul><p>eqn.aux_vars_face is also populated</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L736-L759">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.FluxDict" href="#EulerEquationMod.FluxDict"><code>EulerEquationMod.FluxDict</code></a> — <span class="docstring-category">Constant</span>.</div><div><p><strong>EulerEquationMod.FluxDict</strong></p><p>This dictonary maps the names of the fluxes (Strings) to the   functor object itself.  All flux functors should be added to the dictionary.</p><p>All fluxes have one method that calculates the flux in a particular direction   at a node.  Some fluxes have an additional method that computes the flux   in several directions at a node in a single function call, which can be   more efficient.  See calcEulerFlux_standard for an example.</p><p>In general, these functors call similarly-named function in bc_solvers.jl.   It is recommened to look at the documentation for those functions.</p><p>TODO: document signature of the functors here</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L979-L995">source</a></section><h2><a class="nav-anchor" id="sec:euler_flux_functors-1" href="#sec:euler_flux_functors-1">Flux Functors</a></h2><p>TODO: move this to another file (both code and docs)</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.DucrosFlux" href="#EulerEquationMod.DucrosFlux"><code>EulerEquationMod.DucrosFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_Ducros-Union{Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N} where N,AbstractArray{Tmsh,N} where N,AbstractArray{Tres,1}}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>calcEulerFlux_Ducros</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L902-L904">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ErrorFlux" href="#EulerEquationMod.ErrorFlux"><code>EulerEquationMod.ErrorFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This flux function throws an error. Useful for defaults.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L797-L799">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.IRFlux" href="#EulerEquationMod.IRFlux"><code>EulerEquationMod.IRFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_IR-Union{Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N} where N,AbstractArray{Tmsh,1},AbstractArray{Tres,1}}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>calcEulerFlux_IR</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L919-L921">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.IRSLFFlux" href="#EulerEquationMod.IRSLFFlux"><code>EulerEquationMod.IRSLFFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_IRSLF-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>calcEulerFlux_IRSLF</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L937-L939">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.IdentityFlux" href="#EulerEquationMod.IdentityFlux"><code>EulerEquationMod.IdentityFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This flux function sets F = q.  Useful for testing</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L814-L816">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.LFFlux" href="#EulerEquationMod.LFFlux"><code>EulerEquationMod.LFFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls <a href="flux_functions.html#EulerEquationMod.calcEulerFlux_standard-Union{Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,2},AbstractArray{Tres,2}}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>calcEulerFlux_standard</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L870-L872">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.RoeFlux" href="#EulerEquationMod.RoeFlux"><code>EulerEquationMod.RoeFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls the <a href="flux_functions.html#EulerEquationMod.RoeSolver-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tsol where Tmsh"><code>RoeSolver</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L852-L854">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.SIPGViscousFlux" href="#EulerEquationMod.SIPGViscousFlux"><code>EulerEquationMod.SIPGViscousFlux</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Calls the <a href="solver/euler/@ref"><code>SIPG</code></a> (viscous) flux</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/solver/euler/flux.jl#L954-L956">source</a></section><footer><hr/><a class="previous" href="volume_diff.html"><span class="direction">Previous</span><span class="title">Volume Integrals Jacobian</span></a><a class="next" href="flux_diff.html"><span class="direction">Next</span><span class="title">Face Integrals Jacobian</span></a></footer></article></body></html>

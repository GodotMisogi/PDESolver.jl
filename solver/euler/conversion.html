<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conversion · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li class="current"><a class="toctext" href="conversion.html">Conversion</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="homotopy.html">Homotopy</a></li><li><a class="toctext" href="homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="conversion.html">Conversion</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/solver/euler/conversion.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Conversion</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Conversion-Between-Different-Variables-1" href="#Conversion-Between-Different-Variables-1">Conversion Between Different Variables</a></h1><p>It is possible to write the Euler equations in terms of different sets of variables. The default is to use conservative variables, but there are others as well, such as entropy variables. This page describes how to convert between the different sets of variables. The functions perform conversions back and forth between conservative variables and the &quot;other&quot; variables. The code generally does not support conversion directly between two different sets of &quot;other variables. For example, if we call the conservative variables the <code>q</code> variables, the  first set of &quot;other&quot; variables the <code>w1</code> variables and the second set of &quot;other&quot; variables the <code>w2</code> variables, it is possible to convert between <code>q</code> and <code>w1</code> as well as <code>q</code> and <code>w2</code> but not between <code>w1</code> and <code>w2</code>.</p><p>The basic set of functions perform the conversion, and these function&#39;s names and in an underscore. Layered on top of these functions are a safer method of conversion, which uses the static parameters of the <a href="types.html#EulerEquationMod.ParamType"><code>ParamType</code></a> to determine what variables are stored in <code>eqn.q</code> and performs the appropriate conversion. This is important because if, for example, we are solving the equation using entropy variables, and the function <a href="conversion.html#EulerEquationMod.convertToEntropy-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>convertToEntropy</code></a> is called, it will (correctly) not do the conversion, because the variables are already the entropy variables. If <a href="conversion.html#EulerEquationMod.convertToConservative-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>convertToConservative</code></a> is called, it will do the proper conversion from entropy to conservative variables.</p><p>The function describe here provide one additional bit of functionality. Lets say a function needs to convert it current variables to conservative variables, do some operation, then convert the result back to entropy variables. Converting to conservative variables is easy, that&#39;s what <a href="conversion.html#EulerEquationMod.convertToConservative-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>convertToConservative</code></a> does.  The problem is converting back. The code doesn&#39;t necessarily know what variables are stored in <code>eqn.q</code>, so it doesn&#39;t know what function to call.  Should it call <code>convertToW1</code> or <code>convertToW2</code>? The solution is <a href="conversion.html#EulerEquationMod.convertFromNaturalToWorkingVars-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>convertFromNaturalToWorkingVars</code></a>, which converts from the conservative variables to whatever the variables stored in <code>eqn.q</code> are (as determined by the static parameters of the <code>ParamType</code> object).</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertFromNaturalToWorkingVars-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim" href="#EulerEquationMod.convertFromNaturalToWorkingVars-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>EulerEquationMod.convertFromNaturalToWorkingVars</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertFromNaturlaToWorkingVars</strong></p><p>This function converts a vector qc from the &quot;natural&quot; set of variables to    write the equation to the set of variables the equation is being solved in,    defined by the static parameter var_type of the params.  For the Euler    equations, the &quot;natural&quot; variables are the conservative variables.   Every new set of variables must extend this function with a new method.</p><p>Inputs:     params:  ParamType{Tdim, var_type}     qc: vector of &quot;natural&quot; variables</p><p>Inputs/Outputs:     qe: vector to be populated with the new variables</p><p>Low level function.</p><p>Aliasing restrictions: none (this requires that every method of this function                          support in-place conversion).</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L312-L333">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToConservative-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim" href="#EulerEquationMod.convertToConservative-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>EulerEquationMod.convertToConservative</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>low level function</strong></p><p>Converts conservative variables to conservative variables (ie. it   copies the input to the output).  This method exists to values can be    converted without knowing whether they are conservative or entropy.</p><p>Aliasing restrictions: none (qc and qe <em>can</em> be the same vector)</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L290-L299">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToConservative-Union{Tuple{EulerEquationMod.ParamType{Tdim,:entropy,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim" href="#EulerEquationMod.convertToConservative-Union{Tuple{EulerEquationMod.ParamType{Tdim,:entropy,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>EulerEquationMod.convertToConservative</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToConservative</strong></p><p>Converts  the entropy variables at a node to the conservative variables.</p><p>Inputs:   params  : ParamType{2, :entropy} used to dispatch to the proper method   qe  : vector (of length 4) of entropy variables</p><p>Inputs/outputs   qc : vector (of length 4) of conservative variables.  Contents of vector are        overwritten</p><p>Aliasing: none (qc and qe <em>can</em> be the same vector)</p><p>Ths is a low level function.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L265-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToConservative-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:entropy},Any,AbstractArray{Tsol,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tdim where Tsol where Tmsh" href="#EulerEquationMod.convertToConservative-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:entropy},Any,AbstractArray{Tsol,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tdim where Tsol where Tmsh"><code>EulerEquationMod.convertToConservative</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>mid level function</strong></p><p>Converts the array (3D form) of entropy variables to conservative variables    in place.  If the array is already in conservative variables this is a no-op.   Other methods exist if q_arr is a vector.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:     q_arr: array of values (3D) to be converted</p><p>Aliasing: no restrictions</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L345-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToConservativeFromIR_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol" href="#EulerEquationMod.convertToConservativeFromIR_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol"><code>EulerEquationMod.convertToConservativeFromIR_</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToConservativeFromIR_</strong></p><p>Converts the IR entropy variables at a node to the conservative variables   regardless of the static parameter var_type.</p><p>Inputs:   params  : ParamType{Tdim} used to dispatch to the proper method   qe  : vector (of length 4 or 5) of entropy variables</p><p>Inputs/outputs   qc : vector (of length 4 or 5) of conservative variables.  Contents of         vector are overwritten</p><p>Aliasing: none (qc and qe <em>can</em> be the same vector)</p><p>Ths is a low level function.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L206-L223">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToConservative_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol" href="#EulerEquationMod.convertToConservative_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol"><code>EulerEquationMod.convertToConservative_</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToConservative_</strong></p><p>Converts  the entropy variables at a node to the conservative variables   regardless of the static parameter var_type.</p><p>Inputs:   params  : ParamType{Tdim} used to dispatch to the proper method   qe  : vector (of length 4 or 5) of entropy variables</p><p>Inputs/outputs   qc : vector (of length 4 or 5) of conservative variables.  Contents of vector are        overwritten</p><p>Aliasing: none (qc and qe <em>can</em> be the same vector)</p><p>Ths is a low level function.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L92-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToEntropy-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim" href="#EulerEquationMod.convertToEntropy-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>EulerEquationMod.convertToEntropy</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToEntropy</strong></p><p>Converts the conservative variables at a node to entropy variables</p><p>Input:   params : ParamType{s, :conservative}   qc  : vector (of length 4 or 5) of conservative variables</p><p>Outputs:   qe : vector (of length 4 or 5) of conservative variables.  Contents of         vector areoverwritten</p><p><strong>low level function</strong></p><p>Aliasing restrictions: none (qc and qe <em>can</em> be the same vector)</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L418-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToEntropy-Union{Tuple{EulerEquationMod.ParamType{Tdim,:entropy,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim" href="#EulerEquationMod.convertToEntropy-Union{Tuple{EulerEquationMod.ParamType{Tdim,:entropy,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tdim}, Tuple{Tsol}} where Tsol where Tdim"><code>EulerEquationMod.convertToEntropy</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToEntropy</strong></p><p>Converts the entropy variables to entropy variables (ie. it copies the    input to the output).  This method exists so variables can be converted    to entropy variables without knowing what type they are.</p><p><strong>low level function</strong></p><p>Aliasing restrictions: none (qc and qe <em>can</em> be the same vector)</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L444-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToEntropy-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any,AbstractArray{Tsol,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tdim where Tsol where Tmsh" href="#EulerEquationMod.convertToEntropy-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any,AbstractArray{Tsol,3}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tres where Tdim where Tsol where Tmsh"><code>EulerEquationMod.convertToEntropy</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>mid level function</strong></p><p>Converts the array (3D form) of conservative variables to entropy variables    in place.  If the array is already in entropy variables this is a no-op</p><p>Methods also exist for the 1D form.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:     q_arr: array of values (3D) to be converted</p><p>Aliasing: no restrictions</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L491-L509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToEntropy_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol" href="#EulerEquationMod.convertToEntropy_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol"><code>EulerEquationMod.convertToEntropy_</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToEntropy_</strong></p><p>Converts the conservative variables at a node to the entropy variables   regardless of the static parameter var_type.</p><p>Inputs:   params  : ParamType{Tdim} used to dispatch to the proper method   qe  : vector (of length 4 or 5) of conservative variables</p><p>Inputs/outputs   qc : vector (of length 4 or 5) of entropy variables.  Contents of vector are        overwritten</p><p>Aliasing: none (qc and qe <em>can</em> be the same vector)</p><p>Ths is a low level function.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L31-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.convertToIR_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol" href="#EulerEquationMod.convertToIR_-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1}}, Tuple{Tsol}} where Tsol"><code>EulerEquationMod.convertToIR_</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.convertToIR_</strong></p><p>Converts the conservative variables at a node to the entropy variables   of Ismail and Roe regardless of the static parameter var_type.</p><p>Inputs:   params  : ParamType{Tdim} used to dispatch to the proper method   qe  : vector (of length 4 or 5) of conservative variables</p><p>Inputs/outputs   qc : vector (of length 4 or 5) of entropy variables.  Contents of vector are        overwritten</p><p>Aliasing: none (qc and qe <em>can</em> be the same vector)</p><p>Ths is a low level function.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/conversion.jl#L142-L159">source</a></section><footer><hr/><a class="previous" href="common.html"><span class="direction">Previous</span><span class="title">Common Functions</span></a><a class="next" href="flux_functions.html"><span class="direction">Next</span><span class="title">Numerical Flux Functions</span></a></footer></article></body></html>

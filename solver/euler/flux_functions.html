<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Flux Functions · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li class="current"><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a><ul class="internal"></ul></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="flux_functions.html">Numerical Flux Functions</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/25b6184b6ed01517269a185da4b4c0863ad100b1/docs/src/solver/euler/flux_functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Numerical-Flux-Functions-1" href="#Numerical-Flux-Functions-1">Numerical Flux Functions</a></h1><p>This page documents the numerical flux functions available in the code</p><p>bc_solvers.jl should be renamed to this</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.RoeSolver" href="#EulerEquationMod.RoeSolver"><code>EulerEquationMod.RoeSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>EulerEquationMod.RoeSolver</strong></p><p>This calculates the Roe flux for boundary conditions at a node. The inputs   must be in <em>conservative</em> variables.</p><p>Inputs:   q  : conservative variables of the fluid   qg : conservative variables of the boundary   aux_vars : vector of all auxiliary variables at this node   dxidx : dxidx matrix at the node   nrm : sbp face normal vector   params : ParamType   use_efix: 1 = use entropy fix, 0 = do not use entropy fix (integer)</p><p>Outputs:     flux : vector to populate with solution</p><p>Aliasing restrictions:  none of the inputs can alias params.res_vals1,                           params.res_vals2, params.q_vals, params.flux_vals1, or                           params.sat</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.RoeSolver" href="#EulerEquationMod.RoeSolver"><code>EulerEquationMod.RoeSolver</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The main Roe solver.  Populates <code>flux</code> with the computed flux.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.RoeSolver_revm" href="#EulerEquationMod.RoeSolver_revm"><code>EulerEquationMod.RoeSolver_revm</code></a> — <span class="docstring-category">Function</span>.</div><div><p>###EulerEquationMod.RoeSolver_revm</p><p>Reverse mode of <code>EulerEquationMod.RoeSolver</code>. This function computes the reverse mode of the Roe flux w.r.t the mesh metrics</p><p><strong>Inputs</strong></p><ul><li><code>params</code> : Parameter object</li><li><code>q</code>  : Conservative variable of the fluid</li><li><code>qg</code> : Conservative variable of the boundary or the adjacent element</li><li><code>aux_vars</code> : Auxiliary variables</li><li><code>nrm</code> : Element face normal vector in the physical space</li><li><code>flux_bar</code> : Flux value which needs to get differentiated</li></ul><p><strong>Output</strong></p><ul><li><code>nrm_bar</code> : derivaitve of the flux_bar w.r.t the mesh metrics</li></ul><p>Aliasing Restrictions: Same as the forward function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_Ducros-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcEulerFlux_Ducros-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcEulerFlux_Ducros</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculates the numerical flux function associated with the Ducros flux   splitting.  Methods are available for 2D and 3D.</p><p><strong>Inputs</strong>:</p><ul><li>params:</li><li>qL: the left state</li><li>qR: the right state</li><li>aux_vars: the aux vars for the left state</li><li>dir: the direction vector</li></ul><p><strong>Inputs/Outputs</strong>:</p><ul><li>F: vector to be populated with the flux</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_IR-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcEulerFlux_IR-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcEulerFlux_IR</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates the Ismail-Roe numerical flux at a node in a   specified direction</p><p><strong>Inputs</strong>:</p><ul><li>params: ParamType</li><li>qL: left state vector</li><li>qR: right state vector</li><li>aux_vars: auxiliary variable vector for qL</li><li>dir: a direction vector of length Tdim</li></ul><p><strong>Inputs/Outputs</strong>:</p><ul><li>F: a numDofPerNode x Tdim matrix where each column will be populated with        the flux in the direction specified by the corresponding column of nrm</li></ul><p>Aliasing Restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_IR-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcEulerFlux_IR-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcEulerFlux_IR</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function computes the Ismail-Roe   flux in Tdim directions at once for a given state.  This is more efficient   Than calling the single direction method Tdim times.  Methods are available   for 2 and 3 dimensions.</p><p><strong>Inputs</strong>:</p><ul><li>params: ParamType</li><li>qL: left state vector</li><li>qR: right state vector</li><li>aux_vars: auxiliary variable vector for qL</li><li>dir: a Tdim x Tdim matrix with each column containing a normal vector</li></ul><p><strong>Inputs/Outputs</strong>:</p><ul><li>F: a numDofPerNode x Tdim matrix where each column will be populated with        the flux in the direction specified by the corresponding column of nrm</li></ul><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_IRSLF-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcEulerFlux_IRSLF-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcEulerFlux_IRSLF</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This is the second method that takes in a normal vector directly.   See the first method for a description of what this function does.</p><p>Inputs     qL, qR: vectors conservative variables at left and right states     aux_vars: aux_vars for qL     nrm: a normal vector in xy space</p><p>Inputs/Outputs     F: vector to be updated with the result</p><p>Alising restrictions:     See getEntropyLFStab</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_IRSLW-Tuple{EulerEquationMod.ParamType{Tdim,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,2},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcEulerFlux_IRSLW-Tuple{EulerEquationMod.ParamType{Tdim,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,2},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcEulerFlux_IRSLW</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is similar to calcEulerFlux_IRSLF, but uses Lax-Wendroff   dissipation rather than Lax-Friedrich.</p><p>Aliasing restrictions: see getEntropyLWStab</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_standard-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcEulerFlux_standard-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcEulerFlux_standard</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function computes the split form flux corresponding to the standard   flux in Tdim directions at once for a given state.  This is more efficient   Than calling the single direction method Tdim times.  Methods are available   for 2 and 3 dimensions.</p><p>Inputs:     params: ParamType     qL: left state vector     qR: right state vector     aux_vars: auxiliary variable vector for qL     dir: a Tdim x Tdim matrix with each column containing a normal vector</p><p>Inputs/Outputs:     F: a numDofPerNode x Tdim matrix where each column will be populated with        the flux in the direction specified by the corresponding column of nrm</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSAT" href="#EulerEquationMod.calcSAT"><code>EulerEquationMod.calcSAT</code></a> — <span class="docstring-category">Function</span>.</div><div><p>###EulerEquationMod.calcSAT</p><p>Computes the simultaneous approximation term for use in computing the numerical flux</p><p><strong>Arguments</strong></p><ul><li><code>params</code> : Parameter object of type ParamType</li><li><code>nrm</code> : Normal to face in the physical space</li><li><code>dq</code>  : Boundary condition penalty variable</li><li><code>sat</code> : Simultaneous approximation Term</li><li><code>u</code>   : Velocity in the X-direction in physical space</li><li><code>v</code>   : Velocity in the Y-direction in physical space</li><li><code>H</code>   : Total enthalpy</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSAT_revm" href="#EulerEquationMod.calcSAT_revm"><code>EulerEquationMod.calcSAT_revm</code></a> — <span class="docstring-category">Function</span>.</div><div><p>###EulerEquationMod.calcSAT_revm</p><p>Reverse mode of calcSAT</p><p><strong>Inputs</strong> * <code>params</code> : Parameter object of type ParamType * <code>nrm</code> : Normal to face in the physical space * <code>dq</code>  : Boundary condition penalty variable * <code>vel</code> : Velocities along X &amp; Y directions in the physical space * <code>H</code>   : Total enthalpy * <code>sat_bar</code> : Inpute seed for sat flux whose derivative needs to be computed</p><p><strong>Output</strong></p><ul><li><code>nrm_bar</code> : derivative of <code>sat_bar</code> w.r.t physical normal vector</li></ul></div></section><footer><hr/><a class="previous" href="conversion.html"><span class="direction">Previous</span><span class="title">Conversion</span></a><a class="next" href="stabilization.html"><span class="direction">Next</span><span class="title">Stabilization</span></a></footer></article></body></html>

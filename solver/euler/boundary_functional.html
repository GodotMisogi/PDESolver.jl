<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Functional · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li class="current"><a class="toctext" href="boundary_functional.html">Boundary Functional</a><ul class="internal"></ul></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="boundary_functional.html">Boundary Functional</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/19f30b217586c60605da6ee211a53cfeec84bf1c/docs/src/solver/euler/boundary_functional.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Euler-Boundary-Functional-1" href="#Euler-Boundary-Functional-1">Euler Boundary Functional</a></h1><p>This page consists of all the functions necessary for computing a boundary functional along the geometric edges of a mesh for Euler equations. A boundary functional should ALWAYS be evaluated by calling <code>evalFunctional</code> which is the highest level function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcBndryFunctional-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,EulerEquationMod.BoundaryForceData{Topt,fname}}" href="#EulerEquationMod.calcBndryFunctional-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,EulerEquationMod.BoundaryForceData{Topt,fname}}"><code>EulerEquationMod.calcBndryFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcBndryFunctional</strong></p><p>This function calculates a functional on a geometric boundary of a the computational space. This is a mid level function that should not be called from outside the module. Depending on the functional being computed, it may be necessary to define another method for this function based on a different boundary functional type or parameters.</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code> :  Abstract mesh object</li><li> <code>sbp</code>  : Summation-By-Parts operator</li><li> <code>eqn</code>  : Euler equation object</li><li> <code>opts</code> : Options dictionary</li><li> <code>functionalData</code> : Object which is a subtype of Abstract OptimizationData.                       This is type is associated with the functional being                       computed and holds all the relevant data.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalFunctional-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.AbstractOptimizationData}" href="#EulerEquationMod.evalFunctional-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.AbstractOptimizationData}"><code>EulerEquationMod.evalFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.evalFunctional</strong></p><p>Hight level function that evaluates all the functionals specified over various edges. This function is agnostic to the type of the functional being computed and calls a mid level functional-type specific function for the actual evaluation.</p><p><strong>Arguments</strong></p><ul><li> <code>mesh</code> :  Abstract mesh object</li><li> <code>sbp</code>  : Summation-By-Parts operator</li><li> <code>eqn</code>  : Euler equation object</li><li> <code>opts</code> : Options dictionary</li><li> <code>functionalData</code> : Object of type AbstractOptimizationData. This is type is associated                       with the functional being computed and holds all the                       relevant data.</li><li> <code>functional_number</code> : A number identifying which functional is being computed.                          This is important when multiple functions, that aren&#39;t                          objective functions are being evaluated. Default value                          is 1.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.eval_dJdaoa-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.AbstractOptimizationData,ASCIIString,AbstractArray{Tsol,1}}" href="#EulerEquationMod.eval_dJdaoa-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.AbstractOptimizationData,ASCIIString,AbstractArray{Tsol,1}}"><code>EulerEquationMod.eval_dJdaoa</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.eval_dJdaoa</strong></p><p>Compute the complete derivative of a functional w.r.t angle of attack</p><p><strong>Inputs</strong></p><ul><li><code>mesh</code> : Abstract mesh object</li><li><code>sbp</code>  : Summation-By-Parts operator</li><li><code>eqn</code>  : Euler equation object</li><li><code>opts</code> : Options dictionary</li><li><code>functionalData</code> : Object of type AbstractOptimizationData. This is type is associated                      with the functional being computed and holds all the                      relevant data.</li><li><code>functionalName</code> : Name of the functional being evaluated</li><li><code>adjoint_vec</code> : Local portion of the adjoint vector owned by an MPI rank</li></ul><p><strong>Output</strong></p><ul><li><code>dJdaoa</code> : Complete derivative of the functional w.r.t angle of attack              This is a scalar value that is the same across all MPI ranks</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcBoundaryFunctionalIntegrand-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Int64,N},EulerEquationMod.BoundaryForceData{Topt,fname},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcBoundaryFunctionalIntegrand-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Int64,N},EulerEquationMod.BoundaryForceData{Topt,fname},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcBoundaryFunctionalIntegrand</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcBoundaryFunctionalIntegrand</strong></p><p>Computes the integrand for boundary functional at a surface SBP node. Every functional of a different type may need a corresponding method to compute the integrand. The type of the functional object, which is a subtype of <code>AbstractOptimizationData</code>.</p><p><strong>Arguments</strong></p><ul><li> <code>params</code> : eqn.params object</li><li> <code>q</code> : Nodal solution</li><li> <code>aux_vars</code> : Auxiliary variables</li><li> <code>nrm</code> : Face normal vector in the physical space</li><li> <code>node_info</code> : Information about the SBP node</li><li> <code>objective</code> : Functional data type</li><li> <code>val</code> : Function output value</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcBoundaryFunctionalIntegrand_revm-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Int64,N},EulerEquationMod.BoundaryForceData{Topt,fname},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcBoundaryFunctionalIntegrand_revm-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Int64,N},EulerEquationMod.BoundaryForceData{Topt,fname},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcBoundaryFunctionalIntegrand_revm</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod. calcBoundaryFunctionalIntegrand_revm</strong></p><p>Reverse mode for boundary functional integrand w.r.t. nrm. Takes in input val_bar and return nrm_bar for further reverse propagation.</p><p><strong>Arguments</strong></p><ul><li> <code>params</code> : eqn.params object</li><li> <code>q</code> : Nodal solution</li><li> <code>aux_vars</code> : Auxiliary variables</li><li> <code>nrm</code> : Face normal vector in the physical space</li><li> <code>node_info</code> : Information about the SBP node</li><li> <code>objective</code> : Functional data type</li><li> <code>nrm_bar</code> : Resulting vector</li><li> <code>val_bar</code> : Nodal portion of the seeding vector</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalFunctional_revm-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.AbstractOptimizationData,ASCIIString}" href="#EulerEquationMod.evalFunctional_revm-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.AbstractOptimizationData,ASCIIString}"><code>EulerEquationMod.evalFunctional_revm</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.evalFunctional_revm</strong></p><p>Reverse mode of EulerEquationMod.evalFunctional, It takes in functional value and return <code>mesh.nrm_bndry_bar</code>. Different functionals will need to be added to the if statement to further extend this function.</p><p><strong>Arguments</strong></p><ul><li> <code>mesh</code> :  Abstract mesh object</li><li> <code>sbp</code>  : Summation-By-Parts operator</li><li> <code>eqn</code>  : Euler equation object</li><li> <code>opts</code> : Options dictionary</li><li> <code>functionalData</code> : Object of type AbstractOptimizationData. This is type is associated                       with the functional being computed and holds all the                       relevant data.</li><li> <code>functionalName</code> : Name of the functional being evaluated.</li></ul></div></section><footer><hr/><a class="previous" href="adjoint.html"><span class="direction">Previous</span><span class="title">Adjoint</span></a><a class="next" href="misc.html"><span class="direction">Next</span><span class="title">Misc</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Face Element Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="flux_diff.html">Face Integrals Jacobian</a></li><li class="current"><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Flux-Functors-1">Flux Functors</a></li></ul></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="homotopy.html">Homotopy</a></li><li><a class="toctext" href="homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="faceElementIntegrals.html">Face Element Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/solver/euler/faceElementIntegrals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Face Element Integrals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="sec:euler_face_element_integrals-1" href="#sec:euler_face_element_integrals-1">Face Element Integrals</a></h1><p>This page describes the functions that evaluate the face element integrals for a single interface.  The functions that loop over all the interfaces are located on the <a href="flux.html#sec:euler_face_integrals-1">face integrals</a> page. These integrals require data from all the nodes of the elements rather than the face nodes as with regular face integrals.</p><p>These integrals are used by the entropy stable scheme, and some of them internally use a <a href="flux.html#sec:euler_flux_functors-1">numerical flux function</a>.  This flux function must satisfy an entropy property for the resulting scheme to be entropy stable!  The IR flux function is typically used.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcECFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcECFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcECFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integrals in an entropy conservative manner for a given   interface.  Unlike standard face integrals, this requires data from   the entirety of both elements, not just data interpolated to the face</p><p>resL and resR are updated with the results of the computation for the    left and right elements, respectively.</p><p>Note that nrm_xy must contains the normal vector in x-y space at the   face nodes.</p><p>The flux function must be symmetric!</p><p>Aliasing restrictions: none, although its unclear what the meaning of this                          function would be if resL and resR alias</p><p>Performance note: the version in the tests is the same speed as this one                     for p=1 Omega elements and about 10% faster for                      p=4 elements, but would not be able to take advantage of                      the sparsity of R for SBP Gamma elements</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L16-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcECFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.SparseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcECFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.SparseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcECFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for sparse faces.  See other method for details</p><p>Aliasing restrictions: params.flux_vals1 must not be in use</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L101-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcESLFFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcESLFFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcESLFFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integral in an entropy stable manner using Lax-Friedrich   type dissipation.     This uses calcECFaceIntegral and calcLFEntropyPenaltyIntegral internally,    see those functions for details.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L148-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcESLW2FaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcESLW2FaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcESLW2FaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integral in an entropy stable manner using   Lax-Wendroff type dissipation.     This uses calcECFaceIntegral and calcLW2EntropyPenaltyIntegral internally,    see those functions for details.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L200-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcESLWFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcESLWFaceIntegral-Union{Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcESLWFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integral in an entropy stable manner using approximate   Lax-Wendroff type dissipation.     This uses calcECFaceIntegral and calcLWEntropyPenaltyIntegral internally,    see those functions for details.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L174-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEntropyFix-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{T,1} where T}" href="#EulerEquationMod.calcEntropyFix-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{T,1} where T}"><code>EulerEquationMod.calcEntropyFix</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function modifies the eigenvalues of the euler flux jacobian such   that if any value is zero, a little dissipation is still added.  The   absolute values of the eigenvalues modified eigenvalues are calculated.</p><p>Methods are available for 2 and 3 dimensions</p><p>This function depends on the ordering of the eigenvalues produced by   calcEvals.</p><p>Inputs:     params: ParamType, used to dispatch to 2 or 3D method</p><p>Inputs/Outputs:     Lambda: vector of eigenvalues to be modified</p><p>Aliasing restrictions: none</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L806-L823">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLFEntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcLFEntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcLFEntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate a term that provably dissipates (mathematical) entropy using a    Lax-Friedrich type of dissipation.     This   requires data from the left and right element volume nodes, rather than   face nodes for a regular face integral.</p><p>Note that nrm_face must contain the scaled face normal vector in x-y space   at the face nodes, and qL, qR, resL, and resR are the arrays for the   entire element, not just the face.</p><p>Aliasing restrictions: params.nrm2, params.A0, w_vals_stencil, w_vals2_stencil</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L229-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLFEntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcLFEntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcLFEntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for sparse faces.  See other method for details</p><p>Aliasing restrictions: params: v_vals, v_vals2, q_vals, A0, res_vals1, res_vals2</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L334-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLW2EntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcLW2EntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcLW2EntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate a term that provably dissipates (mathematical) entropy using a    Lax-Wendroff type of dissipation.     This requires data from the left and right element volume nodes, rather than   face nodes for a regular face integral.</p><p>Note nrm_face must contain the scaled normal vector in x-y space   at the face nodes, and qL, qR, resL, and resR are the arrays for the   entire element, not just the face.</p><p>Implementation Detail:     Because the scaling does not exist in arbitrary directions for 3D,      the function projects q into n-t coordinates, computes the     eigendecomposition there, and then rotates back</p><p>Aliasing restrictions: from params the following fields are used:     Y, S2, Lambda, res_vals1, res_vals2,  w_vals_stencil,      w_vals2_stencil, v_vals, v_vals2, q_vals, q_vals2, nrm2, P</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L566-L585">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLW2EntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcLW2EntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcLW2EntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for sparse faces.  See other method for details</p><p>Aliasing restrictions: params: v_vals, v_vals2, q_vals, q_vals2, A0, res_vals1, res_vals2                          A0, S2, Lambda, nrm2, P</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L708-L713">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLWEntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim" href="#EulerEquationMod.calcLWEntropyPenaltyIntegral-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace,ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tmsh where Tres where Tsol where Tdim"><code>EulerEquationMod.calcLWEntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate a term that provably dissipates (mathematical) entropy using a    an approximation to Lax-Wendroff type of dissipation.     This requires data from the left and right element volume nodes, rather than   face nodes for a regular face integral.</p><p>Note that nrm_face must contain the scaled normal vector in x-y space   at the face nodes, and qL, qR, resL, and resR are the arrays for the   entire element, not just the face.</p><p>The approximation to Lax-Wendroff is the computation of</p><p>for i=1:Tdim     abs(ni<em>Y_i</em>S2_i<em>Lambda_i</em>Y_i.&#39;)   end</p><p>rather than computing the flux jacobian in the normal direction.</p><p>Aliasing restrictions: from params the following fields are used:     Y, S2, Lambda, res_vals1, res_vals2, res_vals3,  w_vals_stencil,      w_vals2_stencil, v_vals, v_vals2, q_vals, q_vals2</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L400-L421">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFaceElementFunctors-Tuple{Any,Any,EulerEquationMod.AbstractEulerData,Any}" href="#EulerEquationMod.getFaceElementFunctors-Tuple{Any,Any,EulerEquationMod.AbstractEulerData,Any}"><code>EulerEquationMod.getFaceElementFunctors</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Populates the field(s) of the EulerData object with   <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a> functors as specified by the options   dictionary</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an AbstractMesh</p></li><li><p>sbp: an SBP operator</p></li><li><p>opts: the options dictionary</p></li></ul><p><strong>Inputs/Outputs</strong></p><ul><li><p>eqn: the EulerData object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L1036-L1050">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getEntropyLFStab-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N} where N,AbstractArray{Tmsh,N} where N,AbstractArray{Tres,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh" href="#EulerEquationMod.getEntropyLFStab-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N} where N,AbstractArray{Tmsh,N} where N,AbstractArray{Tres,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>EulerEquationMod.getEntropyLFStab</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function computes the entropy dissipation term using Lax-Friedrich   type dissipation.  The term is evaluated using simple averaging of   qL and qR.  The term is subtracted off of F.</p><p>This function is dimension agnostic, but only works for conservative   variables.</p><p>Aliasing restrictions: params.q_vals3, see also getEntropyLFStab_inner</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/IR_stab.jl#L114-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getEntropyLFStab_inner-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,N} where N,AbstractArray{Tres,N} where N,AbstractArray{Tmsh,N} where N,AbstractArray{Tres,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh" href="#EulerEquationMod.getEntropyLFStab_inner-Union{Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,N} where N,AbstractArray{Tres,N} where N,AbstractArray{Tmsh,N} where N,AbstractArray{Tres,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tres}, Tuple{Tsol}} where Tdim where Tres where Tsol where Tmsh"><code>EulerEquationMod.getEntropyLFStab_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Updates the vector F with the stabilization term from Carpenter, Fisher,   Nielsen, Frankel, Entrpoy stable spectral collocation schemes for the    Navier-Stokes equatiosn: Discontinuous interfaces.  The term is subtracted   off from F.</p><p>The q_avg vector should some average of qL and qR, but the type of    averaging is left up to the user.</p><p>This function is agnostic to dimension, but only works for conservative   variables.</p><p>Aliasing: from params the following arrays are used: A0, v_vals               v_vals2.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/IR_stab.jl#L166-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getIRA0-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,2}}, Tuple{Tsol}} where Tsol" href="#EulerEquationMod.getIRA0-Union{Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,2}}, Tuple{Tsol}} where Tsol"><code>EulerEquationMod.getIRA0</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes dq/dv, where q are the conservative variables and v are the   IR entropy variables.  This is equiavlent to calcA0 scaled by gamma_1,   but computed from the conservative variables, which is much less expensive.</p><p>Methods are available for 2 and 3 dimensions.   A0 is overwritten with the result</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/IR_stab.jl#L7-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getLambdaMaxSimple-Union{Tuple{EulerEquationMod.ParamType{Tdim,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tsol}} where Tdim where Tmsh where Tsol" href="#EulerEquationMod.getLambdaMaxSimple-Union{Tuple{EulerEquationMod.ParamType{Tdim,var_type,Tsol,Tres,Tmsh} where Tmsh where Tres where Tsol where var_type,AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,1}}, Tuple{Tdim}, Tuple{Tmsh}, Tuple{Tsol}} where Tdim where Tmsh where Tsol"><code>EulerEquationMod.getLambdaMaxSimple</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculates the maximum magnitude eigenvalue of the Euler flux    jacobian at the arithmatic average of two states.</p><p>This functions works in both 2D and 3D   Inputs:     params:  ParamType, conservative variable     qL: left state     qR: right state     dir: direction vector (does <em>not</em> have to be unit vector)</p><p>Outputs:     lambda_max: eigenvalue of maximum magnitude</p><p>Aliasing restrictions: params.q_vals3 must be unused</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/IR_stab.jl#L307-L322">source</a></section><h2><a class="nav-anchor" id="Flux-Functors-1" href="#Flux-Functors-1">Flux Functors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ECFaceIntegral" href="#EulerEquationMod.ECFaceIntegral"><code>EulerEquationMod.ECFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative term only</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L888-L890">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ELFPenaltyFaceIntegral" href="#EulerEquationMod.ELFPenaltyFaceIntegral"><code>EulerEquationMod.ELFPenaltyFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Lax-Friedrich entropy penalty term only</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L928-L930">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ELW2PenaltyFaceIntegral" href="#EulerEquationMod.ELW2PenaltyFaceIntegral"><code>EulerEquationMod.ELW2PenaltyFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Lax-Wendroff entropy penalty term only</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L1003-L1005">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ELWPenaltyFaceIntegral" href="#EulerEquationMod.ELWPenaltyFaceIntegral"><code>EulerEquationMod.ELWPenaltyFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Approximate Lax-Wendroff entropy penalty term only</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L966-L968">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ESLFFaceIntegral" href="#EulerEquationMod.ESLFFaceIntegral"><code>EulerEquationMod.ESLFFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative integral + Lax-Friedrich penalty</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L909-L911">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ESLW2FaceIntegral" href="#EulerEquationMod.ESLW2FaceIntegral"><code>EulerEquationMod.ESLW2FaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative integral + Lax-Wendroff penalty</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L985-L987">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ESLWFaceIntegral" href="#EulerEquationMod.ESLWFaceIntegral"><code>EulerEquationMod.ESLWFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative integral + approximate Lax-Wendroff penalty</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/solver/euler/faceElementIntegrals.jl#L947-L949">source</a></section><footer><hr/><a class="previous" href="flux_diff.html"><span class="direction">Previous</span><span class="title">Face Integrals Jacobian</span></a><a class="next" href="bc.html"><span class="direction">Next</span><span class="title">Boundary Integrals</span></a></footer></article></body></html>

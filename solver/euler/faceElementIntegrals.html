<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Face Element Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="flux_diff.html">Face Integrals Jacobian</a></li><li class="current"><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Flux-Functors-1">Flux Functors</a></li></ul></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="homotopy.html">Homotopy</a></li><li><a class="toctext" href="homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="faceElementIntegrals.html">Face Element Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/cd605579e05af7f90c72771fb7335177465209f5/docs/src/solver/euler/faceElementIntegrals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="sec:euler_face_element_integrals-1" href="#sec:euler_face_element_integrals-1">Face Element Integrals</a></h1><p>This page describes the functions that evaluate the face element integrals for a single interface.  The functions that loop over all the interfaces are located on the <a href="flux.html#sec:euler_face_integrals-1">face integrals</a> page. These integrals require data from all the nodes of the elements rather than the face nodes as with regular face integrals.</p><p>These integrals are used by the entropy stable scheme, and some of them internally use a <a href="flux.html#sec:euler_flux_functors-1">numerical flux function</a>.  This flux function must satisfy an entropy property for the resulting scheme to be entropy stable!  The IR flux function is typically used.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcECFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcECFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcECFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integrals in an entropy conservative manner for a given   interface.  Unlike standard face integrals, this requires data from   the entirety of both elements, not just data interpolated to the face</p><p>resL and resR are updated with the results of the computation for the    left and right elements, respectively.</p><p>Note that nrm_xy must contains the normal vector in x-y space at the   face nodes.</p><p>The flux function must be symmetric!</p><p>Aliasing restrictions: none, although its unclear what the meaning of this                          function would be if resL and resR alias</p><p>Performance note: the version in the tests is the same speed as this one                     for p=1 Omega elements and about 10% faster for                      p=4 elements, but would not be able to take advantage of                      the sparsity of R for SBP Gamma elements</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcECFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.SparseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcECFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.SparseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcECFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for sparse faces.  See other method for details</p><p>Aliasing restrictions: params.flux_vals1 must not be in use</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcESLFFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace{T<:Number},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcESLFFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace{T<:Number},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcESLFFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integral in an entropy stable manner using Lax-Friedrich   type dissipation.     This uses calcECFaceIntegral and calcLFEntropyPenaltyIntegral internally,    see those functions for details.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcESLW2FaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace{T<:Number},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcESLW2FaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace{T<:Number},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcESLW2FaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integral in an entropy stable manner using   Lax-Wendroff type dissipation.     This uses calcECFaceIntegral and calcLW2EntropyPenaltyIntegral internally,    see those functions for details.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcESLWFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace{T<:Number},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcESLWFaceIntegral-Tuple{ODLCommonTools.AbstractParamType{Tdim},SummationByParts.AbstractFace{T<:Number},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},ODLCommonTools.FluxType,AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcESLWFaceIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate the face integral in an entropy stable manner using approximate   Lax-Wendroff type dissipation.     This uses calcECFaceIntegral and calcLWEntropyPenaltyIntegral internally,    see those functions for details.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEntropyFix-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{T,1}}" href="#EulerEquationMod.calcEntropyFix-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{T,1}}"><code>EulerEquationMod.calcEntropyFix</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function modifies the eigenvalues of the euler flux jacobian such   that if any value is zero, a little dissipation is still added.  The   absolute values of the eigenvalues modified eigenvalues are calculated.</p><p>Methods are available for 2 and 3 dimensions</p><p>This function depends on the ordering of the eigenvalues produced by   calcEvals.</p><p>Inputs:     params: ParamType, used to dispatch to 2 or 3D method</p><p>Inputs/Outputs:     Lambda: vector of eigenvalues to be modified</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLFEntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcLFEntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcLFEntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate a term that provably dissipates (mathematical) entropy using a    Lax-Friedrich type of dissipation.     This   requires data from the left and right element volume nodes, rather than   face nodes for a regular face integral.</p><p>Note that nrm_face must contain the scaled face normal vector in x-y space   at the face nodes, and qL, qR, resL, and resR are the arrays for the   entire element, not just the face.</p><p>Aliasing restrictions: params.nrm2, params.A0, w_vals_stencil, w_vals2_stencil</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLFEntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcLFEntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcLFEntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for sparse faces.  See other method for details</p><p>Aliasing restrictions: params: v_vals, v_vals2, q_vals, A0, res_vals1, res_vals2</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLW2EntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcLW2EntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcLW2EntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate a term that provably dissipates (mathematical) entropy using a    Lax-Wendroff type of dissipation.     This requires data from the left and right element volume nodes, rather than   face nodes for a regular face integral.</p><p>Note nrm_face must contain the scaled normal vector in x-y space   at the face nodes, and qL, qR, resL, and resR are the arrays for the   entire element, not just the face.</p><p>Implementation Detail:     Because the scaling does not exist in arbitrary directions for 3D,      the function projects q into n-t coordinates, computes the     eigendecomposition there, and then rotates back</p><p>Aliasing restrictions: from params the following fields are used:     Y, S2, Lambda, res_vals1, res_vals2,  w_vals_stencil,      w_vals2_stencil, v_vals, v_vals2, q_vals, q_vals2, nrm2, P</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLW2EntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcLW2EntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.SparseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcLW2EntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for sparse faces.  See other method for details</p><p>Aliasing restrictions: params: v_vals, v_vals2, q_vals, q_vals2, A0, res_vals1, res_vals2                          A0, S2, Lambda, nrm2, P</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLWEntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcLWEntropyPenaltyIntegral-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},SummationByParts.DenseFace{T},ODLCommonTools.Interface,AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tres,2},AbstractArray{Tmsh,2},AbstractArray{Tres,2},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcLWEntropyPenaltyIntegral</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate a term that provably dissipates (mathematical) entropy using a    an approximation to Lax-Wendroff type of dissipation.     This requires data from the left and right element volume nodes, rather than   face nodes for a regular face integral.</p><p>Note that nrm_face must contain the scaled normal vector in x-y space   at the face nodes, and qL, qR, resL, and resR are the arrays for the   entire element, not just the face.</p><p>The approximation to Lax-Wendroff is the computation of</p><p>for i=1:Tdim     abs(ni<em>Y_i</em>S2_i<em>Lambda_i</em>Y_i.&#39;)   end</p><p>rather than computing the flux jacobian in the normal direction.</p><p>Aliasing restrictions: from params the following fields are used:     Y, S2, Lambda, res_vals1, res_vals2, res_vals3,  w_vals_stencil,      w_vals2_stencil, v_vals, v_vals2, q_vals, q_vals2</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getFaceElementFunctors-Tuple{Any,Any,EulerEquationMod.AbstractEulerData{Tsol,Tres},Any}" href="#EulerEquationMod.getFaceElementFunctors-Tuple{Any,Any,EulerEquationMod.AbstractEulerData{Tsol,Tres},Any}"><code>EulerEquationMod.getFaceElementFunctors</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Populates the field(s) of the EulerData object with   <a href="types.html#EulerEquationMod.FaceElementIntegralType"><code>FaceElementIntegralType</code></a> functors as specified by the options   dictionary</p><p><strong>Inputs</strong></p><ul><li>mesh: an AbstractMesh</li><li>sbp: an SBP operator</li><li>opts: the options dictionary</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>eqn: the EulerData object</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getEntropyLFStab-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}" href="#EulerEquationMod.getEntropyLFStab-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}"><code>EulerEquationMod.getEntropyLFStab</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function computes the entropy dissipation term using Lax-Friedrich   type dissipation.  The term is evaluated using simple averaging of   qL and qR.  The term is subtracted off of F.</p><p>This function is dimension agnostic, but only works for conservative   variables.</p><p>Aliasing restrictions: params.q_vals3, see also getEntropyLFStab_inner</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getEntropyLFStab_inner-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,N},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}" href="#EulerEquationMod.getEntropyLFStab_inner-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,N},AbstractArray{Tres,N},AbstractArray{Tmsh,N},AbstractArray{Tres,1}}"><code>EulerEquationMod.getEntropyLFStab_inner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Updates the vector F with the stabilization term from Carpenter, Fisher,   Nielsen, Frankel, Entrpoy stable spectral collocation schemes for the    Navier-Stokes equatiosn: Discontinuous interfaces.  The term is subtracted   off from F.</p><p>The q_avg vector should some average of qL and qR, but the type of    averaging is left up to the user.</p><p>This function is agnostic to dimension, but only works for conservative   variables.</p><p>Aliasing: from params the following arrays are used: A0, v_vals               v_vals2.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getIRA0-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.getIRA0-Tuple{EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.getIRA0</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes dq/dv, where q are the conservative variables and v are the   IR entropy variables.  This is equiavlent to calcA0 scaled by gamma_1,   but computed from the conservative variables, which is much less expensive.</p><p>Methods are available for 2 and 3 dimensions.   A0 is overwritten with the result</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getLambdaMaxSimple-Tuple{EulerEquationMod.ParamType{Tdim,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,1}}" href="#EulerEquationMod.getLambdaMaxSimple-Tuple{EulerEquationMod.ParamType{Tdim,var_type,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tmsh,1}}"><code>EulerEquationMod.getLambdaMaxSimple</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculates the maximum magnitude eigenvalue of the Euler flux    jacobian at the arithmatic average of two states.</p><p>This functions works in both 2D and 3D   Inputs:     params:  ParamType, conservative variable     qL: left state     qR: right state     dir: direction vector (does <em>not</em> have to be unit vector)</p><p>Outputs:     lambda_max: eigenvalue of maximum magnitude</p><p>Aliasing restrictions: params.q_vals3 must be unused</p></div></section><h2><a class="nav-anchor" id="Flux-Functors-1" href="#Flux-Functors-1">Flux Functors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ECFaceIntegral" href="#EulerEquationMod.ECFaceIntegral"><code>EulerEquationMod.ECFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative term only</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ELFPenaltyFaceIntegral" href="#EulerEquationMod.ELFPenaltyFaceIntegral"><code>EulerEquationMod.ELFPenaltyFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Lax-Friedrich entropy penalty term only</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ELW2PenaltyFaceIntegral" href="#EulerEquationMod.ELW2PenaltyFaceIntegral"><code>EulerEquationMod.ELW2PenaltyFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Lax-Wendroff entropy penalty term only</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ELWPenaltyFaceIntegral" href="#EulerEquationMod.ELWPenaltyFaceIntegral"><code>EulerEquationMod.ELWPenaltyFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Approximate Lax-Wendroff entropy penalty term only</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ESLFFaceIntegral" href="#EulerEquationMod.ESLFFaceIntegral"><code>EulerEquationMod.ESLFFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative integral + Lax-Friedrich penalty</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ESLW2FaceIntegral" href="#EulerEquationMod.ESLW2FaceIntegral"><code>EulerEquationMod.ESLW2FaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative integral + Lax-Wendroff penalty</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ESLWFaceIntegral" href="#EulerEquationMod.ESLWFaceIntegral"><code>EulerEquationMod.ESLWFaceIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Entropy conservative integral + approximate Lax-Wendroff penalty</p></div></section><footer><hr/><a class="previous" href="flux_diff.html"><span class="direction">Previous</span><span class="title">Face Integrals Jacobian</span></a><a class="next" href="bc.html"><span class="direction">Next</span><span class="title">Boundary Integrals</span></a></footer></article></body></html>

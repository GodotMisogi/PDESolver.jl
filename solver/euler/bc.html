<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Integrals · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li class="current"><a class="toctext" href="bc.html">Boundary Integrals</a><ul class="internal"><li><a class="toctext" href="#Entry-Points-1">Entry Points</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Boundary-Condition-Functors-1">Boundary Condition Functors</a></li></ul></li><li><a class="toctext" href="bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="homotopy.html">Homotopy</a></li><li><a class="toctext" href="homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="bc.html">Boundary Integrals</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/f82c3059e9af168480a64f84337d5e47d1b36528/docs/src/solver/euler/bc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Boundary-Integrals-1" href="#Boundary-Integrals-1">Boundary Integrals</a></h1><p>This page describes the functions that impose boundarya conditions. The boundary conditions are imposed weakly, using a penalty between the desired state (the boundary condition value) and the current state (the solution).</p><h2><a class="nav-anchor" id="Entry-Points-1" href="#Entry-Points-1">Entry Points</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.evalBoundaryIntegrals" href="#EulerEquationMod.evalBoundaryIntegrals"><code>EulerEquationMod.evalBoundaryIntegrals</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function evaluates the boundary integrals in the Euler equations by   calling the appropriate SBP function on eqn.bndryflux, which must be populated   before calling this function.  eqn.res is updated with the result</p><p>This is a mid level function</p></div></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcBoundaryFlux-Tuple{ODLCommonTools.AbstractCGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},ODLCommonTools.BCType,UnitRange{T<:Real},AbstractArray{ODLCommonTools.Boundary,1},AbstractArray{Tres,3}}" href="#EulerEquationMod.calcBoundaryFlux-Tuple{ODLCommonTools.AbstractCGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},ODLCommonTools.BCType,UnitRange{T<:Real},AbstractArray{ODLCommonTools.Boundary,1},AbstractArray{Tres,3}}"><code>EulerEquationMod.calcBoundaryFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcBoundaryFlux</strong></p><p>This function calculates the boundary flux for the portion of the boundary   with a particular boundary condition.  The eqn.q are converted to   conservative variables if needed</p><p>Inputs:   mesh : AbstractMesh   sbp : AbstractSBP   eqn : EulerEquation   functor : a callable object that calculates the boundary flux at a node   idx_range: the Range describing which Boundaries have the current BC   bndry_facenums:  An array with elements of type Boundary that tell which                    element faces have the boundary condition   Outputs:   bndryflux : the array to store the boundary flux, corresponds to               bndry_facenums</p><p>The functor must have the signature   functor( q, aux_vars, x, nrm_xy, bndryflux_i, eqn.params)   where q are the <em>conservative</em> variables.   where all arguments (except params) are vectors of values at a node.</p><p>params is the ParamType associated with the the EulerEquation object   nrm = mesh.sbpface.normal[:, current_node]</p><p>This is a mid level function.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcBoundaryFlux_nopre-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},ODLCommonTools.BCType,UnitRange{T<:Real},AbstractArray{ODLCommonTools.Boundary,1}}" href="#EulerEquationMod.calcBoundaryFlux_nopre-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},ODLCommonTools.BCType,UnitRange{T<:Real},AbstractArray{ODLCommonTools.Boundary,1}}"><code>EulerEquationMod.calcBoundaryFlux_nopre</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like calcBoundaryFlux, but performs the integration and updates res rather   than storing the flux.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getBCFluxes-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.getBCFluxes-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.getBCFluxes</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getBCFluxes</strong></p><p>This function calls other functions to calculate the boundary fluxes, passing   them pieces of the array needed.  This populates eqn.bndryflux.  It also   calls writeBoundary() to do any requested output.  If the options dictionary   specifies not to precompute the boundary flux, this function will do the   integration as well and update <code>eqn.res</code>.</p><p>This is a mid level function.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getBCFunctors-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.getBCFunctors-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.getBCFunctors</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getBCFunctors</strong></p><p>This function uses the opts dictionary to populate mesh.bndry_funcs with   the the functors</p><p>This is a high level function.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.interpolateBoundary-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,Any,Any,AbstractArray{T,3},AbstractArray{T,3}}" href="#EulerEquationMod.interpolateBoundary-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,Any,Any,AbstractArray{T,3},AbstractArray{T,3}}"><code>EulerEquationMod.interpolateBoundary</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.interpolateBoundary</strong></p><p>Interpolates the solution variables to the exterior boundary of the mesh   and calculates any additional quantities at the boundary of the mesh.   DG only</p><p>Inputs:     mesh: an AbstractDGMesh     sbp     eqn     opts     q : the 3D array of solution variables for all elements, numdofpernode x         numNodesPerElement x numEl</p><p>Inputs/Outputs:     q_bndry: the array to be populated with the solution interpolated to              the boundary, numdofpernode x numNodesPerFace x num boundary faces</p><pre><code class="language-none">eqn.aux_vars_bndry is also populated

Aliasing restrictions: none</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.writeBoundary-Tuple{Any,Any,Any,Any}" href="#EulerEquationMod.writeBoundary-Tuple{Any,Any,Any,Any}"><code>EulerEquationMod.writeBoundary</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.writeBoundary</strong></p><p>This function writes information about the boundary faces and fluxes to files.   It is controlled by the input argument writeboundary, of type Bool.</p><p>It generates the files:     * boundaryfaces.dat : writes mesh.bndryfaces, an array with eltype Boundary                           to a file, one element per line     * boundaryflux.dat  : writes the element, local node number and boundary                           flux to a line in a human readable format     * boundaryflux2.dat : writes the real part ofmesh.bndryflux to space                           delimited file</p><p>This is a high level function.</p></div></section><h2><a class="nav-anchor" id="Boundary-Condition-Functors-1" href="#Boundary-Condition-Functors-1">Boundary Condition Functors</a></h2><p>Each functor defines a different type of boundary condition. Because the equation is solved in the weak form, the functors compute the flux associated with the penalty that imposes the boundary condition.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.FreeStreamBC_dAlpha" href="#EulerEquationMod.FreeStreamBC_dAlpha"><code>EulerEquationMod.FreeStreamBC_dAlpha</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.FreeStreamBC_dAlpha &lt;: BCTypes</strong></p><p>This functor uses the Roe solver to calculate the flux for a boundary   state corresponding to the free stream velocity, using rho_free, Ma, aoa, and E_free</p><p>This is a low level functor</p><p><strong>Arguments</strong></p><ul><li> <code>obj</code> : Object of type BCType used for multiple dispatch. Every new boundary            condition needs to have its own type and entered in BCDict</li><li> <code>q</code>   : Solution variable</li><li> <code>aux_vars</code> : Auxiliary variables</li><li> <code>x</code>        : physical coordinates of the SBP node</li><li> <code>nrm_xy</code>      : scaled normal vector in x-y space</li><li> <code>bndryflux</code> : Computed flux value at the boundary</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.FreeStreamBC_revm" href="#EulerEquationMod.FreeStreamBC_revm"><code>EulerEquationMod.FreeStreamBC_revm</code></a> — <span class="docstring-category">Type</span>.</div><div><p>###EulerEquationMod.FreeStreamBC_revm</p><p>Reverse mode for FreeStreamBC.</p><p><strong>Inputs</strong></p><ul><li><code>obj</code> : Type of the Boundary condition being evaluated. Its a subtype of           BCType_revm</li><li><code>q</code>   : Solution variable</li><li><code>aux_vars</code> : Auxiliary variables</li><li><code>x</code>     : Node coordinates</li><li><code>nrm_xy</code>   : scaled normal vector in x-y space</li><li><code>bndryflux_bar</code> : Input flux value seed that is used to compute the reverse                     mode derivative.</li><li><code>params</code>        : equation object parameters</li></ul><p><strong>Output</strong></p><ul><li><code>nrm_bar</code> : Derivative of bndryflux_bar w.r.t the mapping jacobian</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.allOnesBC" href="#EulerEquationMod.allOnesBC"><code>EulerEquationMod.allOnesBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.allOnesBC &lt;: BCTypes</strong></p><p>This functor uses the Roe solver to calculate the flux for a boundary   state where all the conservative variables have a value 1.0</p><p>This is a low level functor</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.allZerosBC" href="#EulerEquationMod.allZerosBC"><code>EulerEquationMod.allZerosBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.allZerosBC &lt;: BCTypes</strong></p><p>This functor uses the Roe solver to calculate the flux for a boundary   state where all the conservative variables have a value 0.0</p><p>This is a low level functor</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.isentropicVortexBC" href="#EulerEquationMod.isentropicVortexBC"><code>EulerEquationMod.isentropicVortexBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.isentropicVortexBC &lt;: BCTypes</strong></p><p>This type and the associated call method define a functor to calculate   the flux using the Roe Solver using the exact InsentropicVortex solution   as boundary state.  See calcBoundaryFlux for the arguments all functors   must support.</p><p>This is a low level functor.</p><p><strong>Arguments</strong></p><ul><li> <code>obj</code> : Object of type BCType used for multiple dispatch. Every new boundary            condition needs to have its own type and entered in BCDict</li><li> <code>q</code>   : Solution variable</li><li> <code>aux_vars</code> : Auxiliary variables</li><li> <code>x</code>        : physical coordinates of the SBP node</li><li> <code>nrm_xy</code>      : sclaed face normal in physical space</li><li> <code>bndryflux</code> : Computed flux value at the boundary</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.isentropicVortexBC_physical" href="#EulerEquationMod.isentropicVortexBC_physical"><code>EulerEquationMod.isentropicVortexBC_physical</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.isentropicVortexBC_physical &lt;: BCTypes</strong></p><p>This type and the associated call method define a functor to calculate   the actual Euler flux  using the exact InsentropicVortex solution   as boundary state.  See calcBoundaryFlux for the arguments all functors   must support.</p><p>This is a low level functor.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.isentropicVortexBC_revm" href="#EulerEquationMod.isentropicVortexBC_revm"><code>EulerEquationMod.isentropicVortexBC_revm</code></a> — <span class="docstring-category">Type</span>.</div><div><p>###EulerEquationMod.isentropicVortexBC_revm</p><p>Reverse mode for isentropicVortexBC.</p><p><strong>Inputs</strong></p><ul><li><code>obj</code> : Type of the Boundary condition being evaluated. Its a subtype of           BCType_revm</li><li><code>q</code>   : Solution variable</li><li><code>aux_vars</code> : Auxiliary variables</li><li><code>x</code>     : Node coordinates</li><li><code>nrm</code>   : scaled normal vector in x-y space</li><li><code>bndryflux_bar</code> : Input flux value seed that is used to compute the reverse                     mode derivative.</li><li><code>params</code>        : equation object parameters</li></ul><p><strong>Output</strong></p><ul><li><code>nrm_bar</code> : Derivative of flux w.r.t the nrm</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.noPenetrationBC_revm" href="#EulerEquationMod.noPenetrationBC_revm"><code>EulerEquationMod.noPenetrationBC_revm</code></a> — <span class="docstring-category">Type</span>.</div><div><p>###EulerEquationMod.noPenetrationBC_revm</p><p>Reverse mode for noPenetrationBC.</p><p><strong>Input</strong></p><ul><li><code>obj</code> : Type of the Boundary condition being evaluated. Its a subtype of           BCType_revm</li><li><code>q</code>   : Solution variable</li><li><code>aux_vars</code> : Auxiliary variables</li><li><code>x</code>     : Node coordinates</li><li><code>dxidx</code> : Mapping jacobian matrix for the SBP node</li><li><code>nrm</code>   : sbpface normal vector</li><li><code>bndryflux_bar</code> : Input flux value seed that is used to compute the reverse                     mode derivative.</li><li><code>params</code>        : equation object parameters</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.unsteadyVortexBC" href="#EulerEquationMod.unsteadyVortexBC"><code>EulerEquationMod.unsteadyVortexBC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>EulerEquationMod.unsteadyVortexBC &lt;: BCTypes</strong></p><p>This type and the associated call method define a functor to calculate   the flux using the Roe Solver using the exact InsentropicVortex solution   as boundary state.  See calcBoundaryFlux for the arguments all functors   must support.</p><p>This is a low level functor.</p><p><strong>Arguments</strong></p><ul><li> <code>obj</code> : Object of type BCType used for multiple dispatch. Every new boundary            condition needs to have its own type and entered in BCDict</li><li> <code>q</code>   : Solution variable</li><li> <code>aux_vars</code> : Auxiliary variables</li><li> <code>x</code>        : physical coordinates of the SBP node</li><li> <code>dxidx</code>    : Mapping jacobian matrix for the SBP node</li><li> <code>nrm_xy</code>      : SBP face normal</li><li> <code>bndryflux</code> : Computed flux value at the boundary</li></ul></div></section><footer><hr/><a class="previous" href="faceElementIntegrals.html"><span class="direction">Previous</span><span class="title">Face Element Integrals</span></a><a class="next" href="bc_diff.html"><span class="direction">Next</span><span class="title">Boundary Integrals Jacobian</span></a></footer></article></body></html>

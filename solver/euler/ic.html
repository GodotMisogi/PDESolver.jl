<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Initial Conditions · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li class="current"><a class="toctext" href="ic.html">Initial Conditions</a><ul class="internal"><li><a class="toctext" href="#Accessing-Initial-Conditions-1">Accessing Initial Conditions</a></li><li><a class="toctext" href="#Initial-Condition-Functions-1">Initial Condition Functions</a></li></ul></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="ic.html">Initial Conditions</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/c9dbcf7dbf20f621143b33fbc19208be32d2b7c9/docs/src/solver/euler/ic.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Initial-Conditions-1" href="#Initial-Conditions-1">Initial Conditions</a></h1><p>This page describes the functions that apply initial conditions. The initial condition is loaded into the solution vector (not the 3D array). Users should call the appropriate function if they want to transfer the solution from the vector to the 3D array.</p><p>It is important to note that the initial conditions functions <em>do</em> depend on the current time <code>t</code>.  In general, an initial condition function is really a function that computes an exact solution at a given time <code>t</code>. Applying an initial condition is a special case of this (because <code>t = 0</code>). Having the initial condition functions depend on time is used to calculate errors at the end of a simulation (for cases where the exact solution is known).</p><p>Often, the initial condition function will call a function in <a href="common.html#sec:euler_common_funcs-1">common funcs</a> to evalute the exact solution at each node on the mesh.</p><p>Unlike boundary conditions, which are called many times during the execution of the code, initial conditions are called infrequently, so we do not create functors for them.</p><h2><a class="nav-anchor" id="Accessing-Initial-Conditions-1" href="#Accessing-Initial-Conditions-1">Accessing Initial Conditions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICDict" href="#EulerEquationMod.ICDict"><code>EulerEquationMod.ICDict</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Map IC names to functions.  Generally the name is the same as the function   name</p></div></section><h2><a class="nav-anchor" id="Initial-Condition-Functions-1" href="#Initial-Condition-Functions-1">Initial Condition Functions</a></h2><p>TODO: write  a macro for calling common funcs repeatedly</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICChannelMMS-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICChannelMMS-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICChannelMMS</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Initial condition of channel MMS</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICExp-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICExp-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICExp</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Assigns exp(k<em>x</em>y*z) as the initial condition, of each node, where k is    the index of the degree of freedom of the node</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICFile-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICFile-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICFile</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICFile</strong></p><p>This function reads a vector from a file on disk and set the solution to it.   The vector must contain the same number of entries as there are degrees of    freedom in the mesh. </p><p>This function is useful for things like restarting from a checkpoint.   In this case, the file should be the output of writedlm(eqn.q).  The degree    of freedom number must be the same for both simulation for this to work (the    file contains no degree of freedom number information).</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICFreeStream-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICFreeStream-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICFreeStream</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICFreeStream</strong></p><p>Sets all components of the solution to the free stream condition according   to the angle of attack and and Mach number.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICIsentropicVortex-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,N}}" href="#EulerEquationMod.ICIsentropicVortex-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,N}}"><code>EulerEquationMod.ICIsentropicVortex</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICIsentropicVortex</strong></p><p>Sets the solution to the steady isentropic vortex solution.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICIsentropicVortexWithNoise-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICIsentropicVortexWithNoise-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICIsentropicVortexWithNoise</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICIsentropicVortexWithNoise</strong></p><p>Sets the solution to the steady isentropic vortex solution plus    a small random noise component.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICOnes-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICOnes-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICOnes</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICOnes</strong></p><p>Sets all components of the solution to 1.0</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICPeriodicMMS-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICPeriodicMMS-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICPeriodicMMS</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Writes calcPeriodicMMS to the initial condition vector u0</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICRho1E2-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICRho1E2-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICRho1E2</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICRho1E2</strong></p><p>Sets all density values to 1.0 and energy values to 2.0</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICRho1E2U3-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICRho1E2U3-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICRho1E2U3</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICRho1E2U3</strong></p><p>Sets all components density values to 1.0, x and y momenta to 0.35355, and   energy to 2.0</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICTaylorGreen-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICTaylorGreen-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICTaylorGreen</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function applies the initial condition for the Taylor Green vortex,   using the constants in Gassner, Winters, and Kopriva&#39;s Split form Nodal   DG paper</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICUnsteadyVortex-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,N}}" href="#EulerEquationMod.ICUnsteadyVortex-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,N}}"><code>EulerEquationMod.ICUnsteadyVortex</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICUnsteadyVortex</strong></p><p>Sets the solution to the unsteady vortex problem.  eqn.params.t is used to   determine what time to use for the solution.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICZero-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICZero-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICZero</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICZero</strong></p><p>Sets all components of the solution to zero</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICsmoothHeaviside-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICsmoothHeaviside-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICsmoothHeaviside</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICZero</strong></p><p>Sets the density to the smooth Heaviside function, all other components to   zero.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.ICsmoothHeavisideder-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.ICsmoothHeavisideder-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{Tsbp},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.ICsmoothHeavisideder</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.ICsmoothHeavisideder</strong></p><p>Sets the density to the derivative of the smooth Heaviside function, all    other components to zero.</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:      u0: vector to populate with the solution</p><p>Aliasing restrictions: none.</p></div></section><footer><hr/><a class="previous" href="bc.html"><span class="direction">Previous</span><span class="title">Boundary Integrals</span></a><a class="next" href="source.html"><span class="direction">Next</span><span class="title">Source Term</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Misc · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="stabilization.html">Stabilization</a></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li class="current"><a class="toctext" href="misc.html">Misc</a><ul class="internal"></ul></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="misc.html">Misc</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/3cd40b12c60e956b9f60cdebb6548a91433e2fd4/docs/src/solver/euler/misc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Miscellaneous-Function-1" href="#Miscellaneous-Function-1">Miscellaneous Function</a></h1><p>This page documents a bunch of functions that are useful but don&#39;t fit into another catagory.</p><p>Actually, some of these functions do fit into another catagory and new files should be created to move them into.</p><p>A bunch of the things in euler_funcs.jl</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcA0-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcA0-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcA0</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcA0</strong></p><p>This function calculates the A0 (ie. dq/dv, where q are the conservative   and v are the entropy variables) for a node, and stores it A0</p><p>The formation of A0 is given in Hughes</p><p>Inputs:     params : ParamType{Tdim, :entropy}     q  : vector of entropy variables, length Tdim + 2</p><p>Inputs/Outputs:   A0 : (Tdim+2)x(Tdim+2) matrix populated with A0.  Overwritten</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcA0-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcA0-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcA0</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcA0</strong></p><p>This function calculates the A0 (ie. dq/dq, where q are the conservative   variables at a node), and stores it A0.  This function is provided for   compatability purposes</p><p>Inputs:     params : ParamType{2, :entropy}     q  : vector of conservative variables, length 4</p><p>Inputs/Outputs:   A0 : 4x4 (or 5x5 in 3D)  matrix populated with A0.  Overwritten</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcA0Inv-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcA0Inv-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcA0Inv</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcA0Inv</strong></p><p>Calculates inv(A0), where A0 = dq/dv, where q are the conservative variables   at a node and v are the entropy varaibles at a node, using the entropy   variables.</p><p>Inputs:     params : ParamType{Tdim, :entropy}     q  : vector (length 4 or 5) of entropy variables at a node</p><p>Inputs/Outputs:     A0inv : matrix to be populated with inv(A0).  Overwritten.</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcA0Inv-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcA0Inv-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcA0Inv</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcA0Inv</strong></p><p>Calculates inv(A0), where A0 = dq/dq, where q are the conservative variables   at a node.  This function is provided for compatability purposes</p><p>Inputs:     params : ParamType{2, :entropy}     q  : vector (length Tdim + 2) of conservative variables at a node</p><p>Inputs/Outputs:     A0inv : matrix to be populated with inv(A0).  Overwritten.</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcA1-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcA1-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcA1</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcA1</strong></p><p>This function calculates the A1 (ie. dF1/dq, where F1 is the first column of   the Euler flux) for a node, aka the flux   Jacobian of the Euler flux in the x direction.  Methods are available for   both conservative and entropy variables.</p><p>The formation of A1 is given in Hughes paper</p><p>Inputs:     params : ParamType{2, :entropy}     q  : vector of entropy variables, length 4</p><p>Inputs/Outputs:   A1 : 4x4 matrix to be populated.  Overwritten</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcA2-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcA2-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcA2</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcA2</strong></p><p>This function calculates A2 (ie. dF2/dq, where F2 is the second column of the   Euler flux, aka the flux jacobian in the y direction.   Methods are available for both conservative and entropy variables.</p><p>The formation of A2 is given in Hughes</p><p>Inputs:     params : ParamType{2, :entropy},     q  : vector of entropy variables, length 4   Inputs/Outputs:   A2 : 4x4 matrix to be populated.  Overwritten</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEntropy-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcEntropy-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcEntropy</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcEntropy</strong></p><p>This function calculates the entropy at a node and returns it.  Method are   available for conservative and entropy variables, 2D or 3D</p><p>Inputs:     params: ParamType{Tdim, var_type}, used to dispatch to the right method.     q: vector of solution variables at a node.</p><p>Returns: entropy</p><p>This is a low level function</p><p>Aliasing Restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEntropyIR-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcEntropyIR-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcEntropyIR</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates the entropy function U used to define the IR   variablesat a node and returns it.   It does not return the physical entropy   s.  This function is agnostic to the dimension of the equation.</p><p>Inputs:     params: a ParamType     q: a vector of conservative variables at a node</p><p>Outputs:     U: the value of the entropy function</p><p>Aliasing restrictions: none.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcEulerFlux-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcEulerFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcEulerFlux</strong></p><p>This function calculates the Euler flux from the conservative variables at    a single node in a particular direction.  2D only.</p><p>Inputs:    params  : ParamaterType{2, :conservative}    q  : vector of conservative variables    aux_vars : vector of auxiliary variables    dir :  vector in direction to calculate the flux</p><p>Inputs/Outputs:    F  : vector to populate with the flux</p><p>The Tdim paramater of params determine whether this method or the 3D    version is called.</p><p>This is a low level function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcEulerFlux-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcEulerFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>low level function</strong></p><pre><code class="language-none">Calculates the Euler flux from entropy variables

Inputs:
params : ParameterType{Tdim, :entropy}
q : vector of entropy variables
aux_vars : vector of auxiliary variables
dir : vector specifying the direction to caculate the flux

Inputs/Outputs:
F  : vector to populate with the flux

This is a low level function.  The static parameters of
the ParameterType are used to dispatch to the right method for any
combination of variable type or equation dimension.</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux-Tuple{EulerEquationMod.ParamType{3,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcEulerFlux-Tuple{EulerEquationMod.ParamType{3,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},AbstractArray{Tres,1},AbstractArray{Tmsh,N},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcEulerFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcEulerFlux</strong></p><p>This is the 3D method.  All arguments are same as the 2D version.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_revm-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},Any,AbstractArray{Tmsh,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1}}" href="#EulerEquationMod.calcEulerFlux_revm-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},Any,AbstractArray{Tmsh,1},AbstractArray{Tres,1},AbstractArray{Tmsh,1}}"><code>EulerEquationMod.calcEulerFlux_revm</code></a> — <span class="docstring-category">Method</span>.</div><div><p>###EulerEquationMod.calcEulerFlux_revm</p><p>Compute the derivative of the euler flux in reverse mode w.r.t to unit vector flux direction.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEulerFlux_revq-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},Any,AbstractArray{Tmsh,1},AbstractArray{Tres,1},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcEulerFlux_revq-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},Any,AbstractArray{Tmsh,1},AbstractArray{Tres,1},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcEulerFlux_revq</code></a> — <span class="docstring-category">Method</span>.</div><div><p>###EulerEquationMod.calcEulerFlux_revq</p><p>Compute the derivative of the Euler flux in reverse mode w.r.t q</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcMaxWaveSpeed-Tuple{Any,Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any}" href="#EulerEquationMod.calcMaxWaveSpeed-Tuple{Any,Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,:conservative},Any}"><code>EulerEquationMod.calcMaxWaveSpeed</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcMaxWaveSpeed</strong></p><p>This function calculates the maximum wave speed (ie. acoustic wave speed)   present in the domain and returns it.  Methods are available for conservative   and entropy variables.  This function uses eqn.q_vec, not eqn.q to do the   calculation.</p><p>This is a mid level function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcMomentContribution_rev!-Tuple{SummationByParts.AbstractFace{Tsbp},AbstractArray{Tmsh,3},AbstractArray{Tmsh,3},AbstractArray{Tsol,3},AbstractArray{Tsol,3},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcMomentContribution_rev!-Tuple{SummationByParts.AbstractFace{Tsbp},AbstractArray{Tmsh,3},AbstractArray{Tmsh,3},AbstractArray{Tsol,3},AbstractArray{Tsol,3},AbstractArray{Tmsh,1},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcMomentContribution_rev!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>calcMomentContribution_rev!</strong></p><p>This is the reverse differentiated version of calcMomentContribution!.  See docs of calcMomentContribution! for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>xsbp</code> and <code>dforce</code> variables.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>xsbp</code>: SBP-face nodes in physical space; [coord, sbp node, face]</li><li><code>dforce</code>: scaled force at the sbpface nodes; [coord, sbp node, face]</li><li><code>xyz_about</code>: point about which the moment is taken</li><li><code>moment_bar</code>: left multiplies d(moment)/d(xsbp) and d(moment)/d(dforce)</li></ul><p><strong>InOuts</strong></p><ul><li><code>xsbp_bar</code>: result of vector Jacobian product; [coord, sbp node, face]</li><li><code>dforce_bar</code>: result of vector Jacobian product; [coord, sbp node, face]</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcPressure-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcPressure-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcPressure</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcPressure</strong></p><p>This function calculates the pressure from the conservative variables at a   node in 2D.  It returns a single value.</p><p>Inputs:     params : ParamType{Tdim, var_type }     q  : vector of conservative variables</p><p>The parameter of params determines whether the 2D or 3D, conservative   or entropy method is dispatched.</p><p>This is a low level function.</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcPressure-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcPressure-Tuple{EulerEquationMod.ParamType{2,:entropy,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcPressure</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcPressure</strong></p><p>This function calculates pressure using the entropy variables.</p><p>Inputs:     params : ParamType{2, :entropy}     q  : vector of entropy varaibles</p><p>returns pressure</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcPressure-Tuple{EulerEquationMod.ParamType{3,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcPressure-Tuple{EulerEquationMod.ParamType{3,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcPressure</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcPressure</strong></p><p>3D method.  See 2D method documentation</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcPressure_revq-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},Any,Any}" href="#EulerEquationMod.calcPressure_revq-Tuple{EulerEquationMod.ParamType{2,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1},Any,Any}"><code>EulerEquationMod.calcPressure_revq</code></a> — <span class="docstring-category">Method</span>.</div><div><p>###EulerEquationMod.calcPressure_revq</p><p>Compute the gradient of pressure w.r.t q in the reverse mode</p><p><strong>Arguments</strong></p><ul><li><code>params</code> : Parameter object</li><li><code>q</code> : Forward sweep solution variable</li><li><code>press_bar</code> : Reverse pressure gradient</li><li><code>q_bar</code> : Reverse mode solution gradient `</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSpeedofSound-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcSpeedofSound-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcSpeedofSound</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcSpeedofSound</strong></p><p>This function calculates the speed of sound at a node and returns it.   Methods are available for both conservative and entropy variables.</p><p>Inputs:     params:  ParamType{Tdim, var_type}     q  vector of solution variables at a node</p><p>Returns: speed of sound</p><p>This is a low level function</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcSteadyFluxJacobian-Tuple{Any,Any,Any,Any}" href="#EulerEquationMod.calcSteadyFluxJacobian-Tuple{Any,Any,Any,Any}"><code>EulerEquationMod.calcSteadyFluxJacobian</code></a> — <span class="docstring-category">Method</span>.</div><div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcVolumeIntegralsSplitForm-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.FluxType}" href="#EulerEquationMod.calcVolumeIntegralsSplitForm-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.FluxType}"><code>EulerEquationMod.calcVolumeIntegralsSplitForm</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate (S .*F)1 where S is the skew symmetric part of sbp.Q and F   is a symmetric numerical flux function.  eqn.res is updated with the result.   Methods are available for curvilinear and non-curvilinear meshes</p><p>Inputs:     mesh     sbp     eqn     opts     functor: the numerical flux function F, of type FluxType</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcVolumeIntegralsSplitFormCurvilinear-Tuple{ODLCommonTools.AbstractMesh{Tmsh},ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.FluxType}" href="#EulerEquationMod.calcVolumeIntegralsSplitFormCurvilinear-Tuple{ODLCommonTools.AbstractMesh{Tmsh},ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.FluxType}"><code>EulerEquationMod.calcVolumeIntegralsSplitFormCurvilinear</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates I_S2F.&#39;<em>(S .</em> F( uk(I_S2F wk), uk(I_S2F wk)))1.   This is similar to   <a href="@ref">`calcVolumeIntegralsSplitFormCurvilinear</a>, but for the staggered grid   algorithm.</p><p>Inputs:     mesh_s: the mesh object for the solution grid     mesh_f: the mesh object for the flux grid     sbp_s: SBP operator for solution grid     sbp_f: SBP operator for flux grid     functor: the numerical flux functor (<a href="../misc.html#ODLCommonTools.FluxType"><code>FluxType</code></a>) used to compute F</p><p>Inputs/Outputs:     eqn: the equation object (implicitly on the solution grid).  eqn.res is          updated with the result</p><p>Aliasing Restrictions: none (the meshes and the sbp operators could alias,                          in which case this algorithm reduces to the                           non-staggered version</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcVolumeIntegralsSplitFormCurvilinear-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.FluxType}" href="#EulerEquationMod.calcVolumeIntegralsSplitFormCurvilinear-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,ODLCommonTools.FluxType}"><code>EulerEquationMod.calcVolumeIntegralsSplitFormCurvilinear</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculate (S .* F)1, where S is the skew-symmetric part of sbp.Q   and F is a symmetric numerical flux function.  eqn.res is updated   with the result.  This function is used for curvilinear meshes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcVolumeIntegrals_nopre-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.calcVolumeIntegrals_nopre-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.calcVolumeIntegrals_nopre</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculates the volume integrals for the weak form, computing the Euler flux   as needed, rather than using eqn.flux_parametric</p><p>Inputs:     mesh     sbp     eqn: eqn.res is updated with the result     opts</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcVorticity-Tuple{EulerEquationMod.ParamType{3,:conservative,Tsol,Tres,Tmsh},Any,AbstractArray{Tsol,2},AbstractArray{Tmsh,3},AbstractArray{Tmsh,1},AbstractArray{Tres,2}}" href="#EulerEquationMod.calcVorticity-Tuple{EulerEquationMod.ParamType{3,:conservative,Tsol,Tres,Tmsh},Any,AbstractArray{Tsol,2},AbstractArray{Tmsh,3},AbstractArray{Tmsh,1},AbstractArray{Tres,2}}"><code>EulerEquationMod.calcVorticity</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates the vorticity at every node of an element   (because vorticity requires derivatives of the velocity, it would be   awkward to compute it at a node level).</p><p>3D, conservative variables only</p><p>Inputs:     params: a ParamType     q: numDofPerNode x numNodesPerElement array of conservative variables at        each node     dxidx: the 3 x 3 x numNodesPerElement  scaled  mapping jacobian at the node     jac: numNodesPerElement vector of the mapping jacobian determinant at          each node</p><p>Input/Outputs:     vorticity: a 3 x numNodesPerElement array  containing the vorticity in the                x, y, and z directions at each node, overwritten</p><p>Aliasing restrictions: from params: dxidx_element, velocities, velocity_deriv,                                       velocity_deriv_xy</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getAuxVars-Tuple{ODLCommonTools.AbstractMesh{Tmsh},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}" href="#EulerEquationMod.getAuxVars-Tuple{ODLCommonTools.AbstractMesh{Tmsh},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}"><code>EulerEquationMod.getAuxVars</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getAuxVars</strong></p><p>This function calculates any extra variables that are stored across the mesh   using the conservative variables eqn.q.  Currently only calculates pressure.</p><p>Thi is a mid level function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getEulerFlux-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.getEulerFlux-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.getEulerFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getEulerFlux</strong></p><p>This function calculates the Euler flux across the entire mesh by passing   pieces of the eqn.q, eqn.aux_vars, eqn.f_xi and eqn.params to a low level   function.  The flux is calculated in the xi and eta directions,   scaled (mulitiplied) by the mapping jacobian (so that when performing the   integral we don&#39;t have to explictly divide by the jacobian, it just cancels   out with the jacobian factor introduced here.</p><p>Calls writeFlux to do any requested output.</p><p>This is a mid level function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getEulerFlux2-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}" href="#EulerEquationMod.getEulerFlux2-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any}"><code>EulerEquationMod.getEulerFlux2</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getEulerFlux2</strong></p><p>This function calcules the euler flux over the entire mesh directly (ie.   does not call a low level function.  This function is deprecated, although   useful for benchmarking purposes.  2D only.</p><p>This is a mid level function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.interpolateElementStaggered-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},Any,AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,2}}" href="#EulerEquationMod.interpolateElementStaggered-Tuple{EulerEquationMod.ParamType{Tdim,:conservative,Tsol,Tres,Tmsh},Any,AbstractArray{T,2},AbstractArray{T,2},AbstractArray{T,2}}"><code>EulerEquationMod.interpolateElementStaggered</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function does the interpolation from the solution grid to the flux   grid for a single element</p><p><strong>Inputs</strong>:    * params: a ParamType.  The qs_el1 and q_el1 fields are overwritten.    * qs_el: the conservative variables for the element on the solution grid</p><p><strong>Inputs/Outputs</strong>:</p><ul><li>aux_vars: array to be populated with the aux vars on the staggered grid</li><li>qf_el: conservative variables on the flux grid    </li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.matVecA0-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:entropy},Any,AbstractArray{Tsol,3}}" href="#EulerEquationMod.matVecA0-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:entropy},Any,AbstractArray{Tsol,3}}"><code>EulerEquationMod.matVecA0</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.matVecA0</strong></p><p>This function is the same as matVecA0inv, except it multiplies by A0 not   A0inv.  See its documention.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.matVecA0inv-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:entropy},Any,AbstractArray{Tsol,3}}" href="#EulerEquationMod.matVecA0inv-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,:entropy},Any,AbstractArray{Tsol,3}}"><code>EulerEquationMod.matVecA0inv</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.matVecA0inv</strong></p><p>This function takes a 3D array and multiplies it in place by the inv(A0)   matrix (calculated at each node), inplace, (where A0 =dq/dv, where q are the   conservative variables and v are some other variables), inplace.   Methods are available for conservative and entropy variables.</p><p>For conservative variables, A0 is the identity matrix and this is a no-op</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Inputs/Outputs:     res_arr: the array to multiply</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.writeFlux-Tuple{Any,Any,Any,Any}" href="#EulerEquationMod.writeFlux-Tuple{Any,Any,Any,Any}"><code>EulerEquationMod.writeFlux</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.writeFlux</strong></p><p>This function writes the real part of Euler flux to a file named Fxi.dat,   space delimited, controlled by the input options &#39;writeflux&#39;, of type Bool.</p><p>This is a high level function.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEnstrophy-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,3}}" href="#EulerEquationMod.calcEnstrophy-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,3}}"><code>EulerEquationMod.calcEnstrophy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Calculates ( 1/(2V) )*integral(rho * omega dot omega dV), where V is the   volume of the mesh omega is the vorticity vector, and rho is the density.   3D, conservative variables only.  This should work for CG and DG, but   has only been tested for the latter</p><p>Inputs:     mesh: an AbstractMesh     sbp: an SBP operator     eqn: an EulerData object     opts: options dictionary     q_arr: a 3D array of conservative variables </p><p>Outputs:     val: the value of the integral (over the entire domain, not just the          part owned by this process)</p><p>Aliasing restrictions: see calcVorticity</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcKineticEnergy-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}" href="#EulerEquationMod.calcKineticEnergy-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1}}"><code>EulerEquationMod.calcKineticEnergy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates ( 1/(2<em>V) )</em>integral(rho * v dot v dV), where   V is the volume of the mesh, v is the velocity vector, and rho is the density.   This is the total kinetic energy normalized by the volume of the domain   Conservative variables only.</p><p>This function contains an MPI blocking collective operation.  It must be   called by all processes at the same time.</p><p>This function relies on the sequential numbering of dofs on the same node</p><p>Inputs:     mesh: a mesh     sbp: an SBP Operator     eqn: an EulerData object     opts: options dictionary     q_vec: the vector of conservative variables for the entire mesh</p><p>Outputs:     val: the value of the integral (over the entire domain, not just teh part          owned by this procss)</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcKineticEnergydt-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1},AbstractArray{Tres,1}}" href="#EulerEquationMod.calcKineticEnergydt-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{Tsol,1},AbstractArray{Tres,1}}"><code>EulerEquationMod.calcKineticEnergydt</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calclates the time derivative of calcKineticEnergy.</p><p>The idea is to expand the left hand side of d rho*u/dt = res using the    product rule and solve for du/dt, then use it to compute the integral.   Inputs:     mesh: a mesh     sbp: a SBP operator     eqn: an EulerData     opts: options dictionary     q_vec: vector of conservative variables for the entire mesh     res_vec: residual vector (dq/dt) of entire mesh</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.contractResEntropyVars2-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{T,1},AbstractArray{T,1}}" href="#EulerEquationMod.contractResEntropyVars2-Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},Any,EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},Any,AbstractArray{T,1},AbstractArray{T,1}}"><code>EulerEquationMod.contractResEntropyVars2</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like contractResEntropyVars, but uses a special summation technique</p></div></section><footer><hr/><a class="previous" href="boundary_functional.html"><span class="direction">Previous</span><span class="title">Boundary Functional</span></a><a class="next" href="eigensystem.html"><span class="direction">Next</span><span class="title">Eigensystem</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stabilization · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../advection/advection.html">Introduction</a></li><li><a class="toctext" href="../advection/types.html">Datatypes</a></li><li><a class="toctext" href="../advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../advection/source.html">Source Term</a></li><li><a class="toctext" href="../advection/common.html">Common Functions</a></li><li><a class="toctext" href="../advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler.html">Introduction</a></li><li><a class="toctext" href="types.html">Datatypes</a></li><li><a class="toctext" href="volume.html">Volume Integrals</a></li><li><a class="toctext" href="flux.html">Face Integrals</a></li><li><a class="toctext" href="faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="bc.html">Boundary Integrals</a></li><li><a class="toctext" href="ic.html">Initial Conditions</a></li><li><a class="toctext" href="source.html">Source Term</a></li><li><a class="toctext" href="common.html">Common Functions</a></li><li><a class="toctext" href="conversion.html">Conversion</a></li><li><a class="toctext" href="flux_functions.html">Numerical Flux Functions</a></li><li class="current"><a class="toctext" href="stabilization.html">Stabilization</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="adjoint.html">Adjoint</a></li><li><a class="toctext" href="boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="misc.html">Misc</a></li><li><a class="toctext" href="eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li>Euler</li><li><a href="stabilization.html">Stabilization</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/3e7a12c3f0424e27c01495702aba74eb968cf0dd/docs/src/solver/euler/stabilization.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Stabilization-1" href="#Stabilization-1">Stabilization</a></h1><p>This page describes the stabilization methods used for continuous Galerkin formulations. Not all of these effectively stabilized the discretization, and since the move to discontinuous Galerkin, they may have bitrotted.</p><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.edgestabilize!-Tuple{SummationByParts.AbstractSBP{T},Array{ODLCommonTools.Interface,N},ODLCommonTools.AbstractMesh{Tmsh},AbstractArray{T,2},AbstractArray{T,3},AbstractArray{T,4},AbstractArray{T,2},AbstractArray{T,4},AbstractArray{Tres,2},AbstractArray{T,2}}" href="#EulerEquationMod.edgestabilize!-Tuple{SummationByParts.AbstractSBP{T},Array{ODLCommonTools.Interface,N},ODLCommonTools.AbstractMesh{Tmsh},AbstractArray{T,2},AbstractArray{T,3},AbstractArray{T,4},AbstractArray{T,2},AbstractArray{T,4},AbstractArray{Tres,2},AbstractArray{T,2}}"><code>EulerEquationMod.edgestabilize!</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.edgestabilize!</strong></p><p>Adds edge-stabilization (see Burman and Hansbo, doi:10.1016/j.cma.2003.12.032) to a given residual.  Different methods are available depending on the rank of <code>u</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>u</code> is a rank-2 array, with the first dimension for the local-node index, and the second dimension for the element index.</li><li>For <em>vector</em> fields, <code>u</code> is a rank-3 array, with the first dimension for the index of the vector field, the second dimension for the local-node index, and the third dimension for the element index.</li></ul><p>Naturally, the number of entries in the dimension of <code>u</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator <code>sbp</code>.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>u</code>: the array of solution data, numDofPerNode x numNodesPerElement x numEl.        for scalar fields (ie. numDofPerNode), this can be a 2D array.</li><li><code>x</code>: Cartesian coordinates stored in (coord,node,element) format</li><li><code>dxidx</code>: scaled Jacobian of the mapping (as output from <code>mappingjacobian!</code>)</li><li><code>jac</code>: determinant of the Jacobian array, numNodesPerElement x numEl</li><li><code>alpha</code>: array of transformation terms (see below)</li><li><code>stabscale</code>: numfaces x numNodes per face array of scaling parameter</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of the integration is stored, same shape as u</li></ul><p><strong>Details</strong></p><p>The array <code>alpha</code> is used to compute the directional derivative normal to the faces. For a 2-dimensional problem, it can be computed as follows:</p><pre><code class="language-none">  for k = 1:mesh.numelem
    for i = 1:sbp.numnodes
      for di1 = 1:2
        for di2 = 1:2
          alpha[di1,di2,i,k] = (dxidx[di1,1,i,k].*dxidx[di2,1,i,k] + 
                            dxidx[di1,2,i,k].*dxidx[di2,2,i,k])*jac[i,k]
        end
      end
    end
  end</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.stabscale-Tuple{AbstractArray{Tsol,1},AbstractArray{Tmsh,2},AbstractArray{Tmsh,1},EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh}}" href="#EulerEquationMod.stabscale-Tuple{AbstractArray{Tsol,1},AbstractArray{Tmsh,2},AbstractArray{Tmsh,1},EulerEquationMod.ParamType{2,var_type,Tsol,Tres,Tmsh}}"><code>EulerEquationMod.stabscale</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.stabscale</strong></p><p>This function calculates the edge stabilization scalaing parameter at a node   and returns it.</p><p>Inputs:     * q : vector of conservative variables     * dxidx : jacobian of xi wrt x coordinates at the node     * nrm : normal vector in xi space     * params : ParamType{2}</p><pre><code class="language-none">This is a low level function</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.stabscale-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}" href="#EulerEquationMod.stabscale-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}"><code>EulerEquationMod.stabscale</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.stabscale</strong></p><p>This function calculate the stabilization scaling parameter across the   entire mesh by calling the low level method.  This populates eqn.stabscale.</p><p>This is a mid level function</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.GLS-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}" href="#EulerEquationMod.GLS-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}"><code>EulerEquationMod.GLS</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.GLS</strong></p><p>Add Galerkin Least-Squares stabilization to the weak residual. This implementation is only for steady problems and conservative variables</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code>: AbstractMesh type</li><li> <code>sbp</code> : Summation-by-parts operator</li><li> <code>eqn</code> : Equation object used elsewhere</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.SUPG-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}" href="#EulerEquationMod.SUPG-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}"><code>EulerEquationMod.SUPG</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.SUPG</strong></p><p>Add Streamwise Upwind Petrov-Galerkin stabilization to the weak residual. This implementation is only for steady problems</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code>: AbstractMesh type</li><li> <code>sbp</code> : Summation-by-parts operator</li><li> <code>eqn</code> : Equation object used elsewhere</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcAxidxi-Tuple{AbstractArray{Tsol,2},AbstractArray{Tsol,3},AbstractArray{Tsol,3},AbstractArray{Tsol,3},Any,Any}" href="#EulerEquationMod.calcAxidxi-Tuple{AbstractArray{Tsol,2},AbstractArray{Tsol,3},AbstractArray{Tsol,3},AbstractArray{Tsol,3},Any,Any}"><code>EulerEquationMod.calcAxidxi</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcAxidxi</strong></p><p>Calculates Axi<em>Dxi + Aeta</em>Deta at the element level</p><p><strong>Inputs</strong></p><ul><li> <code>Axidxi</code> : Product of flux jacobian with shape function derivative               Axi<em>Dxi + Aeta</em>Deta</li><li> <code>shapefuncderiv</code>: Shape function derivative (Dxi and Deta above)</li><li> <code>Axi</code> : Flux jacobian in the xi direction</li><li> <code>Aeta</code> : Flux jacobian in the eta direction</li><li> <code>ndof</code> : Number of degrees of freedom per node</li><li> <code>nnpe</code> : Number of nodes per element</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcEigenFactorization-Tuple{EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcEigenFactorization-Tuple{EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,1},AbstractArray{Tsol,1},AbstractArray{Tsol,2},AbstractArray{Tsol,2},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcEigenFactorization</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcEigenFactorization</strong></p><p>Computes the eigen value facotrization of the flux jacobian in either xi or eta direction. This is a nodal level function. It is only for 2D conservative  variables.</p><p>Reference: <code>Efficient Solution Methods for the Navier–Stokes Equations</code>, T.H,            Pulliam, NASA Ames Research Center</p><p><strong>Inputs</strong></p><ul><li> <code>eqn</code>  : Euler equation object</li><li> <code>q</code>    : Conservative variables at a node</li><li> <code>dxidx</code>: mapping jacobian vector. It can be either [dξ/dx dξ/dy] or              [dη/dx dη/dy] depending on what Axi or Aeta being factorized.</li><li> <code>T</code>    : Matrix of eigen vectors.</li><li> <code>Tinv</code> : Inverse of T</li><li> <code>Lambda</code> : Diagonal matrix of eigen values</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcElementArea-Tuple{AbstractArray{Tmsh,2}}" href="#EulerEquationMod.calcElementArea-Tuple{AbstractArray{Tmsh,2}}"><code>EulerEquationMod.calcElementArea</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcElementArea</strong></p><p>Calculates the element area of a 2D triangular element</p><p><strong>Inputs</strong></p><ul><li> <code>coords</code> : Vertex coordinates of the element</li></ul><p><strong>Outputs</strong></p><ul><li> <code>area</code> : Area of the triangular element</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcFluxJacobian-Tuple{EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,1},AbstractArray{Tsol,2},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcFluxJacobian-Tuple{EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,1},AbstractArray{Tsol,2},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcFluxJacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcFluxJacobian</strong></p><p>It computes the Euler flux Jacobian at the nodal level in te physical space  (X &amp; Y axes). It uses conservative variables.</p><p><strong>Inputs</strong></p><ul><li> <code>eqn</code>  : Equation object</li><li> <code>q</code>    : Conservative variables at the node</li><li> <code>Ax</code>   : Flux Jacobian at a node in the X-direction</li><li> <code>Ay</code>   : Flux Jacobian at a node in the Y-direction</li></ul><p><strong>Outputs</strong></p><ul><li> None </li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcStabilizationTerm-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,2}}" href="#EulerEquationMod.calcStabilizationTerm-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,2}}"><code>EulerEquationMod.calcStabilizationTerm</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcStabilizationTerm</strong></p><p>Calculates the stabilization term tau for all the nodes in the mesh</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code> : Abstract mesh type</li><li> <code>sbp</code>  : Summation-by-parts operator</li><li> <code>eqn</code>  : Equation object within EulerEquationMod</li><li> <code>tau</code>  : Stabilization term being calculated</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcTau-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,4},Integer}" href="#EulerEquationMod.calcTau-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type},AbstractArray{Tsol,4},Integer}"><code>EulerEquationMod.calcTau</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcTau</strong></p><p>Calculates the stabilization term tau for GLS</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code> : Abstract mesh type</li><li> <code>sbp</code>  : Summation-by-parts operator</li><li> <code>eqn</code>  : Euler equation object</li><li> <code>tau</code>  : Stabilization term</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.circumcircleDiameter-Tuple{AbstractArray{Tmsh,2}}" href="#EulerEquationMod.circumcircleDiameter-Tuple{AbstractArray{Tmsh,2}}"><code>EulerEquationMod.circumcircleDiameter</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.circumcircleDiameter</strong></p><p>Calculates the circumcircle diameter of a triangular element</p><p><strong>Inputs</strong></p><ul><li> <code>coords</code> : Vertex coordinates of the element</li></ul><p><strong>Outputs</strong></p><ul><li> <code>dia</code> : Diameter of the circumcircle</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.parametricFluxJacobian-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}" href="#EulerEquationMod.parametricFluxJacobian-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.EulerData{Tsol,Tres,Tdim,var_type}}"><code>EulerEquationMod.parametricFluxJacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.parametricFluxJacobian</strong></p><p>Claculates the flux jacobian in the parametric space for all the nodes in the mesh. It uses conservative variables</p><p><strong>Inputs</strong></p><ul><li> <code>mesh</code> : Abstract mesh object</li><li> <code>sbp</code>  : Summation-by-parts operator</li><li> <code>eqn</code>  : Equation object</li></ul><p><strong>Outputs</strong></p><ul><li> None</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.applyFilter-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Any,AbstractArray{T,3}}" href="#EulerEquationMod.applyFilter-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Any,AbstractArray{T,3}}"><code>EulerEquationMod.applyFilter</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.applyFilter</strong></p><p>This function multiplies a filter matrix by the variables at every   node in the mesh.  The filter matrix is stored in eqn.params.filter_mat</p><p>Inputs:     mesh     sbp     eqn     opts</p><p>Keyword Args:     trans=false  : transpose the filter matrix or not.</p><p>Inputs/Outputs:     arr: 3D array to multiply the filter matrix by</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcFilter-Tuple{SummationByParts.AbstractSBP{T<:Number},ASCIIString,Any}" href="#EulerEquationMod.calcFilter-Tuple{SummationByParts.AbstractSBP{T<:Number},ASCIIString,Any}"><code>EulerEquationMod.calcFilter</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcfilter</strong></p><p>This function calculates the filter used by applyFilter().   The filter is calculated as V<em>filter_kernel</em>inv(V), where V is a matrix   that converts the interpolating SBP basis to a modal basis and filter_kernal   is a matrix (typically diagonal) that performs the filtering of the modal   basis coefficients.</p><p>Inputs:     sbp: SBP operator used to compute the solutions     filter_name: and ASCIIString that matches the name of a filter function.                  This string is used to retrieve the function from a dictionary                  of all supported filter function.     opts:  options dictonary</p><p>Outputs:     F_ret: a numNodesPerElement x numNodesPerElement filter operator</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcLowPassFilter-Tuple{SummationByParts.AbstractSBP{T<:Number},Any}" href="#EulerEquationMod.calcLowPassFilter-Tuple{SummationByParts.AbstractSBP{T<:Number},Any}"><code>EulerEquationMod.calcLowPassFilter</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcLowPassFilter</strong></p><p>This function calculates a low pass filter diagonal filter matrix.</p><p>Inputs:     sbp: SBP operator     opts: options dictonary</p><p>Outputs:     filt: numNodesPerElement x numNodesPerElement diagonal filter matrix</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcModalTransformationOp-Tuple{SummationByParts.AbstractSBP{T<:Number}}" href="#EulerEquationMod.calcModalTransformationOp-Tuple{SummationByParts.AbstractSBP{T<:Number}}"><code>EulerEquationMod.calcModalTransformationOp</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcModalTransformationOp</strong></p><p>This function calculates a matrix operator V that transforms from a modal   basis to an interpolating basis for SBP operators.  Because the transformation   itself is rank deficient, V is augmented with the last n vector of its Q   matrix (from the full QR decomposition), where numNodesPerElement - rank(V)   = n</p><p>Inputs:     sbp:  SBP operator</p><p>Outputs:     V_full: a numNodesPerElement x numNodesPerElement generalized             Vandermonde matrix</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcRaisedCosineFilter-Tuple{SummationByParts.AbstractSBP{T<:Number},Any}" href="#EulerEquationMod.calcRaisedCosineFilter-Tuple{SummationByParts.AbstractSBP{T<:Number},Any}"><code>EulerEquationMod.calcRaisedCosineFilter</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcRaisedCosineFilter</strong></p><p>This function constructs a diagonal matrix filt for a 2 dimensional basis   filter, using the raised cosine filter described in Spectral Methods for   the Euler Equations: Part I by Hussaini, Kproiva, Salas, Zang</p><p>Inputs     sbp: SBP operator     opts: options dictonary</p><p>Outputs:     filt: an numNodesPerElement x numNodesPerElement diagonal filter matrix</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getPascalLevel-Tuple{Integer}" href="#EulerEquationMod.getPascalLevel-Tuple{Integer}"><code>EulerEquationMod.getPascalLevel</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.getPascalLevel</strong></p><p>This function returns the level of Pascals Triangle a particular node   lies in.</p><p>Inputs:     node:  node index</p><p>Outputs:     level: integer describing level of Pascals triangle.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.applyDissipation-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Any,AbstractArray{T,3}}" href="#EulerEquationMod.applyDissipation-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Any,AbstractArray{T,3}}"><code>EulerEquationMod.applyDissipation</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.applyDissipation</strong></p><p>This function multiplies the dissipation matrix operator for each element   by the values in a 3D array (typically eqn.q) for each node of the element    and stores the results in eqn.res.</p><p>The dissipation matrix operators must be stored in   eqn.dissipation_mat, a numNodesPerElement x numNodesPerElement x numEl array.</p><p>Inputs:     mesh     sbp     eqn     opts     arr: a 3D array to apply the dissipation matrix to</p><p>Aliasing restrictions: no guarantees what happens if arr is eqn.res</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.calcDissipationOperator-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.AbstractEulerData{Tsol,Tres},Any,ASCIIString}" href="#EulerEquationMod.calcDissipationOperator-Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},EulerEquationMod.AbstractEulerData{Tsol,Tres},Any,ASCIIString}"><code>EulerEquationMod.calcDissipationOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquationMod.calcDissipationOperator</strong></p><p>This function calculates the numNodesPerElement x numNodesPerElement    dissipation matrix operator for each element and returns them in an array   numNodesPerElement x numNodesPerElement x numEl array.</p><p>The dissipation matrix operator is calculated as epsilon<em>filt.&#39;</em>h_jac*filt,   where filt is a (usually diagonal) filter matrix, h_jac is a scaling term    that incorporates information about the shape of the element.</p><p>Inputs:     mesh     sbp     eqn     opts     dissipation_name: an ASCIIString of the function name used to retrieve                       the function that generates the matrix filt from a                       dictonary</p><p>Outputs:     dissipation_mat: a numNodesPerElement x numNodesPerElement x numEl array</p><pre><code class="language-none">Aliasing restrictions: none</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EulerEquationMod.getDissipationFilterOperator-Tuple{SummationByParts.TriSBP{T},Function}" href="#EulerEquationMod.getDissipationFilterOperator-Tuple{SummationByParts.TriSBP{T},Function}"><code>EulerEquationMod.getDissipationFilterOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>EulerEquatoinMod.getDissipatoinFilterOperator</strong></p><p>This function gets the dissipation filter operator used to construction   the artificial dissipation matrix.</p><p>The filter is calculated as V<em>filter_kernel</em>inv(V), where V is a matrix   that converts the interpolating SBP basis to a modal basis and filter_kernal   is a matrix (typically diagonal) that performs the filtering of the modal   basis coefficients.</p><p>Inputs:     sbp: SBP operator     filter: function to call to calculate the filter kernal</p><p>Outputs:     F: a numNodesPerElement x numNodesPerElement filter matrix</p></div></section><footer><hr/><a class="previous" href="flux_functions.html"><span class="direction">Previous</span><span class="title">Numerical Flux Functions</span></a><a class="next" href="adjoint.html"><span class="direction">Next</span><span class="title">Adjoint</span></a></footer></article></body></html>

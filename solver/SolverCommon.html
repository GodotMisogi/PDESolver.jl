<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver Common · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="misc.html">Assorted Function and Types</a></li><li class="current"><a class="toctext" href="SolverCommon.html">Solver Common</a><ul class="internal"></ul></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="advection/advection.html">Introduction</a></li><li><a class="toctext" href="advection/types.html">Datatypes</a></li><li><a class="toctext" href="advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="advection/source.html">Source Term</a></li><li><a class="toctext" href="advection/common.html">Common Functions</a></li><li><a class="toctext" href="advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="euler/euler.html">Introduction</a></li><li><a class="toctext" href="euler/types.html">Datatypes</a></li><li><a class="toctext" href="euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="euler/source.html">Source Term</a></li><li><a class="toctext" href="euler/common.html">Common Functions</a></li><li><a class="toctext" href="euler/conversion.html">Conversion</a></li><li><a class="toctext" href="euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="euler/misc.html">Misc</a></li><li><a class="toctext" href="euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver</li><li><a href="SolverCommon.html">Solver Common</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/cd605579e05af7f90c72771fb7335177465209f5/docs/src/solver/SolverCommon.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Solver-Common-1" href="#Solver-Common-1">Solver Common</a></h1><p>This page describes some functions that are used by all physics modules as part of initialization of a simulation</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverCommon.call_nlsolver" href="#SolverCommon.call_nlsolver"><code>SolverCommon.call_nlsolver</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function takes in the 4 principle object, fully initialized, and calls   a nonlinear solver on them, according to the options in the dictionary.   The evalResidual function is passed to the nonlinear solver</p><p>Inputs:     mesh: a mesh object     sbp: an SBP operator     eqn: an equation object     opts: options dictionary, used to determine which nonlinear solver to call     pmesh: mesh used for calculating preconditioning jacobian in Newton&#39;s            method, default to using mesh if not specified</p><p>Outputs:     none</p><p>Aliasing restrictions: none (specificaly, mesh and pmesh <em>can</em> be the same                          object)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverCommon.createMeshAndOperator-Tuple{Any,Any}" href="#SolverCommon.createMeshAndOperator-Tuple{Any,Any}"><code>SolverCommon.createMeshAndOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Create a SBP operator and a mesh.  This is used by all physics modules   to create the right type of operator and mesh based on the input options.   It is type unstable, but that is ok.</p><p>If the options dictionary specifies a second SBP operator type, a second   mesh and SBP operator will be created and stored in the <code>mesh2</code> and <code>sbp2</code></p><p>Inputs:     opts: options dictonary     dofpernode: number of degrees of freedom on each node</p><p>Outputs     sbp : an AbstractSBP     mesh : an AbstractMesh     pmesh : an AbstractMesh, used for preconditioning, may be same object as             mesh     Tsol : DataType that should be used for eqn.q     Tres : DataType that should be used for eqn.res     Tmsh : DataType of mesh.dxidx and friends     mesh_time : time in seconds for creation of mesh (Float64)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverCommon.loadRestartState" href="#SolverCommon.loadRestartState"><code>SolverCommon.loadRestartState</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function is used by all physics modules to load the most recently   saved state when restarting.</p><p><strong>Inputs</strong></p><ul><li>mesh: the mesh</li><li>sbp: AbstractSBP</li><li>eqn: AbstractSolutionData, eqn.q_vec is overwritten with the saved state</li><li>opts: options dictionary</li></ul><p>The keys described in the <a href="../Utils/checkpoint.html#Utils.Checkpointer"><code>Checkpointer</code></a>    documentation are used to determine the most recent complete checkpoint.</p><p>Implementation notes:      currently pmesh isn&#39;t used for anything because checkpointing does not      support mesh adaptation.  When this changes, this function will have to      be updated.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverCommon.createMesh" href="#SolverCommon.createMesh"><code>SolverCommon.createMesh</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function creates the mesh object and, optionally, a second mesh   used for preconditioning</p><p>Inputs:     opts: the options dictionary     sbp: an SBP operator     sbpface: an SBP face operator     topo: an ElementTopology describing the SBP reference element.  Only           needed for 3D DG, otherwise can be any value     Tmsh: the DataType of the elements of the mesh arrays (dxidx, jac, etc.)     dofpernode: number of degrees of freedom on every node     suffix: suffix added to options dictionary keys that describe the SBP             operator.  See <a href="SolverCommon.html#SolverCommon.createSBPOperator"><code>createSBPOperator</code></a></p><p>All arguments except opts are typically provided by    <a href="SolverCommon.html#SolverCommon.createSBPOperator"><code>createSBPOperator</code></a> and <a href="SolverCommon.html#SolverCommon.getDataTypes-Tuple{Dict{K,V}}"><code>getDataTypes</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverCommon.createSBPOperator" href="#SolverCommon.createSBPOperator"><code>SolverCommon.createSBPOperator</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function constructs the SBP operator and the associated SBP face   operator, as specified by the options dictionary.  It also determines   the shape_type that PumiInterface uses to describe the SBP operator to   Pumi.</p><p>Inputs:     opts: the options dictionary     Tsbp: the DataType specifying the Tsbp passed to the SBP operator           constructor     suffix: this suffix is added to all keys accessed in the options dictionary.             Usually the suffix is either the empty string or an integer.  This             provides a convenient way for the input file to specify several             different SBP operator and have this operator construct them.             Default value is the empty string.</p><p>Outputs:     sbp: the SBP operator     sbpface: the SBP face operator     shape_type: an integer passed to the mesh constructor to describe the                 operator     topo: in the 3D DG case, an ElementTopology describing the SBP reference           element, otherwise the integer 0.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SolverCommon.getDataTypes-Tuple{Dict{K,V}}" href="#SolverCommon.getDataTypes-Tuple{Dict{K,V}}"><code>SolverCommon.getDataTypes</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function determines the datatypes of the elements of the arrays of the   mesh quantities, sbp operator, solution variables and residual.</p><p>If the datatypes cannot be determined, an error is thrown.</p><p>Inputs:     opts: the options dictionary</p><p>Outputs     Tmsh     Tsbp     Tsol     Tres</p></div></section><footer><hr/><a class="previous" href="misc.html"><span class="direction">Previous</span><span class="title">Assorted Function and Types</span></a><a class="next" href="advection/advection.html"><span class="direction">Next</span><span class="title">Introduction</span></a></footer></article></body></html>

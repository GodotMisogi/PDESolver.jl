<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Jacobian Calculation · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="unsteady/intro.html">Intro</a></li><li><a class="toctext" href="unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="newton.html">Newton&#39;s Method</a></li><li class="current"><a class="toctext" href="jacobian.html">Jacobian Calculation</a><ul class="internal"><li><a class="toctext" href="#Finite-Differencing/Complex-Step-1">Finite Differencing/Complex Step</a></li><li><a class="toctext" href="#Explicit-Calculation-1">Explicit Calculation</a></li></ul></li><li><a class="toctext" href="jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="matrix.html">Matrix Interface</a></li><li><a class="toctext" href="newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>NonlinearSolvers</li><li><a href="jacobian.html">Jacobian Calculation</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/NonlinearSolvers/jacobian.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Jacobian Calculation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Jacobian-calculation-1" href="#Jacobian-calculation-1">Jacobian calculation</a></h1><p>Special mention of calcJacobianComplex.</p><p>One of the most involved parts of Newton&#39;s method is forming the Jacobian. The NonlinearSolvers module contains the function <a href="jacobian.html#NonlinearSolvers.physicsJac"><code>physicsJac</code></a> to compute the Jacobian of the physics <span>$\frac{\partial R(q)}{\partial q}$</span>, where <span>$R$</span> is <a href="../pdesolver_physics.html#PDESolver.evalResidual"><code>evalResidual</code></a>.  This function can be used by other methods as a starting point for computing the residual of <span>$g(R(q))$</span> described in <a href="newton.html#Newton&#39;s-method-1"> Newton&#39;s method</a> page.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.physicsJac" href="#NonlinearSolvers.physicsJac"><code>NonlinearSolvers.physicsJac</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function computes the Jacobian of an evalResidual-like function.   Specifically, it computes \partial (eqn.q_vec)/ \partial (eqn.res_vec).</p><p>Other users of <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a> (for example, implicit time marching   methods) will need to implemnt their own version of this function.  The   documentation for this function describes the requirements for the other   implementations.</p><p><a href="newton_inner.html#newtonInner-1">`newtonInner</a> guarantees that eqn.q and eqn.q_vec will be consistent   when this function is called.  When using finite differences, eqn.res and   eqn.res_vec must contain the residual of the physics.</p><p><strong>Inputs</strong>:</p><ul><li><p>mesh: an AbstractMesh</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: an AbstractSolutionData, eqn.res and eqn.res_vec may be overwritten</p></li><li><p>opts: options dictonary</p></li><li><p>jac: the Jacobian, can be an Array, SparseMatrixCSC, or PetscMat</p></li><li><p>ctx_residual: a tuple of values.  ctx_residual[1] must be an                evalResidual-like function (eqn.q -&gt; eqn.res) function               with signature func(mesh, sbp, eqn, opts, t).               See <a href="residual_evaluation.html#NonlinearSolvers.physicsRhs"><code>physicsRhs</code></a> for a more thorough description                of ctx_residual.</p></li><li><p>t: simulation time</p></li></ul><p><strong>Options Keys:</strong></p><ul><li><p>jac_type</p></li><li><p>jac_method</p></li><li><p>epsilon</p></li><li><p>calc_jac_explicit</p></li></ul><p><strong>Implementation Notes:</strong></p><p>This function should not have to do any parallel communication. <code>newtonInner</code>   ensures that the <code>rhs_func</code> is called before <code>jac_func</code>, and <code>rhs_func</code>    handles   the parallel communication.</p><p>Implementations of this function may perform either (<code>eqn.q -&gt; jacobian</code>) or   (<code>eqn.q_vec -&gt; jacobian</code>).  The first may be more computationally efficient,   but the second can be simpler for debugging.</p><p>This function supportes several types of jacobians (dense arrays,   SparseMatrixCSC, PetscMat), and several methods for calculating them   (finite difference and complex step).  Any function calling this function   should support them as well.</p><p>It is strongly recommneded to   use this function to compute the spatial jacobian and them modify the   resulting matrix (this function zeros the Jacobian matrix)</p><p>When using Petsc matrices, the function may do intermediate assemblies   (<code>PETSC_FLUSH_ASSEMBLY</code>), but does not need to do the final assembly.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L5-L63">source</a></section><p><code>physicsJac</code> calls one of several functions to compute the Jacobian.  Users should not call these functions directly, they should use <code>physicsJac</code>. There are two approaches to computing the Jacobian: using finite differences/complex step and calculating the entries of the matrix explicitly. The latter approach is much faster than the former, however the former does not require the physics module differentiate <a href="../pdesolver_physics.html#PDESolver.evalResidual"><code>evalResidual</code></a>.</p><h2><a class="nav-anchor" id="Finite-Differencing/Complex-Step-1" href="#Finite-Differencing/Complex-Step-1">Finite Differencing/Complex Step</a></h2><p>The functions <a href="jacobian.html#NonlinearSolvers.calcJacFD"><code>calcJacFD</code></a> and <a href="jacobian.html#NonlinearSolvers.calcJacobianComplex"><code>calcJacobianComplex</code></a> compute the Jacobian as a dense matrix, one column at a time.  This is very slow and only useful for debugging small cases. A more efficient method is implemented in <a href="jacobian.html#NonlinearSolvers.calcJacobianSparse"><code>calcJacobianSparse</code></a>, which uses a graph coloring approach to perturb the solution at several nodes simultaneously. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.calcJacFD" href="#NonlinearSolvers.calcJacFD"><code>NonlinearSolvers.calcJacFD</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.calcJacFD</strong></p><p>This function calculates the Jacobian using finite differences, perturbing   one degree of freedom at a time.  This is slow and not very accurate.     The Jacobian is calculated about the point in eqn.q_vec.</p><p>Inputs:     mesh: AbstractMesh     sbp:  SBP operator     eqn:  AbstractEquation object     opts: options dictionary     pert: perturbation to use the finite differences.  Must be of type Tsol.     func: residual evaluation function     res_0: vector containing residual at the point the Jacobian is calculated</p><p>Inputs/Outputs:     jac:: Jacobian matrix to be populated.  Must be a dense matrix</p><p>Aliasing restrictions: res_0 must not alias eqn.res_vec</p><p>At the start, calcJacFD assumes:     The Jacobian will be calculated at the state that is specified in eqn.q_vec .     res_0 should have the residual at that state in it</p><p>At exit, eqn.q_vec will have the same values as at the start.</p><p>eqn.q and eqn.res will be overwritten in the course of this function.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L183-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.calcJacobianComplex" href="#NonlinearSolvers.calcJacobianComplex"><code>NonlinearSolvers.calcJacobianComplex</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.calcJacComplex</strong></p><p>This function calculates the Jacobian (dense) using the complex step method,    perturbing one degree of freedom at a time.  This is very slow.  The jacobian   is calculated about the point in eqn.q_vec.</p><p>Inputs:     mesh: AbstractMesh     sbp:  SBP operator     eqn:  AbstractEquation object     opts: options dictionary     pert: perturbation to use.  Must be of type Tsol.     func: residual evaluation function</p><p>Inputs/Outputs:     jac:: Jacobian matrix to be populated.  Must be a dense matrix</p><p>Aliasing restrictions: res_0 must not alias eqn.res_vec</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L247-L266">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.calcJacobianSparse" href="#NonlinearSolvers.calcJacobianSparse"><code>NonlinearSolvers.calcJacobianSparse</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.calcJacobianSparse</strong></p><p>This function calculate the Jacobian sparsely (only the entries      within the sparsity bounds), using either finite differences or algorithmic      differentiation.  The jacobian is calculated about the point stored in      eqn.q (not eqn.q_vec).  A mesh coloring approach is used to compute the     jacobian.  Both eqn.q and the MPI send and receive buffers are perturbed     during this process.</p><p>Inputs:     mesh: AbstractMesh     sbp:  SBP operator     eqn:  AbstractEquation object     opts: options dictionary     pert: perturbation to use for the algorithmic differentiation.  Currently,           only complex numbers are supported.     func: residual evaluation function (eqn.q -&gt; eqn.res)     res_0: element-based (3 dimensional) array containing the residual evaluated           at the point where the Jacobian is being calculated.            This is only used for finite differences (can be a 0 x 0 x 0 array            otherwise).</p><p>Inputs/Outputs:     jac:  Jacobian matrix.  Must be a sparse matrix type of some kind,            (including PetscMat).</p><p>Aliasing restrictions: res_0 must not alias eqn.res</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L328-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.applyPerturbation" href="#NonlinearSolvers.applyPerturbation"><code>NonlinearSolvers.applyPerturbation</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.applyPerturbation</strong></p><p>This function applies a perturbation to a the specified degree of freedom   on each element according to a mask.</p><p>Because this is element based perturbation, opts[&quot;parallel_data&quot;] must   be &quot;element&quot;.</p><p>Inputs:     mesh: an AbstractMesh     color: the color to perturb     pert: perturbation to apply.  Can be any datatype     i: local degree of freedom number (in range 1:numDofPerNode) to perturb     j: local node number (in range 1:numNodesPerElement) to perturb</p><p>Inputs/Outputs:     arr: element based (3D) array of values to perturb     shared_data: array of SharedFaceData for ghost elements to be perturbed                  The receive buffers are perturbed according to the masks                  in mesh.shared_element_colormasks, the send buffers are                  perturbed consistently with arr.</p><p>Aliasing restrictions: none</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L442-L466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.assembleElement" href="#NonlinearSolvers.assembleElement"><code>NonlinearSolvers.assembleElement</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Assembles the volume integral contribution.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian_diag.jl#L193-L195">source</a><div><p>This function assembles the jacobian contribution for a single element   into the matrix, when the jacobian is computed using finite differences.   This is used by coloring-based methods for computing the jacobian.</p><p><strong>Inputs:</strong></p><ul><li><p>helper: a AssembleData object</p></li><li><p>mesh:  AbstractMesh object</p></li><li><p>eqn:  AbstractEquation</p></li><li><p>res_arr: element-based (3D) array of perturbed residual values</p></li><li><p>res_0:  element-based (3D) array of non-perturbed residual values</p></li><li><p>el_res: element number of the element we are observing the change in</p></li><li><p>el_pert: element number of the element that was perturbed</p></li><li><p>dof_pert: the degree of freedom number of the perturbed dof</p></li><li><p>epsilon: magnitude of perturbation</p></li></ul><p><strong>Inputs/Outputs:</strong></p><ul><li><p>jac: any kind of matrix (dense, SparseMatrixCSC, PetscMat)</p></li></ul><p>Aliasing restrictions: res_arr and res_0 must not alias each other.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L521-L543">source</a><div><p>Same as other method, but for complex numbers.  See that method for   details.  res_0 is not used in this case</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L608-L611">source</a><div><p><strong>Inputs</strong></p><ul><li><p>helper: an _AssembleElementData</p></li><li><p>mesh: a mesh</p></li><li><p>elnum: element number</p></li><li><p>jac: 4 dimensional array containing the jacobian of the element</p></li></ul><p>jac contains the data for the jacobian of the volume terms for a given   element.  <span>$jac[i, j, p, q] = \partial R[i, p, elnum] / \partial eqn.q[j, q, elnum]$</span>.   Its size is numDofPerNode x numDofPerNode x numNodesPerElement x numNodesPerElement.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L796-L808">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.calcJacCol" href="#NonlinearSolvers.calcJacCol"><code>NonlinearSolvers.calcJacCol</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.calcJacCol</strong></p><p>This function extracts the entries for one column of the Jacobian from two residual evaluates that come from finite differences.</p><p>Inputs:     res_0: vector of unperturbed residual values     res: vector of perturbed residual values     epsilon: magnitude of perturbation</p><p>Inputs/Outputs:     jac_row = vector to be populated with the Jacobian entries</p><p>Aliasing restrictions: res_0 and res cannot alias (obviously).</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L574-L589">source</a><div><p><strong>NonlinearSolvers.calcJacCol</strong></p><p>This function extracts the entries for one column of the Jacobian from a    complex step residual evaluation</p><p>Inputs:     res: vector of perturbed residual values     epsilon: magnitude of perturbation</p><p>Inputs/Outputs:     jac_row = vector to be populated with the Jacobian entries</p><p>Aliasing restrictions: none</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L646-L661">source</a></section><h2><a class="nav-anchor" id="Explicit-Calculation-1" href="#Explicit-Calculation-1">Explicit Calculation</a></h2><p>The most efficient method to compute the Jacobian is to explicitly compute all its entries and assemble them into a matrix. The <a href="../pdesolver_physics.html#PDESolver.evalJacobian"><code>evalJacobian</code></a> function must be extended by each physics module for this to work. This function is passed all the same arguments as <a href="../pdesolver_physics.html#PDESolver.evalResidual"><code>evalResidual</code></a> plus an additional <a href="jacobian.html#NonlinearSolvers._AssembleElementData"><code>_AssembleElementData</code></a> object which is used to assemble the contribution of each element or interface into the matrix.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers._AssembleElementData" href="#NonlinearSolvers._AssembleElementData"><code>NonlinearSolvers._AssembleElementData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Helper object for assembling element and interface jacobians into the   system matrix.</p><p><strong>Fields</strong></p><ul><li><p>A: the matrix (can be Array, SparseMatrixCSC, or PetscMat)</p></li><li><p>idx: temporary array for row indices, length numDofPerNode</p></li><li><p>idy: temporary array for column indices, length numDofPerNode</p></li><li><p>vals: temporary array for matrix entries, size numDofPerNode square</p></li><li><p>idx_i: temporary array for row indices when assembling interface         jacobians, length 2 x numDofPerNode</p></li><li><p>idy_i: like idx_i, but for column indices</p></li><li><p>vals_i: temporary array for storing matrix entries when assembling         interface jacobians, size 2 x numDofPerNode square</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L681-L696">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers._AssembleElementData-Tuple{AbstractArray{T,2} where T,Any,Any,Any,Any}" href="#NonlinearSolvers._AssembleElementData-Tuple{AbstractArray{T,2} where T,Any,Any,Any,Any}"><code>NonlinearSolvers._AssembleElementData</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for <a href="jacobian.html#NonlinearSolvers._AssembleElementData"><code>_AssembleElementData</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L731-L733">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NullAssembleElementData" href="#NonlinearSolvers.NullAssembleElementData"><code>NonlinearSolvers.NullAssembleElementData</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>An empty <a href="jacobian.html#NonlinearSolvers._AssembleElementData"><code>_AssembleElementData</code></a>.  Useful for giving a default value   to fields.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L788-L791">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.assembleElement-Tuple{NonlinearSolvers._AssembleElementData,ODLCommonTools.AbstractMesh,Integer,Array{Float64,4}}" href="#NonlinearSolvers.assembleElement-Tuple{NonlinearSolvers._AssembleElementData,ODLCommonTools.AbstractMesh,Integer,Array{Float64,4}}"><code>NonlinearSolvers.assembleElement</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>Inputs</strong></p><ul><li><p>helper: an _AssembleElementData</p></li><li><p>mesh: a mesh</p></li><li><p>elnum: element number</p></li><li><p>jac: 4 dimensional array containing the jacobian of the element</p></li></ul><p>jac contains the data for the jacobian of the volume terms for a given   element.  <span>$jac[i, j, p, q] = \partial R[i, p, elnum] / \partial eqn.q[j, q, elnum]$</span>.   Its size is numDofPerNode x numDofPerNode x numNodesPerElement x numNodesPerElement.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L796-L808">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.assembleInterface" href="#NonlinearSolvers.assembleInterface"><code>NonlinearSolvers.assembleInterface</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Assembles contributions into an element-block matrix.  <code>jacLR</code> and <code>jacRL</code>   are not used.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian_diag.jl#L223-L226">source</a><div><p>Assembles the jacobian of an interface into the matrix.  Specialized   versions take advantage of the sparsity of the <code>sbpface</code>.</p><p><strong>Inputs</strong></p><ul><li><p>helper: _AssembleElementData</p></li><li><p>sbpface: an SBP face object</p></li><li><p>mesh: a mesh</p></li><li><p>iface: an Interface object identify the interface to be assembled</p></li><li><p>jacLL: see below</p></li><li><p>jacLR:</p></li><li><p>jacRL</p></li><li><p>jacRR</p></li></ul><p>jacAB where A = L or R and B = L or R, is the jacobian of the residual of   element A with respect to the solution of element B.</p><p>jacAB has the same size/layout as <code>jac</code> in <a href="jacobian.html#NonlinearSolvers.assembleElement"><code>assembleElement</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L982-L1001">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.assembleSharedFace" href="#NonlinearSolvers.assembleSharedFace"><code>NonlinearSolvers.assembleSharedFace</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Assembles contribution of the shared face terms into the element-block   matrix.  <code>jacLR</code> is not used.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian_diag.jl#L267-L270">source</a><div><p>Assemble one half of an interface, used by shared face integrals.   See <a href="jacobian.html#NonlinearSolvers.assembleInterface"><code>assembleInterface</code></a>.</p><p><strong>Inputs</strong></p><ul><li><p>helper: _AssembleElementData</p></li><li><p>sbpface: an SBP face object</p></li><li><p>mesh: a mesh</p></li><li><p>jacLL</p></li><li><p>jacLR</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L1219-L1230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.assembleBoundary" href="#NonlinearSolvers.assembleBoundary"><code>NonlinearSolvers.assembleBoundary</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Assembles the boundary terms into an element-block matrix.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian_diag.jl#L301-L303">source</a><div><p>Assembles the jacobian of a boundary integral into the matrix.   Specialized versions take advantage of the sparsity of the <code>sbpface</code>.</p><p><strong>Inputs</strong></p><ul><li><p>helper: _AssembleElementData</p></li><li><p>sbpface: an SBP face object</p></li><li><p>mesh: a mesh</p></li><li><p>jac: a jac, same layout as <a href="jacobian.html#NonlinearSolvers.assembleElement"><code>assembleElement</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/jacobian.jl#L1319-L1329">source</a></section><footer><hr/><a class="previous" href="newton.html"><span class="direction">Previous</span><span class="title">Newton&#39;s Method</span></a><a class="next" href="jac_recalc.html"><span class="direction">Next</span><span class="title">Jacobian Freezing</span></a></footer></article></body></html>

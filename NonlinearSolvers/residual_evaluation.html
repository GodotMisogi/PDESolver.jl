<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Residual Evalution · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="unsteady/intro.html">Intro</a></li><li><a class="toctext" href="unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="jac_recalc.html">Jacobian Freezing</a></li><li class="current"><a class="toctext" href="residual_evaluation.html">Residual Evalution</a><ul class="internal"></ul></li><li><a class="toctext" href="matrix.html">Matrix Interface</a></li><li><a class="toctext" href="newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>NonlinearSolvers</li><li><a href="residual_evaluation.html">Residual Evalution</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/21d1ed1e98a27b1109072fdac351bf63d3833b08/docs/src/NonlinearSolvers/residual_evaluation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Residual-Evaluation-1" href="#Residual-Evaluation-1">Residual Evaluation</a></h1><p>This page describes some helper functions used by various methods in the <code>NonlinearSolvers</code> module.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.physicsRhs" href="#NonlinearSolvers.physicsRhs"><code>NonlinearSolvers.physicsRhs</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function computes the vector form of of the residual from the vector   form of the solution, ie. q_vec -&gt; rhs_vec, for a given physics.   This is one of the two functions required by <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a>.</p><p>Users of newtonInner that are not physics modules (for example, implicit   time marching schemes) will need to implement their own version of this   function.  See the Implimentation Notes section below.</p><p><strong>Inputs</strong></p><ul><li>mesh: an AbstractMesh</li><li>sbp: an AbstractSBP</li><li>eqn: an AbstractSolutionData (may be modified during this function)</li><li>opts: the options dictionary</li><li>ctx_residual: a tuple of values.  ctx_residual[1] must be a function                    that computes (q -&gt; res).  Typically this is evalResidual.                    The other entries of the tuple (if any) are not used.</li></ul><pre><code class="language-none">               The purpose of this argument is to make the signature of
               the function generic enough so that implict time marching
               methods can use it.  (If you are confused about this
               programming pattern, google how callback are implemented
               in C, this ctx is like a void* in C).</code></pre><ul><li>t: the time at which to evalute the residual</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>rhs_vec: vector to put the residual in</li></ul><p><strong>Output</strong></p><ul><li>norm of the residual vector</li></ul><p><strong>Implementation Notes:</strong></p><p>This function is really a wrapper around an evalResidual-like function.   It has to do 5 things:</p><pre><code class="language-none">1. scatter eqn.q_vec -&gt; eqn.q
2. start parallel communication if needed
3. call the evalResidual-like function to compute eqn.q -&gt; eqn.res
4. assemble the residual into the output vector, ie. eqn.res -&gt; rhs_vec
5. compute the norm of the rhs_vec</code></pre><p>Any implementation of this function (used with newtonInner) must have the   following properties:</p><pre><code class="language-none">1. on exit, eqn.q and eqn.q_vec must be consistent
2. this function start parallel communication if needed
3. allow for the possibility that rhs_vec and eqn.res_vec alias</code></pre><p>Is is recommended to use <a href="../Utils/misc.html#Utils.calcNorm-Tuple{ODLCommonTools.AbstractSolutionData{Tsol,Tres},AbstractArray{T,N}}"><code>calcNorm</code></a> to compute the norm.</p><p>Other implementations of this function are encouraged to use this function   to help construct their rhs_vec.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.assembleResidual" href="#NonlinearSolvers.assembleResidual"><code>NonlinearSolvers.assembleResidual</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.assembleResidual</strong></p><p>This function takes the residual in eqn.res and performs an additive reduction   into res_vec.   This function wraps assembleSolution.</p><p>Inputs:     mesh: AbstractMesh     sbp:  SBP operator     eqn:  AbstractEquation object     opts: options dictionary     res_vec: residual vector to put the residual into</p><p>Outputs:     none</p><p>Aliasing restrictions: none</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.disassembleSolution-Tuple{Any,Any,Any,Any,AbstractArray{Float64,1}}" href="#Utils.disassembleSolution-Tuple{Any,Any,Any,Any,AbstractArray{Float64,1}}"><code>Utils.disassembleSolution</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>NonlinearSolvers.disassembleSolution</strong></p><p>This function performs the scatter q_vec -&gt; eqn.q</p><p>Inputs:     mesh: AbstractMesh     sbp:  SBP operator     eqn:  AbstractEquation object     opts: options dictionary     q_vec: vector containing solution variables </p><p>Outputs:     none</p><p>Aliasing Restrictions: none</p></div></section><footer><hr/><a class="previous" href="jac_recalc.html"><span class="direction">Previous</span><span class="title">Jacobian Freezing</span></a><a class="next" href="matrix.html"><span class="direction">Next</span><span class="title">Matrix Interface</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Jacobian Freezing · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="unsteady/intro.html">Intro</a></li><li><a class="toctext" href="unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="jacobian.html">Jacobian Calculation</a></li><li class="current"><a class="toctext" href="jac_recalc.html">Jacobian Freezing</a><ul class="internal"><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Construction-1">Construction</a></li><li><a class="toctext" href="#Recalculation-Policies-1">Recalculation Policies</a></li></ul></li><li><a class="toctext" href="residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="matrix.html">Matrix Interface</a></li><li><a class="toctext" href="newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>NonlinearSolvers</li><li><a href="jac_recalc.html">Jacobian Freezing</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/21d1ed1e98a27b1109072fdac351bf63d3833b08/docs/src/NonlinearSolvers/jac_recalc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Jacobian-and-Preconditioner-Freezing-1" href="#Jacobian-and-Preconditioner-Freezing-1">Jacobian and Preconditioner Freezing</a></h1><p>It is often faster to reuse the Jacobian and/or preconditioner than calculate a new one each major iteration.  The functions described here provide a consistant API for doing so.</p><p>Each method in <code>NonlinearSolvers</code> should specify if it supports Jacobian and PC freezing.  If it does, it should specify the <code>prefix</code> (see <a href="jac_recalc.html#Construction-1">Construction</a>).</p><p>Note that some methods use <code>newtonInner</code> internally.  It is sometimes beneficial to have <code>newtonInner</code> recompute the Jacobian and PC.  In other cases, using the same Jacobian and PC for several calls to <code>newtonInner</code> is beneficial.  Both these use cases are supported. Both <code>newtonInner</code> and the outer method can have their own <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a> objects. When the <code>newtonInner</code> <code>RecalculationPolicy</code> is <a href="jac_recalc.html#NonlinearSolvers.RecalculateNever"><code>RecalculateNever</code></a>, it will never recalculate the Jacobian and PC and the outer method will be the soley responsible for updaing the Jacobian and PC.  In the reverse case, the outer method can use <code>RecalculateNever</code> and let <code>newtonInner</code> recalculate the Jacobian and PC.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.doRecalculation" href="#NonlinearSolvers.doRecalculation"><code>NonlinearSolvers.doRecalculation</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function uses <a href="jac_recalc.html#NonlinearSolvers.decideRecalculation"><code>decideRecalculation</code></a> and the <a href="../linearsolvers/ls.html#LinearSolvers.LinearSolver"><code>LinearSolver</code></a>   interface to recalculate the PC and/or LO as specified by the policy.</p><p>This is the main interface the different methods should use for   recalculating the PC and/or LO.  The only case when   <a href="jac_recalc.html#NonlinearSolvers.decideRecalculation"><code>decideRecalculation</code></a> is better is when the method is not using   the LinearSolvers module to define the PC and LO.</p><p><strong>Inputs</strong></p><ul><li>policy: a <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a></li><li>itr: current iteration number</li></ul><p>The following arguments exactly match the signature of <a href="../linearsolvers/ls.html#LinearSolvers.calcPCandLO-Tuple{LinearSolvers.StandardLinearSolver{T1,T2},ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V},Any,Any}"><code>calcPCandLO</code></a></p><ul><li>ls</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>ctx_residual</li><li>t</li></ul><p>When this function exits, the PC and/or LO will have been updated, if   specified by the RecalculationPolicy.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.decideRecalculation" href="#NonlinearSolvers.decideRecalculation"><code>NonlinearSolvers.decideRecalculation</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the enum specifying whether the PC and/or LO should   be recalculated.</p><p>Every implementation of <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a> should extend this   function with a new method.</p><p><strong>Inputs</strong></p><ul><li>policy: a <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a></li><li>itr: the current iteration</li></ul><p><strong>Outputs</strong></p><ul><li>the num: see <a href="jac_recalc.html#NonlinearSolvers.RECALC_BOTH"><code>RECALC_BOTH</code></a></li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.resetRecalculationPolicy" href="#NonlinearSolvers.resetRecalculationPolicy"><code>NonlinearSolvers.resetRecalculationPolicy</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function should reset the RecalculationPolicy to its initial state.   This function is called at the beginning of Newton&#39;s method (making it   safe to reuse the RecalculationPolicy for repeated calls to Newton)</p><p>Every <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a> should extend function with a new   method.</p><p><strong>Inputs</strong></p><ul><li>policy: a <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a></li></ul><p><strong>Outputs</strong></p><ul><li>none</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.RECALC_BOTH" href="#NonlinearSolvers.RECALC_BOTH"><code>NonlinearSolvers.RECALC_BOTH</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Enums returned by <a href="jac_recalc.html#NonlinearSolvers.decideRecalculation"><code>decideRecalculation</code></a> telling the caller what to   recalculate.</p><p><strong>Enum Names</strong></p><ul><li>RECALC_BOTH: recalculate PC and LO</li><li>RECALC_PC: recalculate PC only</li><li>RECALC_LO: recalculate LO only</li><li>RECALC_NONE: don&#39;t recalculate anything</li></ul></div></section><h2><a class="nav-anchor" id="Construction-1" href="#Construction-1">Construction</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.getRecalculationPolicy" href="#NonlinearSolvers.getRecalculationPolicy"><code>NonlinearSolvers.getRecalculationPolicy</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function constructs and returns the recalculation policy specified by   the options dictionary.</p><p>Methods that want to use a RecalculationPolicy should this this function   to get it (do not call the constructors directly).</p><p><strong>Inputs</strong></p><ul><li>opts: options dictionary</li><li>prefix: prefix of options to use.  This is usually the name of the method              the returned object will be used in, eg. &quot;newton&quot;</li></ul><p><strong>Outputs</strong></p><ul><li>policy: a RecalculationPolicy of some kind</li></ul><p><strong>Options Keys</strong></p><ul><li>&quot;prefix_recalculation_policy&quot;: name of recalculation policy to get</li></ul><p><strong>Current Policies</strong></p><p>ASCIIString[&quot;RecalculateFixedIntervals&quot;,&quot;RecalculateNever&quot;]</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.RecalculationPolicyDict" href="#NonlinearSolvers.RecalculationPolicyDict"><code>NonlinearSolvers.RecalculationPolicyDict</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Maps names to <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a> constructors.  All new   recalculation policies must be added to this list.</p><p>The constructors must have the signature:</p><pre><code class="language-none">MyPolicyName(opts::Dict, prefix::ASCIIString)</code></pre><p>where <code>opts</code> is the options dictionary and <code>prefix</code> is the prefix passed into   <a href="jac_recalc.html#NonlinearSolvers.getRecalculationPolicy"><code>getRecalculationPolicy</code></a>.</p></div></section><h2><a class="nav-anchor" id="Recalculation-Policies-1" href="#Recalculation-Policies-1">Recalculation Policies</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.RecalculateFixedIntervals" href="#NonlinearSolvers.RecalculateFixedIntervals"><code>NonlinearSolvers.RecalculateFixedIntervals</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a> recalculates the LO and PC every <code>x</code>    number if iterations.</p><p><strong>Options Keys</strong></p><ul><li>&quot;prefix_prec_recalc_freq&quot;: frequency of PC recalculation</li><li>&quot;prefix_jac_recalc_freq&quot;: frequency of LO recalculation</li><li>&quot;prefix_recalc_first&quot;: if true, recalculate the PC and LO on the first                               iteration, even if other criteria not met.</li></ul><p>where &quot;prefix&quot; is the prefix passed into <a href="jac_recalc.html#NonlinearSolvers.getRecalculationPolicy"><code>getRecalculationPolicy</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.RecalculateNever" href="#NonlinearSolvers.RecalculateNever"><code>NonlinearSolvers.RecalculateNever</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a> never recalculates the PC or LO.  This is useful when Newton&#39;s method is used inside other methods to solve  easy problems.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.RecalculationPolicy" href="#NonlinearSolvers.RecalculationPolicy"><code>NonlinearSolvers.RecalculationPolicy</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This is the supertype of all types that tell a method when to recalculate   the Jacobian.  Each subtype defines a different policy for when to   recalculate.</p></div></section><footer><hr/><a class="previous" href="jacobian.html"><span class="direction">Previous</span><span class="title">Jacobian Calculation</span></a><a class="next" href="residual_evaluation.html"><span class="direction">Next</span><span class="title">Residual Evalution</span></a></footer></article></body></html>

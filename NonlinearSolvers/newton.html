<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Newton&#39;s Method · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="unsteady/intro.html">Intro</a></li><li><a class="toctext" href="unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li class="current"><a class="toctext" href="newton.html">Newton&#39;s Method</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Newton-internals-1">Newton internals</a></li><li class="toplevel"><a class="toctext" href="#NewtonData-API-1">NewtonData API</a></li></ul></li><li><a class="toctext" href="jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="matrix.html">Matrix Interface</a></li><li><a class="toctext" href="newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>NonlinearSolvers</li><li><a href="newton.html">Newton&#39;s Method</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/NonlinearSolvers/newton.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Newton&#39;s Method</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Newton&#39;s-method-1" href="#Newton&#39;s-method-1">Newton&#39;s method</a></h1><p>Newton&#39;s method is intended to compute updates to some q by solving the following equation.</p><p>\begin{equation} \frac{\partial R(q)}{\partial q} \Delta q = -R(q) \end{equation}</p><p>In the most basic implementation of Newton&#39;s method in PDESolver, q corresponds to the solution,    and f(q) corresponds to the residual evaluation of the currently selected physics module.</p><p>An example of a more sophisticated use of Newton&#39;s method is within the Crank-Nicolson timestepper,    which adds another layer on top of the physics residual:</p><p>\begin{equation} \frac{\partial g(R(q))}{\partial q} \Delta q = -g(R(q)) \end{equation}</p><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><p>PDESolver&#39;s Newton&#39;s method has a wide variety of features.  It contains the Jacobian calculation routines, which can be performed currently using:</p><ul><li><p>finite-differencing </p></li><li><p>complex-step</p></li></ul><p>The Jacobian functions can act upon any arbitrary residual.</p><p>Additionally, the following matrix forms are supported:</p><ul><li><p>Julia dense</p></li><li><p>Julia sparse</p></li><li><p>PETSc sparse</p></li><li><p>Matrix-free</p></li></ul><p>The function that performs the Newton iteration is </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.newtonInner" href="#NonlinearSolvers.newtonInner"><code>NonlinearSolvers.newtonInner</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function contains the algorithm for Newton&#39;s method.  It is intended   to be used by other functions rather than invoked as a solver directly.   For example <a href="NonlinearSolvers/@ref"><code>newton</code></a> uses newtonInner to solve steady problems while   <a href="NonlinearSolvers/@ref"><code>crank_nicolson</code></a> uses it to solve the nonlinear problem arising   from the time discretization.</p><p>For reference, Newton&#39;s method solves the problem R(q) = 0 using     dR/dq delta q = -R(q)   where R is the rsidual and q is the solution</p><p>On entry, eqn.q_vec must contain the initial guess for q.  On exit, eqn.q_vec   will contain the solution to f(q) = 0.  eqn.q will also be consistent with   eqn.q_vec, as will the send and receive buffers in eqn.shared_data</p><p>On exit, rhs_vec will have the residual corresponding to eqn.q_vec in it,   with the imaginary part set to zero.</p><p>The <a href="../linearsolvers/lo.html#LinearSolvers.AbstractLO"><code>AbstractLO</code></a> and <a href="../linearsolvers/pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> supplied   inside the <a href="../linearsolvers/ls.html#LinearSolvers.LinearSolver"><code>LinearSolver</code></a> object must match the <code>jac_type</code>.</p><p>When doing inexact Newton-Krylov, <code>newonInner</code> modifies the tolerances   of the linear solver.  Users calling <code>newtonInner</code> repeatedly with the   same linear solver object should reset the initial tolerances as needed.</p><p><strong>Inputs:</strong></p><ul><li><p>newton_data: NewtonData object, typically obtained from setupNewton</p></li><li><p>mesh: a mesh object</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: a solution data object</p></li><li><p>opts: options dictionary</p></li><li><p>ls: a LinearSolver with the preconditioner and linear operator fully     initialized.  </p></li><li><p>rhs_vec: vector to store R(q) in</p></li><li><p>ctx_residual: extra data required by rhs_func</p></li></ul><p>The user must supply two functions, one to calculate the residual vector   (referred to as rhs_vec), and another to compute the Jacobian.</p><p>rhs_func should compute (eqn.q_vec) -&gt; (rhs_vec) and have the signature</p><pre><code class="language-none">rhs_func(mesh, sbp, eqn, opts, rhs_vec, ctx_residual, t=0.0)</code></pre><p>Note that the ctx_residual passed into newtonInner is passed directly   to rhs_func.  The contents of ctx_residual can be whatever is needed by   rhs_func to perform its computation.  See <a href="residual_evaluation.html#NonlinearSolvers.physicsRhs"><code>physicsRhs</code></a> for   the specific requirements on rhs_func and for an example implementation.</p><p>The same ctx_residual passed into newtonInner is passed directly to   <a href="../linearsolvers/lo.html#LinearSolvers.calcLinearOperator"><code>calcLinearOperator</code></a>..</p><p>This function supports jacobian/preconditioner freezing using the   prefix &quot;newton&quot;.</p><p>Aliasing restrictions: None.  In particular, rhs_vec <em>can</em> alias eqn.res_vec,                          and this leads so some efficiency because it avoids                          needlessly copying data.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton.jl#L77-L137">source</a></section><p>The private data required by Newtons method is stored in the <code>NewtonData</code> object.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.setupNewton" href="#NonlinearSolvers.setupNewton"><code>NonlinearSolvers.setupNewton</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>NonlinearSolvers.setupNewton</strong></p><p>Performs setup work for <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a>, including creating a    <a href="newton.html#NonlinearSolvers.NewtonData"><code>NewtonData</code></a> object.</p><p>This function also resets the implicit Euler globalization.</p><p>alloc_rhs: keyword arg to allocate a new object or not for rhs_vec                 true (default) allocates a new vector                 false will use eqn.res_vec</p><p>rhs_func: only used for Petsc in matrix-free mode to do Jac-vec products             should be the rhs_func passed into <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a>   ctx_residual: ctx_residual passed into <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a></p><p>Allocates Jac &amp; RHS</p><p>See <a href="NonlinearSolvers/@ref"><code>cleanupNewton</code></a> to the cleanup function</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L131-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.free-Tuple{NonlinearSolvers.NewtonData}" href="#Utils.free-Tuple{NonlinearSolvers.NewtonData}"><code>Utils.free</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Cleans up after running Newton&#39;s method.</p><p><strong>Inputs</strong></p><ul><li><p>newton_data: the NewtonData object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L194-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.getNewtonPCandLO" href="#NonlinearSolvers.getNewtonPCandLO"><code>NonlinearSolvers.getNewtonPCandLO</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Returns the Newton precondtioner and linear operator specified by the options   dictionary</p><p><strong>Inputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>rhs_func: rhs_func required by <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L250-L261">source</a></section><h2><a class="nav-anchor" id="Newton-internals-1" href="#Newton-internals-1">Newton internals</a></h2><h1><a class="nav-anchor" id="NewtonData-API-1" href="#NewtonData-API-1">NewtonData API</a></h1><p><a href="newton.html#NonlinearSolvers.NewtonData"><code>NewtonData</code></a> has a small API used by Newton&#39;s method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonData" href="#NonlinearSolvers.NewtonData"><code>NonlinearSolvers.NewtonData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type holds the data required by <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a> as well as   configuration settings.</p><p><strong>Public Fields</strong></p><ul><li><p>myrank: MPI rank</p></li><li><p>commsize: MPI communicator size</p></li><li><p>itr: number of iterations</p></li><li><p>res_norm_i: current iteration residual norm</p></li><li><p>res_norm_i_1: previous iteration residual norm</p></li><li><p>step_norm_i: current iteration newton step norm</p></li><li><p>step_norm_i_1: previous iteration newton step norm</p></li><li><p>res_norm_rel: norm of residual used as the reference point when computing               relative residuals.  If this is -1 on entry to newtonInner,               then the norm of the initial residual is used.</p></li><li><p>step_fac: factor used in step size limiter</p></li><li><p>res_reltol: nonlinear relative residual tolerance</p></li><li><p>res_abstol: nonlinear residual absolute tolerance</p></li><li><p>step_tol: step norm tolerance</p></li><li><p>itermax: maximum number of newton iterations</p></li><li><p>use_inexact_nk: true if inexact-NK should be used, false otherwise</p></li><li><p>krylov_gamma: parameter used by inexact newton-krylov</p></li><li><p>recalc_policy: a <a href="jac_recalc.html#NonlinearSolvers.RecalculationPolicy"><code>RecalculationPolicy</code></a>.</p></li><li><p>ls: a <a href="../linearsolvers/ls.html#LinearSolvers.LinearSolver"><code>LinearSolver</code></a></p></li><li><p>fconv: convergence.dat file handle (or DevNull if not used)</p></li><li><p>verbose: how much logging/output to do</p></li></ul><p><strong>Options Keys</strong></p><p>If <code>res_reltol0</code> is negative, the residual of the initial condition will be   used for res_norm_rel</p><p><code>newton_verbosity</code> is used to the <code>verbose</code> field</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L4-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.reinitNewtonData" href="#NonlinearSolvers.reinitNewtonData"><code>NonlinearSolvers.reinitNewtonData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Reinitialized the NewtonData object for a new solve.</p><p>Note that this does not reset the linear solver, which might be a problem   if inexact newton-krylov was used for the previous solve</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L174-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.recordResNorm" href="#NonlinearSolvers.recordResNorm"><code>NonlinearSolvers.recordResNorm</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Records the most recent nonlinear residual norm in the NewtonData object.   Also updates the implicit Euler globalization</p><p><strong>Inputs</strong></p><ul><li><p>newton_data: the NewtonData</p></li><li><p>res_norm: the residual norm</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L210-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.recordStepNorm" href="#NonlinearSolvers.recordStepNorm"><code>NonlinearSolvers.recordStepNorm</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Records norm of the most recent newton step (ie. the norm of delta q)   in the NewtonData object</p><p><strong>Inputs</strong></p><ul><li><p>newton_data: the NewtonData object</p></li><li><p>step_norm: the norm of the step</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L230-L238">source</a></section><h3><a class="nav-anchor" id="Linear-Operators-and-Preconditioners-1" href="#Linear-Operators-and-Preconditioners-1">Linear Operators and Preconditioners</a></h3><p>A full set of linear operators and preconditioners are provided for solving a linear system where the linear operator is the jacobian of the physics..  These often are a good start for constructing linear operators for unsteady problems or more advanced methods for solving steady problems.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonMatPC" href="#NonlinearSolvers.NewtonMatPC"><code>NonlinearSolvers.NewtonMatPC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Matrix-based Petsc preconditioner for Newton&#39;s method</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L307-L309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonMatPC-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#NonlinearSolvers.NewtonMatPC-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>NonlinearSolvers.NewtonMatPC</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for <a href="newton.html#NonlinearSolvers.NewtonMatPC"><code>NewtonMatPC</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L316-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonVolumePC" href="#NonlinearSolvers.NewtonVolumePC"><code>NonlinearSolvers.NewtonVolumePC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type holds all the data needed to calculate a preconditioner based only   on the volume integrals.  For DG methods, this matrix is block diagonal and   thus easily invertible.  This preconditioner is applied matrix-free.</p><p>jac_size is numDofPerNode * numNodesPerElememnt (the total number of unknowns   on an element).</p><p>This preconditioner is not suitable for use as an inner preconditioner, but   the functions <a href="NonlinearSolvers/@ref"><code>calcVolumePC</code></a>, <a href="NonlinearSolvers/@ref"><code>factorVolumePC</code></a>, and   <a href="NonlinearSolvers/@ref"><code>applyVolumPC</code></a> can be easily used to make a new PC.</p><p><strong>Fields</strong></p><ul><li><p>volume_jac: jacobian of the volume integrals of each element,              jac_size x jac_size x numEl</p></li><li><p>ipiv: permutation information, jac_size x numEl</p></li><li><p>is_factored: if true, volume_jac has been factored (LU with partial              pivoting), false otherwise</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/preconditioning_types.jl#L7-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonVolumePreconditioner-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#NonlinearSolvers.NewtonVolumePreconditioner-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>NonlinearSolvers.NewtonVolumePreconditioner</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Regular constructor</p><p><strong>Inputs</strong></p><ul><li><p>mesh: the mesh</p></li><li><p>sbp: the SBP operator</p></li><li><p>eqn: AbstractSolutionData</p></li><li><p>opts: options dictionary</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/preconditioning_types.jl#L38-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonDenseLO" href="#NonlinearSolvers.NewtonDenseLO"><code>NonlinearSolvers.NewtonDenseLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Dense linear operator for Newton&#39;s method.</p><p>Subtype of <a href="../linearsolvers/lo.html#LinearSolvers.AbstractDenseLO"><code>AbstractDenseLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L360-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonDenseLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#NonlinearSolvers.NewtonDenseLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>NonlinearSolvers.NewtonDenseLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for <a href="newton.html#NonlinearSolvers.NewtonDenseLO"><code>NewtonDenseLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L370-L372">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonSparseDirectLO" href="#NonlinearSolvers.NewtonSparseDirectLO"><code>NonlinearSolvers.NewtonSparseDirectLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Sparse direct linear operator for Newton&#39;s method.  Subtype of   <a href="../linearsolvers/lo.html#LinearSolvers.AbstractSparseDirectLO"><code>AbstractSparseDirectLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L390-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonSparseDirectLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#NonlinearSolvers.NewtonSparseDirectLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>NonlinearSolvers.NewtonSparseDirectLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for <a href="newton.html#NonlinearSolvers.NewtonSparseDirectLO"><code>NewtonSparseDirectLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L399-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonPetscMatLO" href="#NonlinearSolvers.NewtonPetscMatLO"><code>NonlinearSolvers.NewtonPetscMatLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Petsc matrix based linear operator for Newton&#39;s method.</p><p>Subtype of <a href="../linearsolvers/lo.html#LinearSolvers.AbstractPetscMatLO"><code>AbstractPetscMatLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L420-L424">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonPetscMatLO-Tuple{Union{LinearSolvers.AbstractPetscMatFreePC, LinearSolvers.AbstractPetscMatPC},ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#NonlinearSolvers.NewtonPetscMatLO-Tuple{Union{LinearSolvers.AbstractPetscMatFreePC, LinearSolvers.AbstractPetscMatPC},ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>NonlinearSolvers.NewtonPetscMatLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for <a href="newton.html#NonlinearSolvers.NewtonPetscMatLO"><code>NewtonPetscMatLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L430-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonPetscMatFreeLO" href="#NonlinearSolvers.NewtonPetscMatFreeLO"><code>NonlinearSolvers.NewtonPetscMatFreeLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Petsc matrix-free linear operator for Newton&#39;s method.</p><p>Subtype of <a href="../linearsolvers/lo.html#LinearSolvers.AbstractPetscMatFreeLO"><code>AbstractPetscMatFreeLO</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L451-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.NewtonPetscMatFreeLO-Tuple{Union{LinearSolvers.AbstractPetscMatFreePC, LinearSolvers.AbstractPetscMatPC},ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#NonlinearSolvers.NewtonPetscMatFreeLO-Tuple{Union{LinearSolvers.AbstractPetscMatFreePC, LinearSolvers.AbstractPetscMatPC},ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>NonlinearSolvers.NewtonPetscMatFreeLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Newton mat-free linear operator constructor</p><p><strong>Inputs</strong></p><ul><li><p>pc</p></li><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>rhs_func: rhs_func from <a href="newton.html#NonlinearSolvers.newtonInner"><code>newtonInner</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/NonlinearSolvers/newton_setup.jl#L461-L472">source</a></section><footer><hr/><a class="previous" href="unsteady/cn_uadj.html"><span class="direction">Previous</span><span class="title">Crank-Nicolson: Unsteady Adjoint</span></a><a class="next" href="jacobian.html"><span class="direction">Next</span><span class="title">Jacobian Calculation</span></a></footer></article></body></html>

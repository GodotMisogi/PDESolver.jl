<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Newton Inner · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="unsteady/intro.html">Intro</a></li><li><a class="toctext" href="unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="matrix.html">Matrix Interface</a></li><li class="current"><a class="toctext" href="newton_inner.html">Newton Inner</a><ul class="internal"><li><a class="toctext" href="#NewtonData-type-1">NewtonData type</a></li><li><a class="toctext" href="#setupNewton-1">setupNewton</a></li><li><a class="toctext" href="#newtonInner-1">newtonInner</a></li></ul></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>NonlinearSolvers</li><li><a href="newton_inner.html">Newton Inner</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/6cd5bf9fae313f05b0c64c3424dbf0f6bd2b0ed7/docs/src/NonlinearSolvers/newton_inner.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Newton_inner-1" href="#Newton_inner-1">Newton_inner</a></h1><h2><a class="nav-anchor" id="NewtonData-type-1" href="#NewtonData-type-1">NewtonData type</a></h2><h2><a class="nav-anchor" id="setupNewton-1" href="#setupNewton-1">setupNewton</a></h2><h2><a class="nav-anchor" id="newtonInner-1" href="#newtonInner-1">newtonInner</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NonlinearSolvers.physicsRhs" href="#NonlinearSolvers.physicsRhs"><code>NonlinearSolvers.physicsRhs</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function computes the vector form of of the residual from the vector   form of the solution, ie. q_vec -&gt; rhs_vec, for a given physics.   This is one of the two functions required by <a href="@ref"><code>newtonInner</code></a>.</p><p>Users of newtonInner that are not physics modules (for example, implicit   time marching schemes) will need to implement their own version of this   function.  See the Implimentation Notes section below.</p><p><strong>Inputs</strong></p><ul><li>mesh: an AbstractMesh</li><li>sbp: an AbstractSBP</li><li>eqn: an AbstractSolutionData (may be modified during this function)</li><li>opts: the options dictionary</li><li>ctx_residual: a tuple of values.  ctx_residual[1] must be a function                    that computes (q -&gt; res).  Typically this is evalResidual.                    The other entries of the tuple (if any) are not used.</li></ul><pre><code class="language-none">               The purpose of this argument is to make the signature of
               the function generic enough so that implict time marching
               methods can use it.  (If you are confused about this
               programming pattern, google how callback are implemented
               in C, this ctx is like a void* in C).</code></pre><ul><li>t: the time at which to evalute the residual</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>rhs_vec: vector to put the residual in</li></ul><p><strong>Output</strong></p><ul><li>norm of the residual vector</li></ul><p><strong>Implementation Notes:</strong></p><p>This function is really a wrapper around an evalResidual-like function.   It has to do 5 things:</p><pre><code class="language-none">1. scatter eqn.q_vec -&gt; eqn.q
2. start parallel communication if needed
3. call the evalResidual-like function to compute eqn.q -&gt; eqn.res
4. assemble the residual into the output vector, ie. eqn.res -&gt; rhs_vec
5. compute the norm of the rhs_vec</code></pre><p>Any implementation of this function (used with newtonInner) must have the   following properties:</p><pre><code class="language-none">1. on exit, eqn.q and eqn.q_vec must be consistent
2. this function start parallel communication if needed
3. allow for the possibility that rhs_vec and eqn.res_vec alias</code></pre><p>Is is recommended to use <a href="../Utils/misc.html#Utils.calcNorm-Tuple{ODLCommonTools.AbstractSolutionData{Tsol,Tres},AbstractArray{T,N}}"><code>calcNorm</code></a> to compute the norm.</p><p>Other implementations of this function are encouraged to use this function   to help construct their rhs_vec.</p></div></section><footer><hr/><a class="previous" href="matrix.html"><span class="direction">Previous</span><span class="title">Matrix Interface</span></a><a class="next" href="../Utils/Utils.html"><span class="direction">Next</span><span class="title">Main</span></a></footer></article></body></html>

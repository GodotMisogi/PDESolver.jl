<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Crank-Nicolson: Unsteady Adjoint · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../../build.html">Building PDESolver</a></li><li><a class="toctext" href="../../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../../input/input.html">Introduction</a></li><li><a class="toctext" href="../../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="intro.html">Intro</a></li><li><a class="toctext" href="rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="lserk.html">LSERK</a></li><li><a class="toctext" href="cn.html">Crank-Nicolson</a></li><li class="current"><a class="toctext" href="cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a><ul class="internal"><li><a class="toctext" href="#Current-status-1">Current status</a></li><li><a class="toctext" href="#Unsteady-adjoint-derivation-1">Unsteady adjoint derivation</a></li></ul></li></ul></li><li><a class="toctext" href="../newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>NonlinearSolvers</li><li>Unsteady</li><li><a href="cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/cd605579e05af7f90c72771fb7335177465209f5/docs/src/NonlinearSolvers/unsteady/cn_uadj.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Crank-Nicolson-Unsteady-Adjoint-–-EXPERIMENTAL,-INCORRECT-CODE-1" href="#Crank-Nicolson-Unsteady-Adjoint-–-EXPERIMENTAL,-INCORRECT-CODE-1">Crank-Nicolson Unsteady Adjoint – EXPERIMENTAL, INCORRECT CODE</a></h1><h2><a class="nav-anchor" id="Current-status-1" href="#Current-status-1">Current status</a></h2><p>As of mid-September, 2017, development of PDESolver&#39;s unsteady adjoint has been tabled for the time being. The code is preserved, and is accessible with the <code>run_flag</code> of 660. It runs with no errors, and produces a solution that qualititatively demonstrates properties of the correct unsteady adjoint. However, a test sensitivity check does not pass.</p><p>Notation for this section:</p><ul><li>R is the residual</li><li>A is the design variable: the amplitude of a sin function that is an exact solution to the advection equation:      \begin{equation}     u = A \sin(-x + \omega t)     \end{equation}</li><li>J is the objective function:     \begin{equation}     J = \int_{\Gamma_1} u^2 d\Gamma_1     \end{equation}</li><li>\Gamma_1 is the right domain boundary in a square domain</li></ul><p>Some notes about current status that may be of assistance to further development or debugging:</p><ul><li>dRdA makes physical sense, and FD and CS methods match</li><li>dJdu FD, CS, and analytical derivative match</li><li>J is verified by setting a polynomial solution for which SBP should be exact.</li><li>loaded checkpoints match forward solve</li><li>norm of Jacobian calculated from loaded checkpoint matches forward solve&#39;s</li><li>time stepping bookkeeping in forward and reverse appears correct </li><li>Adjoint initial condition equation appears to match the below derivation, as far as code-reading can show</li><li>While the test sensitivity check is incorrect at all time steps,    the fact that it is incorrect at the adjoint initial condition indicates that the    bug manifests itself before the main reverse-sweep time-stepping loop.</li></ul><p>The test sensitivity check being performed is the comparison between these two derivatives:</p><p>\begin{equation} \frac{d J}{d A} &amp;= \frac{\partial J}{\partial u} \frac{\partial u}{\partial A} \
\end{equation}</p><p>\begin{equation} \frac{d J}{d A} &amp;= \psi^T \left( - \frac{\partial R}{\partial A}\right) \end{equation}</p><p>For the above, note that: \begin{equation} \frac{\partial J}{\partial A} = 0 \end{equation}</p><h2><a class="nav-anchor" id="Unsteady-adjoint-derivation-1" href="#Unsteady-adjoint-derivation-1">Unsteady adjoint derivation</a></h2><p>The unsteady adjoint derivation starts with the generic Lagrangian equation:</p><p>\begin{equation} \mathcal{L}(u, \psi) = \psi^T R(u) + J(u) \end{equation}</p><p>In the discrete context of CN, all of these variables are global-in-time. That is, the adjoint vector contains the adjoint at time step 1 concatenated with    the adjoint at time step 2, and so on, until time step <span>$n$</span>. Therefore, in this document we will rewrite the Lagrangian using bolded symbols to indicate    that a vector or matrix is global-in-time, as there will also be corresponding variables   specific to a particular time step:</p><p>\begin{equation} \boldsymbol{\mathcal{L}}(\boldsymbol{u}, \boldsymbol{\psi}) = \boldsymbol{\psi}^T \boldsymbol{R}(\boldsymbol{u}) + \boldsymbol{J}(\boldsymbol{u}) \end{equation}</p><p>The global-in-time residual discretized according to the Crank-Nicolson method is:</p><div>\[\boldsymbol{R(\boldsymbol{u})} = \begin{bmatrix} u_1 - u_0 - \frac{\Delta t}{2} R(u_1) - \frac{\Delta t}{2} R(u_0) \\ u_2 - u_1 - \frac{\Delta t}{2} R(u_2) - \frac{\Delta t}{2} R(u_1) \\ \vdots \\ u_i - u_{i-1} - \frac{\Delta t}{2} R(u_i) - \frac{\Delta t}{2} R(u_{i-1}) \\ u_{i+1} - u_{i} - \frac{\Delta t}{2} R(u_{i+1}) - \frac{\Delta t}{2} R(u_{i}) \\ \vdots \\ u_n - u_{n-1} - \frac{\Delta t}{2} R(u_n) - \frac{\Delta t}{2} R(u_{n-1}) \end{bmatrix}\]</div><p>The global-in-time adjoint vector is:</p><div>\[\boldsymbol{\psi}^T = [\psi_1^T, \psi_2^T, \dots, \psi_i^T, \psi_{i+1}^T, \dots, \psi_n^T]\]</div><p>Note that each time step&#39;s adjoint variable is a vector of length equal to the number of degrees of freedom in the mesh. And finally, the global-in-time objective function vector is:</p><div>\[\boldsymbol{J}^T = [J_1, J_2, \dots, J_i, J_{i+1}, \dots, J_n]\]</div><p>Therefore, the full discrete Lagrangian is:</p><div>\[\boldsymbol{\mathcal{L}}(\boldsymbol{u}, \boldsymbol{\psi}) = \boldsymbol{\psi}^T \boldsymbol{R(\boldsymbol{u})} + \boldsymbol{J}(\boldsymbol{u}) = \begin{bmatrix} \psi_1^T \left( u_1 - u_0 - \frac{\Delta t}{2} R(u_1) - \frac{\Delta t}{2} R(u_0) \right) \\ \psi_2^T \left( u_2 - u_1 - \frac{\Delta t}{2} R(u_2) - \frac{\Delta t}{2} R(u_1) \right) \\ \vdots \\ \psi_i^T \left( u_i - u_{i-1} - \frac{\Delta t}{2} R(u_i) - \frac{\Delta t}{2} R(u_{i-1}) \right) \\ \psi_{i+1}^T \left( u_{i+1} - u_{i} - \frac{\Delta t}{2} R(u_{i+1}) - \frac{\Delta t}{2} R(u_{i}) \right) \\ \vdots \\ \psi_n^T \left( u_n - u_{n-1} - \frac{\Delta t}{2} R(u_n) - \frac{\Delta t}{2} R(u_{n-1}) \right) \end{bmatrix} + \begin{bmatrix} J(u_1) \\ J(u_2) \\ \vdots \\ J(u_i) \\ J(u_{i+1}) \\ \vdots \\ J(u_n) \end{bmatrix}\]</div><p>Taking the derivative of the Lagrangian with respect to the state at step <span>$i$</span> yields, for values of i not equal to 0 or n:</p><div>\[\frac{\partial \boldsymbol{L}}{\partial u_i} = \underbrace{\psi_i^T - \psi_i^T \frac{\Delta t}{2} \frac{\partial R(u_i)}{\partial u_i}}_{\text{contribution from }\boldsymbol{R}(u_i)} - \underbrace{\psi_{i+1}^T - \psi_{i+1}^T \frac{\Delta t}{2} \frac{\partial R(u_i)}{\partial u}}_{\text{contribution from }\boldsymbol{R}(u_{i+1})} + \frac{\partial J(u_i)}{\partial u_i}= 0^T\]</div><p>Or, rearranging:</p><div>\[\frac{\partial \boldsymbol{L}}{\partial u_i} = (\psi_i - \psi_{i+1}) - \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T (\psi_i + \psi_{i+1}) + \frac{\partial J(u_i)}{\partial u_i} = 0\]</div><h3><a class="nav-anchor" id="Initial-Condition-1" href="#Initial-Condition-1">Initial Condition</a></h3><p>The derivative of the Lagrangian with respect to the state at the final step <span>$i = n$</span> is:</p><div>\[\frac{\partial \boldsymbol{L}}{\partial u_n} = \psi_n - \frac{\Delta t}{2} \left( \frac{\partial R(u_n)}{\partial u_n} \right)^T \psi_n + \frac{\partial J(u_n)}{\partial u_n} = 0\]</div><p>Therefore, the value of the adjoint at time step n, which is the initial condition for the reverse sweep, is:</p><div>\[\psi_n = \left( \left(I - \frac{\Delta t}{2} \frac{\partial R(u_n)}{\partial u_n} \right)^T \right)^{-1} \left( - \frac{\partial J(u_n)}{\partial u_n} \right)^T\]</div><h3><a class="nav-anchor" id="Direct-Solve-1" href="#Direct-Solve-1">Direct Solve</a></h3><p>The method of performing a direct solve to advance the CN reverse sweep (as opposed to using Newton&#39;s method to converge each time step) starts with the restatement of the derivative of the Lagrangian at time step <span>$i$</span>:</p><div>\[\frac{\partial \boldsymbol{L}}{\partial u_i} = \underbrace{\psi_i^T - \psi_i^T \frac{\Delta t}{2} \frac{\partial R(u_i)}{\partial u_i}}_{\text{contribution from }\boldsymbol{R}(u_i)} - \underbrace{\psi_{i+1}^T - \psi_{i+1}^T \frac{\Delta t}{2} \frac{\partial R(u_i)}{\partial u}}_{\text{contribution from }\boldsymbol{R}(u_{i+1})} + \frac{\partial J(u_i)}{\partial u_i}= 0^T\]</div><p>Rearranging:</p><div>\[\left[ \psi_i - \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T \psi_i \right] - \left[ \psi_{i+1} + \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T \psi_{i+1} \right] + \frac{\partial J(u_i)}{\partial u_i} = 0\]</div><p>Grouping terms to isolate <span>$\psi_i$</span>:</p><div>\[\left[ I - \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T \right] \psi_i = \left[ \psi_{i+1} + \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T \psi_{i+1} \right] - \frac{\partial J(u_i)}{\partial u_i}\]</div><p>Solving for <span>$\psi_i$</span>:</p><div>\[\psi_i = \left[ I - \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T \right]^{-1} \left( \left[ \psi_{i+1} + \frac{\Delta t}{2} \left( \frac{\partial R(u_i)}{\partial u_i} \right)^T \psi_{i+1} \right] - \frac{\partial J(u_i)}{\partial u_i} \right)\]</div><p>Therefore, <span>$\psi_i$</span> is a function of 1) the Jacobian of the primal solution at step <span>$i$</span>, which is loaded from checkpointed data, 2) the derivative of the objective function with respect to the state, at step <span>$i$</span>, and 3) the adjoint solution at time step <span>$i+1$</span>.  The adjoint solution sweep is thus stepped backwards in time, starting at time step <span>$n$</span>.</p><h3><a class="nav-anchor" id="Checkpointing-1" href="#Checkpointing-1">Checkpointing</a></h3><p>Currently, all time steps are checkpointed.  Eventually, Revolve will be implemented, for which a separate Julia package has been developed.  See <a href="http://dl.acm.org/citation.cfm?id=347846">here</a> for the publication discussing the Revolve algorithm.</p><h3><a class="nav-anchor" id="Global-in-time-Jacobian-1" href="#Global-in-time-Jacobian-1">Global-in-time Jacobian</a></h3><p>For reference, the structure of the global-in-time Jacobian is shown here. It should never be formed except in the course of debugging very simple use cases,    but it can be helpful for visualizing the matrix form of CN for all space and time.</p><p>(Work in progress)</p><footer><hr/><a class="previous" href="cn.html"><span class="direction">Previous</span><span class="title">Crank-Nicolson</span></a><a class="next" href="../newton.html"><span class="direction">Next</span><span class="title">Newton&#39;s Method</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li class="current"><a class="toctext" href="input.html">Introduction</a><ul class="internal"><li><a class="toctext" href="#Conventions-1">Conventions</a></li><li><a class="toctext" href="#Key-Validation-1">Key Validation</a></li></ul></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Input</li><li><a href="input.html">Introduction</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/39e1a498a6dc4e7afd00f73cf860b3b9ad76ddc8/docs/src/input/input.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Input-1" href="#Input-1">Input</a></h1><p>A PDESolver execution is controlled by an options dictonary.  The user must supply this dictonary in the form of a Julia source file that declares a <code>Dict{Any, Any}</code> called <code>arg_dict</code>. The file path (relative to the users <code>pwd</code> must be passed to the solver as the the first optional argument.  For example, to launch a PDESolver run, execute</p><pre><code class="language-none">julia /path/to/startup.jl &quot;path/to/dictonary&quot;</code></pre><p>Descriptions of the valid keys and values can be found in the file <a href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/work/src/input/input_vals.txt">input_vals.txt</a>. PDESolver supplies default values for all keys for which there is a sane default.  Values that might be unused are initialized to -1 or &quot;none&quot;.</p><h2><a class="nav-anchor" id="Conventions-1" href="#Conventions-1">Conventions</a></h2><p>Physics modules generally use the <code>majorIterationCallback</code> function to log important quantities to files.  Such logging should be controlled by two keys, <code>&quot;write_outname&quot;</code> where <code>outname</code> is the name of the quantity, which has a boolean value, and <code>&quot;write_outname_fname&quot;</code> that has a string value containing the name of the file to write (including extension).  Examples out things that can be logged are entropy and kinetic energy.  Both these keys should have default values, and users should generally not need to modify the second one.</p><h2><a class="nav-anchor" id="Key-Validation-1" href="#Key-Validation-1">Key Validation</a></h2><p>After supplying default values, PDESolver checks that all keys in the dictonary are recognized keys.  It does this by comparing against the list of keys documented in the <a href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/work/src/input/input_vals.txt">input_vals.txt</a> file.  A warning of is printed to STDERR if an unrecognized key is found.</p><p>The mechanics of the key validation are as follows.  The <code>extract_keys.jl</code> script reads the <a href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/work/src/input/input_vals.txt">input_vals.txt</a> file (and the input_vals_internal.txt), looking for any string that is surrounded by double quotes and starts in the first character of a line.  All keys are written to a dictonary in the file <code>known_keys.jl</code>.  This file is included by PDESolver.</p><p>The script <code>extract_keys.jl</code> is run as part of PDESolver installation.  If new keys are added it must be run again to silence warnings during key validation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Input.make_input-Tuple{Dict{K,V},AbstractString}" href="#Input.make_input-Tuple{Dict{K,V},AbstractString}"><code>Input.make_input</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Make an input file from an options dictionary.</p><p>Inputs:     dict: the options dictionary     fname: the file name (without extension)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Input.read_input-Tuple{AbstractString}" href="#Input.read_input-Tuple{AbstractString}"><code>Input.read_input</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>PDESolver.read_input</strong></p><p>This function reads a file which must  be a julia source file that declares   a dictionary of option keywords and values for the options named arg_dict.   See the documention on input variables for valid keywords.</p><p>read_input() returns the dictionary after doing some sanity checks and   supplying default values for any unspecified keys.</p><p>After supplying default values, it prints the dictonary to arg_dict_output.jl,   which is a valid julia source file and can be read in to re-run a simulation.</p><p>This function checks whether the keys in arg_dict are recognized keywords   and prints a warning to STDERR if an unrecognized key is found.  The list of   known keys is read from the julia source file known_keys.jl</p><p>Inputs:     * fname : name of file to read</p><p>Outputs:     arg_dict: a Dict{Any, Any} containing the option keywords and values</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Input.checkForIllegalOptions_post-Tuple{Any}" href="#Input.checkForIllegalOptions_post-Tuple{Any}"><code>Input.checkForIllegalOptions_post</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Check the user supplied options for errors after supplying default options.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Input.checkForIllegalOptions_pre-Tuple{Any}" href="#Input.checkForIllegalOptions_pre-Tuple{Any}"><code>Input.checkForIllegalOptions_pre</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Check the user supplied options for errors before supplying default values</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Input.checkKeys-Tuple{Any,Any}" href="#Input.checkKeys-Tuple{Any,Any}"><code>Input.checkKeys</code></a> — <span class="docstring-category">Method</span>.</div><div><p><strong>PDESolver.checkKeys</strong></p><p>This function verifies all the keys in the first argument are also keys   of the second argument and prints a warning to STDERR if they are not.</p><p>Inputs     arg_dict: first dictonary     known_keys: second dictonary</p><p>Outputs:     cnt: number of unrecognized keys</p></div></section><footer><hr/><a class="previous" href="../solver/simpleODE/simpleODE.html"><span class="direction">Previous</span><span class="title">Main</span></a><a class="next" href="../NonlinearSolvers/nonlinearsolvers.html"><span class="direction">Next</span><span class="title">Introduction</span></a></footer></article></body></html>

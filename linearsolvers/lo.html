<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Operators · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="linearsolvers.html">Introduction</a></li><li><a class="toctext" href="pc.html">Preconditioners</a></li><li class="current"><a class="toctext" href="lo.html">Linear Operators</a><ul class="internal"><li><a class="toctext" href="#Type-Hierarchy-1">Type Hierarchy</a></li><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Concrete-LO-Types-1">Concrete LO Types</a></li><li><a class="toctext" href="#Implementing-a-New-Linear-Operator-1">Implementing a New Linear Operator</a></li></ul></li><li><a class="toctext" href="ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>LinearSolvers</li><li><a href="lo.html">Linear Operators</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/fec676ef2f392fbd60a91ce35662247f0f295951/docs/src/linearsolvers/lo.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="sec:linearoperators-1" href="#sec:linearoperators-1">Linear Operators</a></h1><p>This section describes the different catagories of linear operators, including the API and the requirements for defining new linear operators. Note that whenever a linear solver is used, the <a href="ls.html#sec:linearsolvers-1">Linear Solver</a> interface should be used rather than the Linear Operator interface described here.</p><h2><a class="nav-anchor" id="Type-Hierarchy-1" href="#Type-Hierarchy-1">Type Hierarchy</a></h2><p>When creating a new linear operator, it is very important to make it inherit from the proper abstract type.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractLO" href="#LinearSolvers.AbstractLO"><code>LinearSolvers.AbstractLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract supertype of all linear operators used for A when solving Ax = b.</p><p>The purpose of this type is to provide a consistent interface for different   types of linear operators.  This type really combines two notions: what the   type of the linear operator is, and how it should be solved.</p><p>Any implementation of this type should subtype the appropriate catagory   of: <a href="lo.html#LinearSolvers.AbstractDenseLO"><code>AbstractDenseLO</code></a>, <a href="lo.html#LinearSolvers.AbstractSparseDirectLO"><code>AbstractSparseDirectLO</code></a>,   <a href="lo.html#LinearSolvers.AbstractPetscMatLO"><code>AbstractPetscMatLO</code></a>, <a href="lo.html#LinearSolvers.AbstractPetscMatFreeLO"><code>AbstractPetscMatFreeLO</code></a></p><p>Note that matrix-explicit implementations can often write a single function   for all these cases if using an matrix interface functions that are defined   for all the matrix types.  See <a href="lo.html#LinearSolvers.MatExplicitLO"><code>MatExplicitLO</code></a></p><p><strong>Required Fields</strong></p><ul><li>lo_inner: another <code>AbstractPC</code>.  Can be one of <a href="lo.html#LinearSolvers.DenseLO"><code>DenseLO</code></a>,                <a href="lo.html#LinearSolvers.SparseDirectLO"><code>SparseDirectLO</code></a>, <a href="lo.html#LinearSolvers.PetscMatLO"><code>PetscMatLO</code></a>, or                <a href="lo.html#LinearSolvers.PetscMatFreeLO"><code>PetscMatFreeLO</code></a>, or any other user defined linear                operator.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractDenseLO" href="#LinearSolvers.AbstractDenseLO"><code>LinearSolvers.AbstractDenseLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Linear operator type for Dense matrices.  This is generally used only for   debugging.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractSparseDirectLO" href="#LinearSolvers.AbstractSparseDirectLO"><code>LinearSolvers.AbstractSparseDirectLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Linear operator type for <code>SparseMatrixCSC</code> matrices, which use a direct   solver.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractPetscMatLO" href="#LinearSolvers.AbstractPetscMatLO"><code>LinearSolvers.AbstractPetscMatLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Linear operator type for Petsc matrix-explicit.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractPetscMatFreeLO" href="#LinearSolvers.AbstractPetscMatFreeLO"><code>LinearSolvers.AbstractPetscMatFreeLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Linear operator type for Petsc matrix-free.</p></div></section><p>Several typealiases are also available:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.MatExplicitLO" href="#LinearSolvers.MatExplicitLO"><code>LinearSolvers.MatExplicitLO</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Useful union for all the matrix-explicit linear operator types.   Because matrices have a small set of common interface functions, it is   often possible to write a single function that works on all the different   types of matrices.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscLO" href="#LinearSolvers.PetscLO"><code>LinearSolvers.PetscLO</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Union of Petsc linear operator types</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.DirectLO" href="#LinearSolvers.DirectLO"><code>LinearSolvers.DirectLO</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Union of linear operators that do direct solves</p></div></section><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><p>Every linear operator supports the following functions.  When defining a new linear operator, some of the functions must be extended with new methods, while others will be created automatically based on the supertype of the linear operator.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.calcLinearOperator" href="#LinearSolvers.calcLinearOperator"><code>LinearSolvers.calcLinearOperator</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function calculates the linear operator.  Every implementation of   <a href="lo.html#LinearSolvers.AbstractLO"><code>AbstractLO</code></a> should extend this function with a new   method.  For matrix-free operators, this function must exist but need   not perform any actions.</p><p>For matrix-explicit implementations, this function should be called on   <code>lo_inner</code> first and modifications to the Jacobian made subsequently.</p><p><strong>Inputs</strong></p><ul><li>lo: the AbstractLO implementation (fields may be updated)</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>ctx_residual: the ctx required by <a href="@ref"><code>physicsRhs</code></a></li><li>t: current time</li></ul><p>Implementation Notes:     For matrix-free operation, this function sets the Petsc ctx for the     PetscMat, which contains a reference to the mesh, sbp, eqn, opts arguments.     This could lead to unexpected behavior if those arguments are modified and     this function is not called again before the next solve.</p></div><div><p>Calculates the linear operator.  Use this function only if you want to   calculate the linear operator and not the preconditioner.   Prefer <a href="ls.html#LinearSolvers.calcPCandLO-Tuple{LinearSolvers.StandardLinearSolver{T1,T2},ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V},Any,Any}"><code>calcPCandLO</code></a>, which avoids calculating the matrix twice if   the preconditioner and linear operator share the same matrix</p><p><strong>Inputs</strong></p><ul><li>ls: StandardLinearSolver</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>ctx_residual: the ctx required by <a href="@ref"><code>physicsRhs</code></a> like functions</li><li>t: current time</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>start_comm: start parallel communication (if required by the lo), default                   false.  This means the user is generally required to make sure                   parallel communication is started before calling this                   function.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.applyLinearOperator" href="#LinearSolvers.applyLinearOperator"><code>LinearSolvers.applyLinearOperator</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Applies the linear operator, ie. , Ax = b</p><p>Matrix-explicit implementations <a href="lo.html#LinearSolvers.AbstractLO"><code>AbstractLO</code></a> do not have   to implement this function, though matrix-free implementations must extend   it with a new method.</p><p><strong>Inputs</strong></p><ul><li>lo: the <a href="lo.html#LinearSolvers.AbstractLO"><code>AbstractLO</code></a> implementation.</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>ctx_residual: the ctx for <a href="@ref"><code>physicsRhs</code></a> or the another right hand                    side function built on top of it</li><li>t: current time</li><li>x: an AbstractVector (although never a PetscVec)</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>b: vector updated with results (do not overwrite)</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.applyLinearOperatorTranspose" href="#LinearSolvers.applyLinearOperatorTranspose"><code>LinearSolvers.applyLinearOperatorTranspose</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Applies the transpose of the linear operator, ie. A.&#39;*x = b   Similar to <a href="lo.html#LinearSolvers.applyLinearOperator"><code>applyLinearOperator</code></a>, see that function for details.</p><p>Note that not every method supports this.  In particular, Petsc   matrix-free LinearOperators don&#39;t currently expose this    (although they could with enough reverse-mode)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.getBaseLO" href="#LinearSolvers.getBaseLO"><code>LinearSolvers.getBaseLO</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Similar to <a href="pc.html#LinearSolvers.getBasePC"><code>getBasePC</code></a> except it gets the underlying linear operator,   ie. one of <a href="lo.html#LinearSolvers.DenseLO"><code>DenseLO</code></a>, <a href="lo.html#LinearSolvers.SparseDirectLO"><code>SparseDirectLO</code></a>, <a href="lo.html#LinearSolvers.PetscMatLO"><code>PetscMatLO</code></a>   or <a href="lo.html#LinearSolvers.PetscMatFreeLO"><code>PetscMatFreeLO</code></a>.</p><p>For matrix-explicit methods, this is a good way of getting the underlying   linear operator object, which contains the matrix in the <code>A</code> field (for   all matrix-explicit linear operators).</p><p><strong>Inputs</strong></p><ul><li>lo: an AbstractLO</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.getBaseObject" href="#LinearSolvers.getBaseObject"><code>LinearSolvers.getBaseObject</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function calls either <a href="pc.html#LinearSolvers.getBasePC"><code>getBasePC</code></a> or <a href="lo.html#LinearSolvers.getBaseLO"><code>getBaseLO</code></a>   depending on the type of its argument.</p><p><strong>Inputs</strong></p><ul><li>lo: either an <code>AbstractLO</code> or <code>AbstractPC</code> object</li></ul><p><strong>Outputs</strong></p><ul><li>the base PC or LO object</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.free-Tuple{LinearSolvers.AbstractLO}" href="#Utils.free-Tuple{LinearSolvers.AbstractLO}"><code>Utils.free</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function frees any memory belonging to external libraries.  Users must   call this function when they are finished with an AbstractLO   object.</p><p>Users do not have to define this function for their   <a href="lo.html#LinearSolvers.AbstractLO"><code>AbstractLO</code></a> types.</p><p><strong>Inputs</strong></p><ul><li>lo: the AbstractLO object</li></ul></div></section><h2><a class="nav-anchor" id="Concrete-LO-Types-1" href="#Concrete-LO-Types-1">Concrete LO Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.DenseLO" href="#LinearSolvers.DenseLO"><code>LinearSolvers.DenseLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Dense array linear operator.  Serial only.</p><p><strong>Public Fields</strong></p><ul><li>A: an Array{Float64, 1}</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.DenseLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}" href="#LinearSolvers.DenseLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}"><code>LinearSolvers.DenseLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for DenseLO</p><p><strong>Inputs</strong></p><ul><li>pc: a PCNone</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.SparseDirectLO" href="#LinearSolvers.SparseDirectLO"><code>LinearSolvers.SparseDirectLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>LinearOperator type to be used with sparse direct solve.  Note that the   sparsity pattern of the matrix A must be constant.</p><p><strong>Fields</strong></p><ul><li>A: the matrix</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.SparseDirectLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}" href="#LinearSolvers.SparseDirectLO-Tuple{LinearSolvers.PCNone,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}"><code>LinearSolvers.SparseDirectLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for SparseDirectLO</p><p><strong>Inputs</strong></p><ul><li>pc: a PCNone</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatLO" href="#LinearSolvers.PetscMatLO"><code>LinearSolvers.PetscMatLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Petsc matrix-explicit linear operator.</p><p>Note that if an interface common to both Petsc and regular matrices is used   when accessing the <code>Ap</code> field, it is possible to write functions that   operate on both regular and Petsc linear operators.</p><p><strong>Public Fields</strong></p><ul><li>A: a PetscMat</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatLO-Tuple{LinearSolvers.PetscMatPC,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}" href="#LinearSolvers.PetscMatLO-Tuple{LinearSolvers.PetscMatPC,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}"><code>LinearSolvers.PetscMatLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for PetscMatLO</p><p><strong>Inputs</strong></p><ul><li>pc: a Petsc preconditioner of some kind</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatFreeLO" href="#LinearSolvers.PetscMatFreeLO"><code>LinearSolvers.PetscMatFreeLO</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Petsc matrix-free linear operator.</p><p><strong>Public Fields</strong></p><ul><li>none</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatFreeLO-Tuple{LinearSolvers.PetscMatPC,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}" href="#LinearSolvers.PetscMatFreeLO-Tuple{LinearSolvers.PetscMatPC,ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},ODLCommonTools.AbstractSolutionData{Tsol,Tres},Dict{K,V}}"><code>LinearSolvers.PetscMatFreeLO</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for PetscMatFreeLO</p><p><strong>Inputs</strong></p><ul><li>pc: a Petsc preconditioner of some kind</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li></ul></div></section><p><code>PetscMatFreePC</code> has an additional function not needed by other linear operator types:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.setLOCtx" href="#LinearSolvers.setLOCtx"><code>LinearSolvers.setLOCtx</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function sets the ctx for the underlying Petsc matrix object.  The   end result is that the mesh, sbp, eqn, and opts that are passed into this   function will be passed to the user-defined <a href="lo.html#LinearSolvers.applyLinearOperator"><code>applyLinearOperator</code></a>   during the next linear solve.  See that function for a description of   the arguments.</p><p><strong>Inputs</strong></p><ul><li>lo: the user defined linear operator</li><li>mesh</li><li>sbp</li><li>eqn</li><li>opts</li><li>ctx_residual</li><li>t</li></ul></div></section><h2><a class="nav-anchor" id="Implementing-a-New-Linear-Operator-1" href="#Implementing-a-New-Linear-Operator-1">Implementing a New Linear Operator</a></h2><p>Many of the API functions are automatically generated for matrix-explicit linear operators.  Matrix-free linear operators need to define most of the LO interface themselves.  A summary of the functions each preconditioner must implement is:</p><p><strong>Matrix-explicit</strong></p><ul><li><a href="lo.html#LinearSolvers.calcLinearOperator"><code>calcLinearOperator</code></a>   <strong>Matrix-free</strong></li></ul><ul><li><a href="lo.html#LinearSolvers.calcLinearOperator"><code>calcLinearOperator</code></a></li><li><a href="lo.html#LinearSolvers.applyLinearOperator"><code>applyLinearOperator</code></a></li><li><a href="lo.html#LinearSolvers.applyLinearOperatorTranspose"><code>applyLinearOperatorTranspose</code></a></li></ul><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Linear operators use the same composition structure as preconditioners, see the <a href="pc.html#Implementing-a-New-Preconditioner-1">Implementing a New Preconditioner</a> section before proceeding.</p><pre><code class="language-none"># Assume the ExamplePetscMatLO type has already been defined

type OuterPetscMatLO &lt;: AbstractPetscMatPC
  lo_inner::ExamplePetscMatLO
end


function OuterPetscMatPC(pc::OuterPetscMatLO, mesh::AbstractMesh,
                         sbp::AbstractSBP, eqn::AbstractSolutionData, opts::Dict)

  lo_inner = ExamplePetscMatLO(pc, mesh, sbp, eqn, opts)
  return OuterPetscMatPC(lo_inner)
end

function calcLinearOperator(lo::OuterPetscMatLO, mesh::AbstractMesh,
                            sbp::AbstractSBP, eqn::AbstractSolutionData,
                            opts::Dict, ctx_residual, t)

  # have inner LO do its computation
  calcLinearOperator(lo.lo_inner, mesh, sbp, eqn, opts, ctx_residual, t)

  lo2 = getBaseLO(lo)
  # use set_values1!(lo2.A, ...) to modify the matrix A

  return nothing
end</code></pre><p><a href="lo.html#LinearSolvers.applyLinearOperator"><code>applyLinearOperator</code></a> and <a href="lo.html#LinearSolvers.applyLinearOperatorTranspose"><code>applyLinearOperatorTranspose</code></a> are defined automatically for all <a href="lo.html#LinearSolvers.AbstractPetscMatLO"><code>AbstractPetscMatLO</code></a> types (using <a href="lo.html#LinearSolvers.getBaseLO"><code>getBaseLO</code></a>).</p><footer><hr/><a class="previous" href="pc.html"><span class="direction">Previous</span><span class="title">Preconditioners</span></a><a class="next" href="ls.html"><span class="direction">Next</span><span class="title">Linear Solvers</span></a></footer></article></body></html>

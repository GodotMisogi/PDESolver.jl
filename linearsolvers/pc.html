<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Preconditioners · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="linearsolvers.html">Introduction</a></li><li class="current"><a class="toctext" href="pc.html">Preconditioners</a><ul class="internal"><li><a class="toctext" href="#Type-hierarchy-1">Type hierarchy</a></li><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Concrete-PC-Types-1">Concrete PC Types</a></li><li><a class="toctext" href="#Implementing-a-New-Preconditioner-1">Implementing a New Preconditioner</a></li></ul></li><li><a class="toctext" href="lo.html">Linear Operators</a></li><li><a class="toctext" href="ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="../Utils/Utils.html">Main</a></li><li><a class="toctext" href="../Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="../Utils/projections.html">Projections</a></li><li><a class="toctext" href="../Utils/logging.html">Logging</a></li><li><a class="toctext" href="../Utils/io.html">Input/Output</a></li><li><a class="toctext" href="../Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="../Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>LinearSolvers</li><li><a href="pc.html">Preconditioners</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/linearsolvers/pc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Preconditioners</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="sec:preconditioners-1" href="#sec:preconditioners-1">Preconditioners</a></h1><p>This section describes the different catagories of preconditioners, including the API and the requirements for creating new preconditioners. Note that whenever a linear solver is used, the <a href="ls.html#sec:linearsolvers-1">Linear Solver</a> interface should be used rather than the Linear Operator interface described here.</p><h2><a class="nav-anchor" id="Type-hierarchy-1" href="#Type-hierarchy-1">Type hierarchy</a></h2><p>When creating a new preconditioner, it is very important to make it inherit from the proper supertype.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractPC" href="#LinearSolvers.AbstractPC"><code>LinearSolvers.AbstractPC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract supertype of all preconditioner types.  Preconditioners can be used   with iterative methods only.  When using a direct method, <a href="pc.html#LinearSolvers.PCNone"><code>PCNone</code></a>   should be used.</p><p>The purpose of this type is to provide a consistent interface for different   types of preconditioners.  In particular, it provides control over when the   preconditioner is recomputed.</p><p>Users should implement new preconditioners using composition with   one of the preconditioners defined here, namely <a href="pc.html#LinearSolvers.PetscMatPC"><code>PetscMatPC</code></a> or   <a href="pc.html#LinearSolvers.PetscMatFreePC"><code>PetscMatFreePC</code></a>, ie. they should define a new subtype of   <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> that has either <code>PetscMatPC</code> or <code>PetscMatFrePC</code> as   a field.  This allows calling the existing functions for these types   (which compute a preconditioner for the Jacobian of the physics) and   modifying the preconditioner as needed.   User defined preconditioners should subtype either <a href="pc.html#LinearSolvers.AbstractPetscMatPC"><code>AbstractPetscMatPC</code></a>   of <a href="pc.html#LinearSolvers.AbstractPetscMatFreePC"><code>AbstractPetscMatFreePC</code></a>.</p><p><strong>Fields</strong></p><ul><li><p>pc_inner: another <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a></p></li></ul><p>Note that arbitrarily deep nesting of preconditioners is allowed.   The <code>pc_inner</code> field can be one of <a href="pc.html#LinearSolvers.PCNone"><code>PCNone</code></a>, <a href="pc.html#LinearSolvers.PetscMatPC"><code>PetscMatPC</code></a>,   or <a href="pc.html#LinearSolvers.PetscMatFreePC"><code>PetscMatFreePC</code></a> for a non-nested preconditioner, or some   other <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> for a nested preconditioner.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L156-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractPetscMatPC" href="#LinearSolvers.AbstractPetscMatPC"><code>LinearSolvers.AbstractPetscMatPC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract supertype of all Petsc matrix-explicit preconditioners</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L186-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractPetscMatFreePC" href="#LinearSolvers.AbstractPetscMatFreePC"><code>LinearSolvers.AbstractPetscMatFreePC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract supertype of all Petsc matrix-free preconditioners.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L191-L193">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.AbstractPetscPC" href="#LinearSolvers.AbstractPetscPC"><code>LinearSolvers.AbstractPetscPC</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Alias for any kind of Petsc PC (matrix-explicit or matrix-free)</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L196-L198">source</a></section><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><p>Every preconditioner supports the following functions.  When defining a new preconditioner, some of the functions must be defined for the new  <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> type, while others are defined automatically based on the supertype of the preconditioner.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.calcPC-Tuple{LinearSolvers.AbstractPC,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}" href="#LinearSolvers.calcPC-Tuple{LinearSolvers.AbstractPC,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}"><code>LinearSolvers.calcPC</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function calculates the preconditioner.  Every implementation of   <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> should extend this function with a new method</p><p>When creating new preconditioners, this function should generally be called   first on pc_inner, and modifications to the Jacobian should be made    subsequently.</p><p><strong>Inputs</strong></p><ul><li><p>pc: the AbstractPC implementation</p></li><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>ctx_residual: the ctx required by <a href="linearsolvers/@ref"><code>physicsRhs</code></a></p></li><li><p>t: current time</p></li></ul><p>Implementation Notes:     For matrix-explicit preconditioners, this might not actually calculate the     preconditioner.  Rather, it calculates the matrix the preconditioner is     based on, and the solve function calcultes the preconditioner from it.     Nevertheless, it supports the proper semantics for when the PC is updated     even when the PC matrix and LinearOperator matrix are the same (as long as     the solve function is called regularly).</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L202-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.applyPC-Tuple{LinearSolvers.AbstractPC,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#LinearSolvers.applyPC-Tuple{LinearSolvers.AbstractPC,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>LinearSolvers.applyPC</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Applies the preconditioner, ie. x = inv(Ap)*b, where Ap is the approximation   to the matrix A.  Note that Ap itself may not be available for some   preconditioners, hence there is only an API for applying inv(Ap),   not Ap itself.</p><pre><code class="language-none">Matrix-free preconditioners need to extend this function with a new method,
matrix-explicit preconditioners do not.</code></pre><p><strong>Inputs</strong></p><ul><li><p>pc: the <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> implementation.</p></li><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn: this argument should generally not be used because all the solution      related data should be stored in the pc object by <a href="ls.html#LinearSolvers.calcPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}"><code>calcPC</code></a></p></li><li><p>opts</p></li><li><p>t: current time</p></li><li><p>b: a AbstractVector representing the local part of the solution (ie    eqn.q_vec)</p></li></ul><p><strong>Inputs/Outputs</strong></p><ul><li><p>x: AbstractVector updated with results (same size as b) (do not overwrite)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L234-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.applyPCTranspose-Tuple{LinearSolvers.AbstractPC,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#LinearSolvers.applyPCTranspose-Tuple{LinearSolvers.AbstractPC,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>LinearSolvers.applyPCTranspose</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Applies the transpose of the preconditioner, ie. x = inv(Ap).&#39;*b.   Similar to <a href="ls.html#LinearSolvers.applyPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>applyPC</code></a>, see that function for details.</p><p>Note that not every preconditioning method supports this.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L268-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.getBasePC" href="#LinearSolvers.getBasePC"><code>LinearSolvers.getBasePC</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the underlying preconditioner object, ie.   <a href="pc.html#LinearSolvers.PCNone"><code>PCNone</code></a>, <a href="pc.html#LinearSolvers.PetscMatPC"><code>PetscMatPC</code></a>, or <a href="pc.html#LinearSolvers.PetscMatFreePC"><code>PetscMatFreePC</code></a>.</p><p>Note that arbitrarily deep nesting of preconditioners is allowed.   Users do not have to implement as long as the nested preconditioner is   stored in a field called <code>pc_inner</code>.</p><p>For matrix-explicit preconditioners, this function is useful for getting   the <a href="pc.html#LinearSolvers.PetscMatPC"><code>PetscMatPC</code></a> object, which contains the preconditioning   Jacobian matrix.</p><p><strong>Inputs</strong></p><ul><li><p>pc: the users <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L283-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.free-Tuple{LinearSolvers.AbstractPC}" href="#Utils.free-Tuple{LinearSolvers.AbstractPC}"><code>Utils.free</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function frees any memory belonging to external libraries.  Users must   call this function when they are finished with an AbstractPC   object.</p><p>Users do not have to define this function for their   <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> types.</p><p><strong>Inputs</strong></p><ul><li><p>pc: the AbstractPC object</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/LinearSolvers.jl#L360-L371">source</a></section><h2><a class="nav-anchor" id="Concrete-PC-Types-1" href="#Concrete-PC-Types-1">Concrete PC Types</a></h2><p>The following types are the &quot;Base&quot; PC types refered to by <a href="pc.html#LinearSolvers.getBasePC"><code>getBasePC</code></a>. Every preconditioner must contain one of these (either directly, in the <code>pc_inner</code> field described by <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a>, of inside another preconditioner).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PCNone" href="#LinearSolvers.PCNone"><code>LinearSolvers.PCNone</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Preconditioner type for direct solve.   Do not use with PetscLinearOperator.</p><p><strong>Public Fields</strong></p><ul><li><p>none</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_none.jl#L3-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PCNone-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#LinearSolvers.PCNone-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>LinearSolvers.PCNone</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor</p><p><strong>Inputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_none.jl#L15-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatPC" href="#LinearSolvers.PetscMatPC"><code>LinearSolvers.PetscMatPC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> implementation for Petsc matrix-explicit preconditioners.</p><p><strong>Public Fields</strong></p><ul><li><p>A: a PetscMat object used to calculate the preconditioner</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_petscmat.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatPC-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#LinearSolvers.PetscMatPC-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>LinearSolvers.PetscMatPC</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor</p><p><strong>Inputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_petscmat.jl#L31-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatFreePC" href="#LinearSolvers.PetscMatFreePC"><code>LinearSolvers.PetscMatFreePC</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Type for managing a Petsc matrix-free preconditioner.  Actual preconditioners   can be built on top of this.  Because matrix-free preconditioners do not have   a particular form, this type requires the preconditioner to implement the   entire <a href="pc.html#LinearSolvers.AbstractPC"><code>AbstractPC</code></a> interface.  The benefit of using this type to   build a preconditioner is that is automatically exposes the preconditioner   to Petsc.</p><p>The <a href="ls.html#LinearSolvers.calcPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}"><code>calcPC</code></a> function the user defines must call <a href="pc.html#LinearSolvers.setPCCtx"><code>setPCCtx</code></a>.</p><p><strong>Public Fields</strong></p><ul><li><p>none</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_petscmatfree.jl#L3-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.PetscMatFreePC-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}" href="#LinearSolvers.PetscMatFreePC-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict}"><code>LinearSolvers.PetscMatFreePC</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor</p><p><strong>Inputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_petscmatfree.jl#L33-L42">source</a></section><p>PetscMatFreePC has an additional function not needed by other preconditioner types:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearSolvers.setPCCtx" href="#LinearSolvers.setPCCtx"><code>LinearSolvers.setPCCtx</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function should be called by the users <a href="ls.html#LinearSolvers.calcPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}"><code>calcPC</code></a> function.   The arguments passed to this function are passed to <a href="ls.html#LinearSolvers.applyPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>applyPC</code></a>   during the next preconditioner application.   See that function for a description of the arguments</p><p><strong>Inputs</strong></p><ul><li><p>pc:</p></li><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>ctx_residual</p></li><li><p>t</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/c57a3693f745bb619295b20a96ac7b6bc158a2bc/src/linearsolvers/pc_petscmatfree.jl#L93-L108">source</a></section><h2><a class="nav-anchor" id="Implementing-a-New-Preconditioner-1" href="#Implementing-a-New-Preconditioner-1">Implementing a New Preconditioner</a></h2><p>Many of the API functions are automatically generated for matrix-explicit preconditioners.  Matrix-free preconditioners need to define most of the PC interface themselves.  A summary of the functions each preconditioner must implements is:</p><p><strong>Matrix-explicit</strong></p><ul><li><p><a href="ls.html#LinearSolvers.calcPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}"><code>calcPC</code></a></p></li></ul><p><strong>Matrix-free</strong></p><ul><li><p><a href="ls.html#LinearSolvers.calcPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,Any}"><code>calcPC</code></a></p></li><li><p><a href="ls.html#LinearSolvers.applyPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>applyPC</code></a></p></li><li><p><a href="ls.html#LinearSolvers.applyPCTranspose-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>applyPCTranspose</code></a></p></li></ul><h3><a class="nav-anchor" id="First-Level-PC-1" href="#First-Level-PC-1">First Level PC</a></h3><p>This example shows how to implement a new preconditioner that directly   contains one of the <a href="pc.html#Concrete-PC-Types-1">Concrete PC Types</a> described above.</p><pre><code class="language-none">type ExamplePetscMatPC &lt;: AbstractPetscMatPC
  pc_inner::PetscMatPC  # the supertype of pc_inner and ExamplePetscMatPC
                        # must match
end

function ExamplePetscMatPC(mesh::AbstractMesh, sbp::AbstractSBP,
                    eqn::AbstractSolutionData, opts::Dict)

  pc_inner = PetscMatPC(mesh, sbp, eqn, opts)

  return ExamplePetscMatPC(pc_inner)
end


function calcPC(pc::ExamplePetscMatPC, mesh::AbstractMesh, sbp::AbstractSBP,
                eqn::AbstractSolutionData, opts::Dict, ctx_residual, t)


  calcPC(pc.pc_inner)

  pc2 = getBasePC(pc)  # because pc_inner is the base pc, this returns
                       # pc.pc_inner
  # call set_values1!(pc2.Ap, ...) to put values into the preconditioning matrix

  return nothing
end</code></pre><p>Because <code>calcPC</code> is defined and the base PC is one of the concrete PC types, namely <a href="pc.html#LinearSolvers.PetscMatPC"><code>PetscMatPC</code></a>, the functions <a href="ls.html#LinearSolvers.applyPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>applyPC</code></a> and <a href="ls.html#LinearSolvers.applyPC-Tuple{LinearSolvers.StandardLinearSolver,ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,Any,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>applyPC</code></a> are automatically defined for <code>ExamplePetscMatPC</code>. The new preconditioner is now fully usable.</p><h3><a class="nav-anchor" id="Multiple-Levels-of-Composition-1" href="#Multiple-Levels-of-Composition-1">Multiple Levels of Composition</a></h3><p>The same structure as shown in the previous structure can be used to build a new preconditioner out of any existing preconditioner, not only the <a href="pc.html#Concrete-PC-Types-1">Concrete PC Types</a>.</p><pre><code class="language-none">type OuterPetscMatPC &lt;: AbstractPetscMatPC
  pc_inner::ExamplePetscMatPC  # use the PC define in the previous example
end

function OuterPetscMatPC(mesh::AbstractMesh, sbp::AbstractSBP,
                         eqn::AbstractSolutionData, opts::Dict)

  pc_inner = ExamplePetscMatPC(mesh, sbp, eqn, opts)

  return OuterPetscMatPC(pc_inner)
end


function calcPC(pc::OuterPetscMatPC, mesh::AbstractMesh, sbp::AbstractSBP,
                eqn::AbstractSolutionData, opts::Dict, ctx_residual, t)


  calcPC(pc.pc_inner)  # always call the inner PC calc function first

  pc2 = getBasePC(pc)  # in this case, pc2 is the PetscMatPC inside 
                       # the ExamplePetscMatPC
  # call set_values1!(pc2.Ap, ...) to put values into the preconditioning matrix  # because calcPC(pc.pc_inner) was called already, the values here should
  # be added to those already in pc2.Ap

  return nothing
end</code></pre><p>As before, this preconditioner is now fully usable.</p><h3><a class="nav-anchor" id="Matrix-Free-1" href="#Matrix-Free-1">Matrix Free</a></h3><p>An outline of how a matrix free preconditioner should be implemented is:</p><pre><code class="language-none">type ExamplePetscMatFreePC &lt;: AbstractPetscMatFreePC
  pc_inner::PetscMatFreePC
  # other fields...
end

function ExamplePetscMatFreePC(mesh::AbstractMesh, sbp::AbstractSBP,
                         eqn::AbstractSolutionData, opts::Dict)

  pc_inner = PetscMatFreePC(mesh, sbp, eqn, opts)

  return ExamplePetscMatFreePC(pc_inner)
end

function calcPC(pc::ExamplePetscMatFreePC, mesh::AbstractMesh, sbp::AbstractSBP,
                eqn::AbstractSolutionData, opts::Dict, ctx_residual, t)

  # do any setup operations, storing data into the &quot;other fields...&quot; of the pc

  # these arguments will be passed into applyPC() the next time it is called
  # by Petsc
  # always do this last
  setPCCtx(pc, mesh, sbp, eqn, opts, ctx_residual, t)

  return nothing
end

function applyPC(pc::PetscMatFreePC, mesh::AbstractMesh, sbp::AbstractSBP,
                 eqn::AbstractSolutionData, opts::Dict, t, b::AbstractVector, 
                 x::AbstractVector)

  # use the data in pc to multiply the preconditioner by b, storing result in x

  return nothing
end

function applyPCTranspose(pc::PetscMatFreePC, mesh::AbstractMesh,
                 sbp::AbstractSBP,
                 eqn::AbstractSolutionData, opts::Dict, t, b::AbstractVector, 
                 x::AbstractVector)

  # use the data in pc to multiply the transpose of the preconditioner by b,
  # storing result in x

  return nothing
end</code></pre><p>Matrix-free preconditioners support the same kind of composition as matrix explicit preconditioners, so it is recommended to add the result into <code>x</code>, rather than overwrite <code>x</code> when <code>pc_inner</code> is not one of the <a href="pc.html#Concrete-PC-Types-1">Concrete PC Types</a>.</p><footer><hr/><a class="previous" href="linearsolvers.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="lo.html"><span class="direction">Next</span><span class="title">Linear Operators</span></a></footer></article></body></html>

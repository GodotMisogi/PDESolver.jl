<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PDESolver Physics Interface · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDESolver.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="concepts/intro.html">Intro</a></li><li><a class="toctext" href="concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="build.html">Building PDESolver</a></li><li><a class="toctext" href="deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="pdesolver.html">Introduction</a></li><li><a class="toctext" href="pdesolver_user.html">PDESolver User Interface</a></li><li class="current"><a class="toctext" href="pdesolver_physics.html">PDESolver Physics Interface</a><ul class="internal"><li><a class="toctext" href="#Functions-to-be-Extended-1">Functions to be Extended</a></li><li><a class="toctext" href="#Additional-Functions-1">Additional Functions</a></li><li><a class="toctext" href="#Registration-Functions-1">Registration Functions</a></li></ul></li><li><a class="toctext" href="pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="input/input.html">Introduction</a></li><li><a class="toctext" href="input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="Utils/Utils.html">Main</a></li><li><a class="toctext" href="Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="Utils/projections.html">Projections</a></li><li><a class="toctext" href="Utils/logging.html">Logging</a></li><li><a class="toctext" href="Utils/io.html">Input/Output</a></li><li><a class="toctext" href="Utils/checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="Utils/misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="test/Testing.html">Introduction</a></li><li><a class="toctext" href="test/Readme.html">Local Testing</a></li><li><a class="toctext" href="test/Travis.html">CI Testing</a></li><li><a class="toctext" href="test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Frontend</li><li><a href="pdesolver_physics.html">PDESolver Physics Interface</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/master/docs/src/pdesolver_physics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PDESolver Physics Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Documentation-of-the-PDESolver-Physics-Module-Interface-1" href="#Documentation-of-the-PDESolver-Physics-Module-Interface-1">Documentation of the PDESolver Physics Module Interface</a></h1><p>The <code>PDESolver</code> Module provides some structure for physics modules to plug into. See <a href="interfaces.html#Interfaces-in-PDESolver-1">Interfaces in PDESolver</a> for details. Each physics module should create a new subtype of <code>AbstractSolutionData</code>. This physics module should then extend the required methods, specializing one of the arguments with the new (physics-specific) type. This structure allows the API for the physics module to be visible to other parts of the code (such as <code>NonlinearSolvers</code>), while being defined  within the physics module.</p><p>One exception to this pattern of defining generic functions and then specializing one argument is the initialization functions. These functions run before the <code>AbstractSolutionData</code> object is created, so they can not dispatch to different methods. Instead, each physics module has to register itself and provide the required initialization functions. See the <a href="pdesolver_physics.html#Registration-Functions-1">Registration Functions</a> section.</p><h2><a class="nav-anchor" id="Functions-to-be-Extended-1" href="#Functions-to-be-Extended-1">Functions to be Extended</a></h2><p>All the functions in this section should be extended by each physics module with a new method, specializing the type of the <code>eqn</code> argument.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createFunctional-Union{Tuple{I}, Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Any,AbstractString,Array{I,1}}} where I&lt;:Integer" href="#PDESolver.createFunctional-Union{Tuple{I}, Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Any,AbstractString,Array{I,1}}} where I&lt;:Integer"><code>PDESolver.createFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Creates a functional object.</p><p>Each physics modules should extend this function with a new method,   specializing the <code>eqn</code> argument.</p><p><strong>Inputs</strong></p><ul><li><p><code>mesh</code> : Abstract PUMI mesh</p></li><li><p><code>sbp</code>  : Summation-by-parts operator</p></li><li><p><code>eqn</code>  : AbstractSolutionData object</p></li><li><p><code>opts</code> : Options dictionary</p></li><li><p><code>functional_name</code>: the name of the functional</p></li><li><p><code>functional_bcs</code>: the boundary condition numbers the functional is                   computed on.</p></li></ul><p><strong>Outputs</strong></p><ul><li><p>functional: an <a href="solver/misc.html#ODLCommonTools.AbstractFunctional"><code>AbstractFunctional</code></a>.  Usually an             <a href="solver/misc.html#ODLCommonTools.AbstractIntegralFunctional"><code>AbstractIntegralFunctional</code></a>, although this is not             required.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L159-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalFunctional-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData{Tsol,Tres} where Tres,Any,ODLCommonTools.AbstractFunctional}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#PDESolver.evalFunctional-Union{Tuple{ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData{Tsol,Tres} where Tres,Any,ODLCommonTools.AbstractFunctional}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>PDESolver.evalFunctional</code></a> — <span class="docstring-category">Method</span>.</div><div><p>High level function that evaluates the given functional   This function is agnostic to the type of the functional being   computed and calls a mid level functional-type specific function for the    actual evaluation.</p><p>The functional is evaluated at the state in eqn.q_vec.</p><p><strong>Arguments</strong></p><ul><li><p><code>mesh</code> :  Abstract mesh object</p></li><li><p><code>sbp</code>  : Summation-By-Parts operator</p></li><li><p><code>eqn</code>  : AbstractSolutionData object</p></li><li><p><code>opts</code> : Options dictionary</p></li><li><p><code>functionalData</code> : Object of type AbstractFunctional.                      This type determines the functional being computed and                     holds all the relevant data.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L193-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalFunctionalDeriv-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData{Tsol,Tres} where Tres,Any,ODLCommonTools.AbstractIntegralFunctional,AbstractArray{T,3} where T}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh" href="#PDESolver.evalFunctionalDeriv-Union{Tuple{ODLCommonTools.AbstractDGMesh{Tmsh},SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData{Tsol,Tres} where Tres,Any,ODLCommonTools.AbstractIntegralFunctional,AbstractArray{T,3} where T}, Tuple{Tmsh}, Tuple{Tsol}} where Tsol where Tmsh"><code>PDESolver.evalFunctionalDeriv</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Computes a 3D array of hte derivative of a functional wrt eqn.q.</p><p>The derivative is evaluated at the state in eqn.q_vec.</p><p><strong>Inputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li><li><p>functionalData: AbstractIntegralFunctional to evaluate</p></li></ul><p><strong>Inputs/Outputs</strong></p><ul><li><p>func_deriv_arr: array to hold derivative of function wrt eqn.q, same                 size as equation.q</p></li></ul><p><strong>Options Keys</strong></p><p>This funciton is not compatible with <code>precompute_q_bndry</code> = false</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L220-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalHomotopyJacobian-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,PDESolver.AssembleElementData,Number}" href="#PDESolver.evalHomotopyJacobian-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Dict,PDESolver.AssembleElementData,Number}"><code>PDESolver.evalHomotopyJacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Evaluates the Jacobian of the <a href="solver/euler/homotopy.html#PDESolver.evalHomotopy"><code>evalHomotopy</code></a> multiplied by the   homotopy parameter lambda.  Conceptually similar to <a href="pdesolver_physics.html#PDESolver.evalJacobian"><code>evalJacobian</code></a>.</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an AbstractMesh</p></li><li><p>sbp: an AbstractSBP</p></li><li><p>eqn: an AbstractSolutionData (physics modules should specialize this      argument)</p></li><li><p>opts: options dictionary</p></li><li><p>assembler: an object used to assemble contributions into the Jacobian</p></li><li><p>lambda: the homotopy parameter</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L95-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalJacobian" href="#PDESolver.evalJacobian"><code>PDESolver.evalJacobian</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Similar function to <a href="pdesolver_physics.html#PDESolver.evalResidual"><code>evalResidual</code></a>, but instead of computing the   residual, it computes and assembles the Jacobian of the residual with   respect to <code>eqn.q</code> into the system matrix.</p><p>The functions <a href="@ref"><code>assembleElement</code></a> and <a href="@ref"><code>assembleInterface</code></a>   in <code>NonlinearSolvers</code> should be used to assembles the Jacobians of   individual elements and interfaces into the system matrix.</p><p>Physics modules that can compute element Jacobians directly   should extend this function with a new method, otherwise the coloring   algorithm with be used with <a href="pdesolver_physics.html#PDESolver.evalResidual"><code>evalResidual</code></a> to compute the   system matrix.  For physics modules that support multiple formuations,   this function should throw an exception if called with an unsupported   formulation.</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an AbstractMesh</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: AbstractSolutionData (physics modules should specialize this      argument)</p></li><li><p>opts: options dictionary</p></li><li><p>assembler: object that must be passed to <code>assembleElement</code> and             <code>assembleInterface</code></p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p>start_comm: whether or not to start parallel communication,             default false because the functions Nonlinear solvers             have already done parallel communication when this             function gets called.</p></li></ul><p><strong>Options Keys</strong></p><p>TODO: describe the key that controls whether this function gets called         or not.</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L47-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalJacobianStrong" href="#PDESolver.evalJacobianStrong"><code>PDESolver.evalJacobianStrong</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function evaluates the Jacobian of the strong form of the spatial   residual.  Note that the residual is written</p><p>du/dt = -(Q * f) + SAT</p><p>Note the negative sign.</p><p>Currently this function neglects the SAT terms (both interface and boundary   conditions)</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an AbstractMesh</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: AbstractSolutionData (physics modules should specialize this      argument)</p></li><li><p>opts: options dictionary</p></li><li><p>assembler: object that must be passed to <code>assembleElement</code> and             <code>assembleInterface</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L127-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.evalResidual" href="#PDESolver.evalResidual"><code>PDESolver.evalResidual</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function evalutes dq/dt = R(q).  For steady problems it evalutes R(q)   at some state q.  The state is stored in eqn.q, and eqn.res is populated with   R(q).  Note that these are 3 dimensional arrays.  The physics modules only   interact with the 3 dimensional arrays, never the vectors eqn.q_vec and   eqn.res_vec.  Each physics module must implement this function for its   own subtype of AbstractSolutionData (ie. with a more specific type for   the eqn argument and equallty specific types for the other arguments).   This is important because evalResidual is common to all physics modules,   so a user or some other part of the code can call evalResidual(mesh, sbp   eqn, opts), and Julia&#39;s multiple dispatch will figure out the right method   to call based on the type of the eqn argument.</p><p>The evaluation of the residual R(q) should depend only on the data stored in   mesh, sbp, eqn, and opts, and any data that depend on q should be recalculated   every time the function is called.  This function is used as a building block   by other parts of the solver, particularly the NonlinearSolvers.  See   interfaces.md for details</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an AbstractMesh describing the mesh on which to solve the physics</p></li><li><p>sbp: an SBP operator</p></li><li><p>eqn: a subtype of AbstractSolution data, used to store all of the data used by the physics module</p></li><li><p>opts: the options dictionary</p></li><li><p>t: the current time value, defaults to 0.0</p></li></ul><p>#TODO: list required options keys</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L4-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.solvePDE" href="#PDESolver.solvePDE"><code>PDESolver.solvePDE</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function takes fully initialzed objects and solves the partial   differential equation.</p><p>Every physics should extend this function with a new method, specialzing the   <code>eqn</code> argument type.</p><p>Objects can be created with the <a href="pdesolver_physics.html#PDESolver.createObjects-Tuple{AbstractString}"><code>createObjects</code></a> function.</p><p>The functions in the <code>SolverCommon</code> module are helpful in writing   this function.</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an AbstractMesh</p></li><li><p>sbp: an SBP Operator</p></li><li><p>eqn: an AbstractSolutionData</p></li><li><p>opts: the options dictionary</p></li><li><p>pmesh: mesh for preconditioning (optional)</p></li></ul><p><strong>Outputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn: on exit, eqn.q_vec should have the converged solution in it.</p></li><li><p>opts</p></li></ul><p><strong>Options Keys</strong></p><ul><li><p>Relfunc_name: also writes vtk files called &quot;solution_relfunc&quot;              if key not present, ignored               TODO: fix that</p></li><li><p>IC_name</p></li><li><p>calc_error: also write vtk files called &quot;solution_error&quot;</p></li><li><p>calc_trunc_error</p></li><li><p>perturb_ic</p></li><li><p>calc_dt</p></li></ul><pre><code class="language-none">For options like calc_dt and Relfunc_name, it is very important that
the computed quantity be saved to the options dictionary for use later
in the code (ie. and not passed directly to another function).  The
code won&#39;t restart correctly if this happens.</code></pre></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L279-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.updateMetricDependents-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Any}" href="#PDESolver.updateMetricDependents-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,ODLCommonTools.AbstractSolutionData,Any}"><code>PDESolver.updateMetricDependents</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function recalculates all quantities that depend on the mesh metrics.   This function handles changes in the metric <em>values</em> only (not changed in   mesh topology).</p><p>This function should be called after the mesh is warped (ie. using mesh   movement).</p><p>Every physics module should extend this function with a new method   specializing the <code>eqn</code> argument type.</p><p><strong>Inputs</strong></p><ul><li><p>mesh</p></li><li><p>sbp</p></li><li><p>eqn</p></li><li><p>opts</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface.jl#L252-L269">source</a></section><h2><a class="nav-anchor" id="Additional-Functions-1" href="#Additional-Functions-1">Additional Functions</a></h2><p>These functions are available for all physics module, but do not need to be extended with a new method. They usually boil down to calling one of the functions in the previous section.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createFunctional" href="#PDESolver.createFunctional"><code>PDESolver.createFunctional</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Creates a functional object, using the data described in the options   dictionary</p><p><strong>Arguments</strong></p><ul><li><p><code>mesh</code> : Abstract PUMI mesh</p></li><li><p><code>sbp</code>  : Summation-by-parts operator</p></li><li><p><code>eqn</code>  : AbstractSolutionData</p></li><li><p><code>opts</code> : Options dictionary</p></li><li><p><code>functional_number</code> : which functional (of the functionals described                       in the options dictionary) to create</p></li></ul><p><strong>Outputs</strong></p><p>same as other method</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface2.jl#L94-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createObjects-Tuple{AbstractString}" href="#PDESolver.createObjects-Tuple{AbstractString}"><code>PDESolver.createObjects</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function returns the fully initialized objects needed to solve an   equations.</p><p><strong>Inputs</strong></p><ul><li><p>fname: input file name</p></li></ul><p><strong>Outputs</strong></p><ul><li><p>mesh: an AbstractMesh of some kind (depending on input file)</p></li><li><p>sbp: an SBP operator of some kind (depending on input file)</p></li><li><p>eqn: an AbstractSolutionData of some kind (depending on input file)</p></li><li><p>opts: options dictionary</p></li><li><p>pmesh: mesh for computing preconditioning, may be the same object as <code>mesh</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface2.jl#L5-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createObjects-Tuple{Dict}" href="#PDESolver.createObjects-Tuple{Dict}"><code>PDESolver.createObjects</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Method for creating objects from an options dictionary</p><p><strong>Inputs</strong></p><ul><li><p>opts: the options dictionary</p></li></ul><p><strong>Outputs</strong></p><pre><code class="language-none">see other method</code></pre></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface2.jl#L29-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createObjects-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,Dict}" href="#PDESolver.createObjects-Tuple{ODLCommonTools.AbstractMesh,SummationByParts.AbstractSBP,Dict}"><code>PDESolver.createObjects</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This method constructs a new equation object for the given mesh, sbp   and opts.</p><p>This is useful for solving on a submesh.</p><p><strong>Inputs</strong></p><ul><li><p>mesh: an <code>AbstractMesh</code></p></li><li><p>sbp: an <code>AbstractSBP</code></p></li><li><p>opts: options dictionary</p></li></ul><p><strong>Outputs</strong></p><p>same as other method</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface2.jl#L48-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.solvePDE-Tuple{Union{AbstractString, Dict}}" href="#PDESolver.solvePDE-Tuple{Union{AbstractString, Dict}}"><code>PDESolver.solvePDE</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Additional methods for <code>solvePDE</code>, allows solving the PDE starting   with either a file name or options dictionary.</p><p>See the other method for details</p><p><strong>Inputs</strong></p><ul><li><p>opts: either a file name to load an options dictionary from or the       options dictionary itself</p></li></ul><p><strong>Outputs</strong></p><p>same as other method</p></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/interface2.jl#L73-L87">source</a></section><h2><a class="nav-anchor" id="Registration-Functions-1" href="#Registration-Functions-1">Registration Functions</a></h2><p>These function provide the basic API for registering and retrieving physics modules with the <code>PDESolver</code> module.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.register_physics" href="#PDESolver.register_physics"><code>PDESolver.register_physics</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function registered a new physics module with the global list of all   known physics modules.  Every physics module should do this as part of   module initialization.  The name, the module, and the startup function must   be unique (ie. they must not already exist in the list).  This function   throws and exception if they are not.</p><p><strong>Inputs</strong></p><ul><li><p>modname:  an String name for this entry in the list.  It is used            to retrieve the module and startup function in the             retrieve_physics function. Typically the name is capitalized.</p></li><li><p>mod:  the Module itself</p></li><li><p>_createObjects: function that creates the mesh, sbp, eqn, and opts                  objects. Must have a method with signature                  <code>_createObjects(opt::Dict)</code></p><pre><code class="language-none">             If this physics modules supports solving on a submesh,
             this function should also have a method
             `_createObjects(mesh::AbstractMesh, sbp::AbstractSBP, opts::Dict)`
             to create a new equation object.  See [`createObjects`](@ref).</code></pre></li><li><p>_checkOptions: physics-specific function for supplying default options and               checking options.  Note that most of the input option               processing is done in <a href="input/input.html#Input.read_input-Tuple{AbstractString}"><code>read_input</code></a>,               <code>_checkOptions</code> need only do the physics-specific part.               This function must have signature <code>_checkOptions(opts::Dict)</code>.</p></li></ul><p><strong>Outputs</strong></p><pre><code class="language-none">none</code></pre></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/registration.jl#L19-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.retrieve_physics" href="#PDESolver.retrieve_physics"><code>PDESolver.retrieve_physics</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Retrieves the physics module and function registered using <a href="pdesolver_physics.html#PDESolver.register_physics"><code>register_physics</code></a></p><p><strong>Input</strong></p><ul><li><p>modname: an String containing the name of the module supplied to         <code>register_physics</code></p></li></ul><p><strong>Outputs</strong></p><ul><li><p>mod: the physics Module</p></li><li><p>_createObjects: function that creates the solver objects</p></li><li><p>_checkOptions: the options checking function</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/OptimalDesignLab/PDESolver.jl/blob/8be796fb3ce1688e648ef2c40968143d17f40fc9/src/registration.jl#L91-L104">source</a></section><p>See also <a href="pdesolver_user.html#PDESolver.registerIC"><code>registerIC</code></a> and <a href="pdesolver_user.html#PDESolver.registerBC"><code>registerBC</code></a>.</p><footer><hr/><a class="previous" href="pdesolver_user.html"><span class="direction">Previous</span><span class="title">PDESolver User Interface</span></a><a class="next" href="pdesolver_structure.html"><span class="direction">Next</span><span class="title">PDESolver Structure</span></a></footer></article></body></html>

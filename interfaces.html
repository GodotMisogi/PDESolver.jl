<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Code Interfaces · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">PDESolver Introduction</a></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="build.html">Building PDESolver</a></li><li><a class="toctext" href="deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li class="current"><a class="toctext" href="interfaces.html">Code Interfaces</a><ul class="internal"><li><a class="toctext" href="#AbstractSolutionData-1">AbstractSolutionData</a></li><li><a class="toctext" href="#AbstractMesh-1">AbstractMesh</a></li><li><a class="toctext" href="#Physics-Module-1">Physics Module</a></li><li><a class="toctext" href="#Functional-Programming-1">Functional Programming</a></li></ul></li><li><a class="toctext" href="parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="pdesolver.html">Introduction</a></li><li><a class="toctext" href="pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="pdesolver_physics.html">PDESolver PhysicsInterface</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="solver/misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="solver/euler/misc.html">Misc</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="input/input.html">Introduction</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li></ul></li><li><a class="toctext" href="NonlinearSolvers/newton.html">Newton&#39;s Method</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="Utils/Utils.html">Main</a></li><li><a class="toctext" href="Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="Utils/projections.html">Projections</a></li><li><a class="toctext" href="Utils/logging.html">Logging</a></li><li><a class="toctext" href="Utils/io.html">Input/Output</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>DOC To be broken up or organized</li><li><a href="interfaces.html">Code Interfaces</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/c9dbcf7dbf20f621143b33fbc19208be32d2b7c9/docs/src/interfaces.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Interfaces-in-PDESolver-1" href="#Interfaces-in-PDESolver-1">Interfaces in PDESolver</a></h1><p>PDESolver depends on the the three main objects, the <code>AbstractSolutionData</code> object,  <code>AbstractMesh</code> object, and the SBP object implementing certain interfaces. This document describes what the interfaces are, and gives some hints for how to  implement them.</p><p>Before doing so, a short description of what general Julia interfaces look like is in order.   The paradigm of Julia code is that of &quot;objects with associated functions&quot;, where  a new Type is defined, and then functions that take the Type as an argument are defined. The functions define the interface to the Type. The Type holds data (ie. state), and the functions perform operations on that state (ie. behavior). Perhaps counter-intuitively, it is generally not recommended for users of a type to access the fields directly. Instead, any needed operations on the data that the Type holds should be provided through functions. The benefit of this convention is that it imposes no requirements on how the Type stores its data or implements its behavior. This is important because a user of the Type should not be concerned with these things. The user needs to know what behavior the Type has, but not how it is implemented. This distinction becomes even more important when there are multiple implementations certain functionality. The user should be able to seamlessly transition between different implementations. This requires all implementations have the same interface.</p><p>The question of how to enforce interfaces, and how strongly to do so, is still an open question in Julia. Some relevant Github issues:</p><ul><li><a href="https://github.com/JuliaLang/julia/issues/5">5</a></li><li><a href="https://github.com/JuliaLang/julia/issues/4935">4935</a></li><li><a href="https://github.com/JuliaLang/julia/issues/6975">6975</a></li></ul><p>One of the strongest arguments against the &quot;functions as interfaces&quot; idea is that for many applications, just storing data in an array is best. Creating interface functions for the Type to implement the array interface would be a lot of extra code with no benefit. For this reason, it makes sense to directly access the fields of some Types, to avoid trivial get/set methods. We do this extensively in PDESolver, because arrays are the natural choice for storing the kind of data used in PDESolver.</p><h2><a class="nav-anchor" id="AbstractSolutionData-1" href="#AbstractSolutionData-1">AbstractSolutionData</a></h2><p>ODLCommonTools defines:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODLCommonTools.AbstractSolutionData" href="#ODLCommonTools.AbstractSolutionData"><code>ODLCommonTools.AbstractSolutionData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This abstract type is the supertype for all the objects that store the    solution data. Every physics module should implement its own subtype.</p><p>Static parameters:</p><pre><code class="language-none">Tsol: datatype of solution variables
Tres: datatype of the mesh variables</code></pre><p>See the <a href="interfaces.html#AbstractSolutionData-1">AbstractSolutionData</a> for the description of everything this   type must implement.</p></div></section><p>The purpose of an <code>AbstractSolutionData</code> is to hold all the data related to the solution of an equation. This includes the solution at every node and any auxiliary quantities. The storage for any quantity that is calculated over the entire mesh should be allocated as part of this object, in order to avoid repeatedly reallocated the array for every residual evaluation. In general, there should never be a need to allocate a vector longer than the number of degrees of freedom at a node (or a matrix similarly sized matrix) during a residual evaluation. Structuring code such that it conforms with this requirement has significant performance benefits because it reduces memory allocation/deallocation.</p><p>The static parameter <code>Tsol</code> is the datatype of the solution variables and <code>Tres</code> is the datatype of the residual (when computing the Jacobian with finite differences or algorithmic differentiation, these will be the same).</p><h3><a class="nav-anchor" id="Required-Fields-1" href="#Required-Fields-1">Required Fields</a></h3><p>The required fields of an <code>AbstractSolutionData</code> are:</p><pre><code class="language-none">  q::AbstractArray{Tsol, 3}
  q_vec::AbstractArray{Tsol, 1}
  shared_data::AbstractArray{SharedFaceData{Tsol}, 1}
  res::AbstractArray{Tres, 3}
  res_vec::AbstractArray{Tres, 1}
  M::AbstractArray{Float64, 1}
  Minv::AbstractArray{Float64, 1}
  disassembleSolution::Function
  assembleSolution::Function
  multiplyA0inv::Function
  majorIterationCallback::Function
  params{Tsol..., Tdim}::AbstractParamType{Tdim}</code></pre><p>The purpose of these fields are:</p><p><code>q</code>: to hold the solution variables in an element-based array.      This array should be <code>numDofPerNode</code> x <code>numNodesPerElement</code> x <code>numEl</code>.      The residual evaluation <em>only</em> uses <code>q</code>, never <code>q_vec</code></p><p><code>q_vec</code>: to hold the solution variables as a vector, used for any linear algebra operations and time stepping. This array should have a length equal to the total number of degrees of freedom in the mesh. Even though this vector is not used by the residual evaluation, it is needed for many other operations, so it is allocated here so the memory can be reused. There are functions to facilitate the scattering of values from <code>q_vec</code> to <code>q</code>. Note that for Continuous Galerkin type discretization (as opposed to Discontinuous Galerkin discretizations), there is not a corresponding &quot;gather&quot; operation (ie. <code>q</code> -&gt; <code>q_vec</code>).</p><p><code>shared_data</code> is a vector of length <code>npeers</code>.  Each element contains the data               needed send and receive the <code>q</code> variables to/from other               the corresponding MPI rank listed in <code>mesh.peer_parts</code>.               The precise contents of <code>SharedFaceData</code> is documented in the               <code>Utils</code> module, however they do include the send and receive               buffers.</p><p><code>res</code>: similar to <code>q</code>, except that the residual evaluation function populates        it with the residual values.          As with <code>q</code>, the residual evaluation function only interacts with this array,        never with <code>res_vec</code>.</p><p><code>res_vec</code>: similar to <code>q_vec</code>.  Unlike <code>q_vec</code> there are functions to perform an            additive reduction (basically a &quot;gather&quot;) of <code>res</code> to <code>res_vec</code>.              For continuous Galerkin discretizations, the corresponding &quot;scatter&quot;            (ie. <code>res_vec</code> -&gt; res`) may not exist.</p><p><code>M</code>:  The mass matrix of the entire mesh.  Because SBP operators have diagonal       mass matrices, this is a vector.  Length numDofPerNode x numNodes (where       numNodes is the number of nodes in the entire mesh).</p><p><code>Minv</code>:  The inverse of the mass matrix.</p><p><code>disassembleSolution</code>:  Function that takes the a vector such as <code>q_vec</code> and                         scatters it to an array such as <code>q</code>.                         This function must have the signature:                         <code>disassembleSolution(mesh::AbstractMesh, sbp, eqn::AbstractSolutionData, opts, q_arr:AbstractArray{T, 3}, q_vec::AbstractArray{T, 1})</code>                         Because this variable is a field of a type, it will be dynamically dispatched.                         Although this is slower than compile-time dispatch, the cost is insignificant compared to the cost of evaluating the residual, so the added flexibility of having this function as a field is worth the cost.</p><p><code>assembleSolution</code>:  Function that takes an array such as <code>res</code> and performs an additive reduction to a vector such as <code>res_vec</code>.                      This function must have the signature:                      <code>assembleSolution(mesh::AbstractMesh, sbp, eqn::AbstractSolutionData, opts, res_arr::AbstractArray{T, 3}, res_vec::AbstractArray{T, 1}, zero_resvec=true)</code>                      The argument <code>zero_resvec</code> determines whether <code>res_vec</code> is zeroed before the reduction is performed.                      Because it is an additive reduction, elements of the vector are only added to, never overwritten, so forgetting to zero out the vector could cause strange results.                      Thus the default is true.</p><p><code>multiplyA0inv</code>:  Multiplies the solution values at each node in an array such as <code>res</code> by the inverse of the coefficient matrix of the time term of the equation.                   This function is used by time marching methods.                   For some equations, this matrix is the identity matrix, so it can be a no-op, while for others might not be.                   The function must have the signature:</p><p><code>multiplyA0inv(mesh::AbstractMesh, sbp, eqn::AbstractSolutionData, opts, res_arr::AbstractArray{Tsol, 3})</code></p><p><code>majorIterationCallback</code>:  function called before every step of Newton&#39;s method or stage of an explicit time marching scheme. This function is used to do output and logging. The function must have the signature:</p><p><code>function majorIterationCallback(itr, mesh::AbstractMesh, sbp::AbstractSBP, eqn::AbstractEulerData, opts)</code></p><p><code>params</code>:  user defined type that inherits from <code>AbstractParamType</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODLCommonTools.AbstractParamType" href="#ODLCommonTools.AbstractParamType"><code>ODLCommonTools.AbstractParamType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This abstract type is the supertype for all Param objects, which hold values    needed for the computation in a place that is fast to access.</p><p>The Param type is also useful for dispatching to low level functions which     the AbstractSolutionData might not be passed (depending on the organization     of the physics module.</p><p><strong>Static Parameters</strong>:</p><ul><li>Tdim: the dimensionality of the equation being solved (2d or 3d usually)</li></ul></div></section><p>The purpose of this type is to store any variables that need to be quickly accessed or updated. The only required fields are: * <code>t::Float64</code>: hold the current time value * <code>order</code>: order of accuracy of the discretization (same as <code>AbstractMesh.order</code>) *  <code>time::Timings</code>: an object to record how long different parts of the code take,   defined in the Utils module.</p><h2><a class="nav-anchor" id="AbstractMesh-1" href="#AbstractMesh-1">AbstractMesh</a></h2><p>ODLCommonTools defines:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODLCommonTools.AbstractMesh" href="#ODLCommonTools.AbstractMesh"><code>ODLCommonTools.AbstractMesh</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This abstract type is the supertype for all mesh objects.  Every interface to   a mesh software should define its own implementation.</p><p>Static parameters:</p><pre><code class="language-none">Tmsh: datatype of the mesh data (coordinates, mapping to/from parametric
      space, mapping jacobian).</code></pre><p>See the <a href="interfaces.html#AbstractMesh-1">AbstractMesh</a> for the description of everything this   type must implement.</p></div></section><p>The purpose of an <code>AbstractMesh</code> is to hold all the mesh related data that the  solver will need.  It also serves to establish an interface between the solver  and whatever mesh software is used.  By storing all data in the fields of the  <code>AbstractMesh</code> object, the details of how the mesh software stores and allows  retrieval of data are not needed by the solver.  This should make it easy to  accommodate different mesh software without making any changes to the solver.</p><p>The static parameter <code>Tmsh</code> is used to enable differentiation with respect to the mesh variable in the future.</p><h3><a class="nav-anchor" id="Required-Fields-2" href="#Required-Fields-2">Required Fields</a></h3><pre><code class="language-none">  # counts
  numVert::Integer
  numEl::Integer
  numNodes::Integer
  numDof::Integer
  numDofPerNode::Integer
  numNodesPerElement::Integer
  order::Integer
  numNodesPerFace::Int

  # parallel counts
  npeers::Int
  numGlobalEl::Int
  numSharedEl::Int
  peer_face_counts::Array{Int, 1}
  local_element_counts::Array{Int, 1}
  remote_element_counts::array{Int, 1}

  # MPI Info
  comm::MPI.Comm
  myrank::Int
  commsize::Int
  peer_parts::Array{Int, 1}

  # Discretization type
  isDG::Bool
  isInterpolated::bool

  # mesh data
  coords::AbstractArray{Tmsh, 3}
  dxidx::AbstractArray{Tmsh, 4}
  jac::AbstractArray{Tmsh, 2}

  # interpolated data
  coords_bndry::Array{Tmsh, 3}
  dxidx_bndry::Array{Tmsh, 4}
  jac_bndry::Array{T1, 2}
  dxidx_face::Array{Tmsh, 4}
  jac_face::Array{Tmsh, 2}

  # parallel data
  coords_sharedface::Array{Array{Tmsh, 3}, 1}
  dxidx_sharedface::Array{Array{Tmsh, 4}, 1}
  jac_sharedface::Array{Array{Tmsh, 2}, 1}  

  # boundary condition data
  numBC::Integer
  numBoundaryEdges::Integer
  bndryfaces::AbstractArray{Boundary, 1}
  bndry_offsets::AbstractArray{Integer, 1}
  bndry_funcs::AbstractArray{BCType, 1}

  # interior edge data
  numInterfaces::Integer
  interfaces::AbstractArray{Interface, 1}

  # degree of freedom number data
  dofs::AbstractArray{Integer, 2}
  dof_offset::Int
  sparsity_bnds::AbstractArray{Integer, 2}
  sparsity_nodebnds::AbstractArray{Integer, 2}

  # mesh coloring data
  numColors::Integer
  maxColors::Integer
  color_masks::AbstractArray{ AbstractArray{Number, 1}, 1}
  shared_element_colormasks::Array{Array{BitArray{1}, 1}, 1}
  pertNeighborEls::AbstractArray{Integer, 2}

  # parallel bookkeeping
  bndries_local::Array{Array{Boundary, 1}, 1}
  bndries_remote::Array{Array{Boundary, 1}, 1}
  shared_interfaces::Array{Array{Interface, 1}, 1}
  shared_element_offsets::Array{Int, 1}
  local_element_lists::Array{Array{Int, 1}, 1}
</code></pre><h4><a class="nav-anchor" id="Counts-1" href="#Counts-1">Counts</a></h4><p><code>numVert</code>:  number of vertices in the mesh</p><p><code>numEl</code>:  number of elements in the mesh</p><p><code>numNodes</code>: number of nodes in the mesh</p><p><code>numDof</code>:  number of degrees of freedom in the mesh (= <code>numNodes</code> * <code>numDofPerNode</code>)</p><p><code>numDofPerNode</code>:  number of degrees of freedom on each node.</p><p><code>numNodesPerElement</code>:  number of nodes on each element.</p><p><code>order</code>:  order of the discretization (ie. first order, second order...), where           an order <code>p</code> discretization should have a convergence rate of <code>p+1</code>.</p><p><code>numNodesPerFace</code>: number of nodes on an edge in 2D or face in 3D.  For interpolated                    meshes it is the number of interpolation points on the face</p><h4><a class="nav-anchor" id="Parallel-Counts-1" href="#Parallel-Counts-1">Parallel Counts</a></h4><p><code>npeers</code>: number of processes that have elements that share a face with the current          process</p><p><code>numGlobalEl</code>: number of locally owned elements + number of non-local elements that                share a face with a locally owned element</p><p><code>numSharedEl</code>: number of non-local elements that share a face with a locally owned                element</p><p><code>local_element_counts</code>: array of length <code>npeers</code>, number of local elements                         that share a face with each remote process</p><p><code>remote_element_counts</code>: array of length <code>npeers</code>, number of remote elements                          that share a face with with current process</p><h4><a class="nav-anchor" id="MPI-Info-1" href="#MPI-Info-1">MPI Info</a></h4><p><code>comm</code>: the MPI Communicator the mesh is defined on <code>myrank</code>: rank of current MPI process (0-based) <code>commsize</code>: number of MPI processes on this communicator <code>peer_parts</code>: array of MPI proccess ranks for each process that has elements that               share a face with the current process</p><h4><a class="nav-anchor" id="Discretization-Type-1" href="#Discretization-Type-1">Discretization Type</a></h4><p><code>isDG</code>: true if mesh is a DG type discretization <code>isInterpolated</code>: true if mesh requires data to be interpolated to the faces                   of an element</p><h4><a class="nav-anchor" id="Mesh-Data-1" href="#Mesh-Data-1">Mesh Data</a></h4><p><code>coords</code>: <code>n</code> x <code>numNodesPerElement</code> x <code>numEl</code> array, where <code>n</code> is the dimensionality of            the equation being solved (2D or 3D typically).              <code>coords[:, nodenum, elnum] = [x, y, z]</code> coordinates of node <code>nodenum</code>            of element <code>elnum</code>.</p><p><code>dxidx</code>:  <code>n</code> x <code>n</code> x <code>numNodesPerElement</code> x <code>numEl</code>, where <code>n</code> is defined above. It stores the mapping jacobian scaled by <code>( 1/det(jac) dxi/dx )</code> where <code>xi</code> are the parametric coordinates, <code>x</code> are the physical (x,y,z) coordinates, and <code>jac</code> is the determinant of the mapping jacobian <code>dxi/ dx</code>.</p><p><code>jac</code>  : <code>numNodesPerElement</code> x <code>numEl</code> array, holding the determinant of the          mapping jacobian <code>dxi/dx</code> at each node of each element.</p><h4><a class="nav-anchor" id="Interpolated-Data-1" href="#Interpolated-Data-1">Interpolated Data</a></h4><p>This data is used for interpolated mesh only.</p><p><code>coords_bndry</code>: coordinates of nodes on the boundary of the mesh,                 2 x <code>numFaceNodes</code> x <code>numBoundaryEdges</code></p><p><code>dxidx_bndry</code>: 2 x 2 x <code>numFaceNodes</code> x <code>numBoundary edges array of `dxidx</code>                interpolated to the boundary of the mesh</p><p><code>jac_bndry</code>: <code>numFaceNodes</code> x <code>numBoundaryEdges</code> array of <code>jac</code> interpolated               to the boundary</p><p><code>dxidx_face</code>: 2 x 2 x <code>numFaceNodes</code> x <code>numInterfaces</code> array of <code>dxidx</code>               interpolated to the face shared between two elements</p><p><code>jac_face</code>: <code>numNodesPerFace</code> x <code>numInterfaces</code> array of <code>jac</code> interpolated              to the face shared between two element</p><h4><a class="nav-anchor" id="Parallel-Data-1" href="#Parallel-Data-1">Parallel Data</a></h4><p>This data is required for parallelizing interpolated DG meshes</p><p><code>coords_sharedface</code>: array of arrays, one array for each peer process,                      containing the coordinates of the nodes on the faces                      shared between a local element on a non-local element.                      Each array is 2 x <code>numFaceNodes</code> x number of faces shared                      with this process. <code>dxidx_sharedface</code>: similar to <code>coords_sharedface</code>, <code>dxidx</code> interpolated to                     faces between elements in different processes, each                     array is 2 x 2 x <code>numFaceNodes</code> x number of faces shared                     with this process. <code>jac_sharedface</code>: similar to <code>coords_sharedface</code>, <code>jac</code> interpolated to faces                   between a local element and a non-local element. Each array                   is <code>numFaceNodes</code> x number of faces shared with this process.</p><h4><a class="nav-anchor" id="Boundary-Condition-Data-1" href="#Boundary-Condition-Data-1">Boundary Condition Data</a></h4><p>The mesh object stores data related to applying boundary conditions. Boundary conditions are imposed weakly, so there is no need to remove degrees of freedom from the mesh when Dirichlet boundary conditions are applied. In order to accommodate any combination of boundary conditions, an array of functors are stored as part of the mesh object, along with lists of which mesh edges (or faces in 3D) should have which boundary condition applied to them</p><p><code>numBC</code>: number of different types of boundary conditions used.</p><p><code>numBoundaryEdges</code>: number of mesh edges that have boundary conditions applied                     to them.</p><p><code>bndryfaces</code>:  array of Boundary objects (which contain the element number and                the local index of the edge), of length <code>numBoundaryEdges</code>.</p><p><code>bndry_offsets</code>:  array of length numBC+1, where <code>bndry_offsets[i]</code> is the index                   in <code>bndryfaces</code> where the edges that have boundary condition                   <code>i</code> applied to them start.                   The final entry in <code>bndry_offsets</code> should be <code>numBoundaryEdges + 1</code>.                   Thus <code>bndryfaces[ bndry_offsets[i]:(bndry_offsets[i+1] - 1) ]</code>                   contains all the boundary edges that have boundary condition                   <code>i</code> applied to them.</p><p><code>bndry_funcs</code>:  array of boundary functors, length <code>numBC</code>.  All boundary                 functors are subtypes of <code>BCType</code>.  Because <code>BCType</code> is an                 abstract type, the elements of this array should not be used                 directly, but passed as an argument to another function, to                  avoid type instability.</p><h4><a class="nav-anchor" id="Interior-Edge-Data-1" href="#Interior-Edge-Data-1">Interior Edge Data</a></h4><p>Data about interior mesh edges (or faces in 3D) is stored to enable use of edge stabilization or Discontinuous Galerkin type discretizations. Only data for edges (faces) that are shared by two elements are stored (ie. boundary edges are not considered).</p><p><code>numInterfaces</code>:  number of interior edges</p><p><code>interfaces</code>:  array of Interface types (which contain the element numbers for                the two elements sharing the edge, and the local index of the                edge from the perspective of the two elements, and an indication                of the relative edge orientation).                The two element are referred to as <code>elementL</code> and <code>elementR</code>,                but the choice of which element is <code>elementL</code> and which is                <code>elementR</code> is arbitrary.                The length of the array is numInterfaces.               Unlike <code>bndryfaces</code>, the entries in the array do not have to be in               any particular order.</p><h4><a class="nav-anchor" id="Degree-of-Freedom-Numbering-Data-1" href="#Degree-of-Freedom-Numbering-Data-1">Degree of Freedom Numbering Data</a></h4><p><code>dofs</code>:  <code>numDofPerNode</code> x <code>numNodesPerElement</code> x <code>numEl</code> array. Holds the local degree of freedom number of each degree of freedom. Although the exact method used to assign dof numbers is not critical, all degrees of freedom on a node must be numbered sequentially.</p><p><code>dof_offset</code>: offset added to the local dof number to make it a global dof               number.</p><p><code>sparsity_bnds</code>:  2 x <code>numDof</code> array. <code>sparsity_bnds[:, i]</code> holds the maximum, minimum degree of freedom numbers associated with degree of freedom <code>i</code>. In this context, degrees of freedom <code>i</code> and <code>j</code> are associated if entry <code>(i,j)</code> of the jacobian is non-zero. In actuality, <code>sparsity_bnds</code> need only define upper and lower bounds for degree of freedom associations (ie. they need not be tight bounds). This array is used to to define the sparsity pattern of the jacobian matrix.</p><p><code>sparsity_nodebnds</code>:  2 x numNodes array. <code>sparsity_bnds[:, i]</code> holds the maximum, minimum node associated with node <code>i</code>, similar the information stored in <code>sparsity_bnds</code> for degrees of freedom.</p><h4><a class="nav-anchor" id="Mesh-Coloring-Data-1" href="#Mesh-Coloring-Data-1">Mesh Coloring Data</a></h4><p>The NonlinearSolvers module uses algorithmic differentiation to compute the Jacobian. Doing so efficiently requires perturbing multiple degrees of freedom simultaneously, but perturbing associated degrees of freedom at the same time leads to incorrect results. Mesh coloring assigns each element of the mesh to a group (color) such that every degree of freedom on each element is not associated with any other degree  of freedom on any other element of the same color. An important aspect of satisfying this condition is the use of the  element-based arrays (all arrays that store data for a quantity over the entire  mesh are <code>ncomp</code> x <code>numNodesPerElement</code> x <code>numEl</code>). In such an array, any node that is part of 2 or more elements has one entry for each element. When performing algorithmic differentiation, this enables perturbing a degree of  freedom on one element without perturbing it on the other elements that share  the degree of freedom.</p><p>For example, consider a node that is shared by two elements. Let us say it is node 2 of element 1 and node 3 of element 2. This means <code>AbstractSolutionData.q[:, 2, 1]</code> stores the solution variables for this node on the first element, and <code>AbstractSolutionData.q[:, 3, 2]</code> stores the solution variables for the second element. Because these are different entries in the array <code>AbstractSolutionData.q</code>, they can be perturbed independently. Because <code>AbstractSolutionData.res</code> has the same format, the perturbations to <code>AbstractSolutionData.q[:, 2, 1]</code> are mapped to <code>AbstractSolutionData.res[:, 2, 1]</code> for a typical continuous Galerkin type discretization. This is a direct result of having an element-based discretization.</p><p>There are some discretizations, however, that are not strictly element-based. Edge stabilization, for example, causes all the degrees of freedom of one element to be associated with any elements it shares an edge with. To deal with this, we use the idea of a distance-n coloring. A distance-n coloring is a coloring where there are n elements in between two element of the same color. For element-based discretizations with element-based arrays, every element in the mesh can be the same color.  This is a distance-0 coloring. For an edge stabilization discretization, a distance-1 coloring is required, where every element is a different color than any neighbors it shares and edge with. (As a side node, the algorithms that perform a distance-1 coloring are rather complicated, so in practice we use a distance-2 coloring instead).</p><p>In order to do algorithmic differentiation, the <code>AbstractMesh</code> object must store the information that determines which elements are perturbed for which colors, and, for the edge stabilization case, how to relate a perturbation in the output  <code>AbstractSolutionData.res</code> to the degree of freedom in <code>AbstractSolutionData.q</code> in O(1) time. Each degree of freedom on an element is perturbed independently of the other degrees of freedom on the element, so the total number of residual evaluations is the number of colors times the number of degrees of freedom on an element.</p><p>The fields required are:</p><p><code>numColors</code>:  The number of colors in the mesh. <code>maxColors</code>: the maximum number of colors on any process</p><p><code>color_masks</code>:  array of length <code>numColors</code>.  Each entry in the array is itself                 an array of length <code>numEl</code>.  Each entry of the inner array is                 either a 1 or a 0, indicating if the current element is                 perturbed or not for the current color. For example, in <code>color_mask_i = color_masks[i]; mask_elj = color_mask_i[j]</code>, the variable <code>mask_elj</code> is either a 1 or a zero, determining whether or not element <code>j</code> is perturbed as part of color <code>i</code>.</p><p><code>shared_element_colormasks</code>: array of BitArrays controlling when to perturb                              non-local elements.  There are <code>npeers</code> arrays,                              each of length number of non-local elements shared                              with this process</p><p><code>pertNeighborEls</code>:  <code>numEl</code> x <code>numColors</code> array.  <code>neighbor_nums[i,j]</code> is the element number of of the element whose perturbation is affected element <code>i</code> when color <code>j</code> is being perturbed, or zero if element <code>i</code> is not affected by any  perturbation.  </p><h4><a class="nav-anchor" id="Parallel-Bookkeeping-1" href="#Parallel-Bookkeeping-1">Parallel Bookkeeping</a></h4><p><code>bndries_local</code>: array of arrays of <code>Boundary</code>s describing faces shared                  with non-local elements from the local side (ie. the                  local element number and face).  The number of arrays is                  <code>npeers</code>.</p><p><code>bndries_remote</code>: similar to <code>bndries_local</code>, except describing the faces                   from the non-local side.  Note that the element numbers are                   from the <em>remote</em> process</p><p><code>shared_interfaces</code>: array of arrays of <code>Interface</code>s describing the faces                      shared between local and non-local elements.  The local                      element is <em>always</em> <code>elementL</code>.  The remote element is                      assigned a local number greater than <code>numEl</code>.</p><p><code>shared_element_offsets</code>: array of length npeers+1 that contains the first                           element number assigned to elements on the shared                           interface.  The last entry is equal to the highest                           element number on the last peer process + 1.  The                           elements numbers assigned to a given peer must form                           a contiguous range.</p><p><code>local_element_lists</code>: array of arrays containing the element numbers of the                        elements that share a face with each peer process</p><h3><a class="nav-anchor" id="Other-Functions-1" href="#Other-Functions-1">Other Functions</a></h3><p>The mesh module must also defines and exports the functions</p><pre><code class="language-none">saveSolutionToMesh(mesh::MeshImplementationType, vec::AbstractVector)
writeVisFiles(mesh::MeshImplementationType, fname::ASCIIString)</code></pre><p>where the first function takes a vector of length <code>numDof</code> and saves it to the mesh, and the second writes Paraview files for the mesh, including the solution field.</p><h3><a class="nav-anchor" id="Subtypes-1" href="#Subtypes-1">Subtypes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODLCommonTools.AbstractCGMesh" href="#ODLCommonTools.AbstractCGMesh"><code>ODLCommonTools.AbstractCGMesh</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>ODLCommonTools.AbstractCGMesh</strong></p><p>The abstrac type is the supertype of all continuous Galerkin meshes</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODLCommonTools.AbstractDGMesh" href="#ODLCommonTools.AbstractDGMesh"><code>ODLCommonTools.AbstractDGMesh</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>ODLCommonTools.AbstractDGGMesh</strong></p><p>The abstrac type is the supertype of all discontinuous Galerkin meshes</p></div></section><h2><a class="nav-anchor" id="Physics-Module-1" href="#Physics-Module-1">Physics Module</a></h2><p>For every new physics to be solved, a new module should be created. The purpose of this module is to evaluate the equation:</p><p><code>M dq/dt = f(q)</code></p><p>where <code>M</code> is the mass matrix. For steady problems, <code>dq/dt = 0</code> and the module evaluates the residual. For unsteady problems, the form <code>M dq/dt = f(q)</code> is suitable for explicit time marching.</p><p>Every physics module must define a boundary condition called <code>defaultBC</code>.  If the user does not specify a boundary condition on any geometric edges, the mesh constructor will add a new boundary condition and assign all mesh edges classified on the unspecified geometric edges are assigned to it.  This boundary condition can be a no-op if that is correct for the physics, or it can be the face integral that should be done for every element (recall that boundary faces do not appear in <code>mesh.interfaces</code>).</p><h3><a class="nav-anchor" id="Interface-to-NonlinearSolvers-1" href="#Interface-to-NonlinearSolvers-1">Interface to NonlinearSolvers</a></h3><p>The <code>evalResidual</code> function and the fields <code>eqn.q</code> and <code>eqn.res</code> are the interface between the NonlinearSolvers and the physics modules.  The Nonlinear solvers populate <code>eqn.q</code>, and use <code>evalResidual</code> to populate <code>eqn.res</code>, from which the next value if <code>eqn.q</code> is calculated.  The algorthmic differentiation mechanism described above is uses several residual evaluations to compute the Jacobian if needed for a given method.  Some methods, such as RK4, are better expressed in terms of <code>eqn.q_vec</code> and <code>eqn.res_vec</code> rather than <code>eqn.q</code> and <code>eqn.res</code>.  <code>eqn.assembleSolution</code> and <code>eqn.disassmbleSolution</code> exist to transform back and forth between the vector and 3D array forms.  In order to compute the Jacobian efficiently, it is necessary to work with the 3D arrays. For this reason, <code>evalResidual</code> must work only with <code>eqn.q</code> and <code>eqn.res</code> and let the caller decide whether or not to transform into the vector form.</p><p>Newton&#39;s method supports both finite differences and complex step for calculating the Jacobian, and the static parameters need to be set accordingly. If finite differences are used, then <code>Tsol=Tres=Tmsh=Float64</code> is required.  If complex step is used, then <code>Tsol=Tres=Complex128</code> and <code>Tmsh = Float64</code> is needed.</p><h3><a class="nav-anchor" id="Interface-to-users-1" href="#Interface-to-users-1">Interface to users</a></h3><p>The interface to users is described in <code>src/Readme.md</code></p><h3><a class="nav-anchor" id="Interface-to-Summation-by-Parts-1" href="#Interface-to-Summation-by-Parts-1">Interface to Summation-by-Parts</a></h3><p>The physics modules use the interface provided by the Summation-by-Parts package to approximate derivatives numerically.  The reason for passing around the <code>sbp</code> object is that the SBP interface requires it to be passed in along with the data arrays it operates on.</p><h2><a class="nav-anchor" id="Functional-Programming-1" href="#Functional-Programming-1">Functional Programming</a></h2><p>An important aspect of the use of the <code>mesh</code>, <code>sbp</code>, <code>eqn</code>, and <code>opts</code> to define interfaces is that the physics modules and nonlinear solvers are written in a purely functional programming style, which is to say that the behavior of every function is determined entirely by the arguments to the function, and the only effects of the function are to modify an argument or return a value.</p><p>This property is important for writing generic, reusable code. For example, when using iterative solvers, a preconditioner is usually required, and constructing the preconditioner requires doing residual evaluations. In some cases, the preconditioner will use a different mesh or a different mesh coloring. Because the physics modules are written in a functional style, they can be used to evaluate the residual on a different mesh simply by passing the residual evaluation function a different mesh object.</p><p>A critical aspect of function programming is that there is <em>no global state</em>. The state of the solver is determined entirely by the state of the objects that are passed around.</p><p>##Variable Naming Conventions In an attempt to make code more uniform and readable, certain variable names are reserved for certain uses.</p><ul><li><code>mesh</code>:  object that implements <code>AbstractMesh</code></li><li><code>pmesh</code>:  mesh used for preconditioning</li><li><code>sbp</code>:  Summation-by-Parts object</li><li><code>eqn</code>:  object that implements <code>AbstractSolutionData</code></li><li><code>opts</code>: options dictionary</li><li><code>params</code>: parameter object (used for values that might be in <code>opts</code> but need to be accessed quickly)</li><li><code>x</code>: the first real coordinate direction</li><li><code>y</code>: the second real coordinate direction</li><li><code>xi</code>: the first parametric coordinate direction</li><li><code>eta</code>: the second parametric coordinate direction</li><li><code>h</code>:  mesh spacing</li><li><code>hx</code>: mesh spacing in x direction</li><li><code>hy</code>: mesh spacing in y direction</li><li><code>p</code>: pressure at a node</li><li><code>a</code>; speed of sound at a node</li><li><code>s</code>: entropy at a node</li><li><code>gamma</code>: specific heat ratio</li><li><code>gamma_1</code>: <code>gamma</code> - 1</li><li><code>R</code>: specific gas constant in ideal gas law (units J/(Kg * K) in SI)</li><li><code>delta_t</code>: time step</li><li><code>t</code>: current time</li><li><code>nrm</code>: a normal vector of some kind</li><li><code>A0</code>: the coefficient matrix of the time term at a node</li><li><code>Axi</code>: the flux jacobian at a node in the <code>xi</code> direction</li><li><code>Aeta</code>: the flux jacobian at a node in the <code>eta</code> direction</li><li><code>Ax</code>: the flux jacobian in the <code>x</code> direction at a node</li><li><code>Ay</code>: the flux jacobian in the <code>y</code> direction at a node</li></ul><footer><hr/><a class="previous" href="deps_readme.html"><span class="direction">Previous</span><span class="title">Build Options</span></a><a class="next" href="parallel.html"><span class="direction">Next</span><span class="title">Code Parallelization</span></a></footer></article></body></html>

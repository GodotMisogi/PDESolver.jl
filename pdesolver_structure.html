<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PDESolver Structure · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="concepts/intro.html">Intro</a></li><li><a class="toctext" href="concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="build.html">Building PDESolver</a></li><li><a class="toctext" href="deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="pdesolver.html">Introduction</a></li><li><a class="toctext" href="pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="pdesolver_physics.html">PDESolver Physics Interface</a></li><li class="current"><a class="toctext" href="pdesolver_structure.html">PDESolver Structure</a><ul class="internal"><li><a class="toctext" href="#Physics-Module-Startup-1">Physics Module Startup</a></li></ul></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="solver/misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="input/input.html">Introduction</a></li><li><a class="toctext" href="input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="Utils/Utils.html">Main</a></li><li><a class="toctext" href="Utils/parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="Utils/projections.html">Projections</a></li><li><a class="toctext" href="Utils/logging.html">Logging</a></li><li><a class="toctext" href="Utils/io.html">Input/Output</a></li><li><a class="toctext" href="Utils/checkpoint.html">Checkpointing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Frontend</li><li><a href="pdesolver_structure.html">PDESolver Structure</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/3cd40b12c60e956b9f60cdebb6548a91433e2fd4/docs/src/pdesolver_structure.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Starting-a-Simulation-1" href="#Starting-a-Simulation-1">Starting a Simulation</a></h1><p>This page describes functions located in the PDESolver module that tie together the physics modules and the Nonlinear solvers.  </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.run_solver-Tuple{AbstractString}" href="#PDESolver.run_solver-Tuple{AbstractString}"><code>PDESolver.run_solver</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function provides a way to invoke any physics solver based on the   specification of the physics in the input file.   This requires loading the input file twice, once to figure out the physics,   and a second time when the physics-specific startup function is called</p><p>The physics module must have already been registered using <a href="pdesolver_physics.html#PDESolver.register_physics"><code>register_physics</code></a></p><p>Inputs:</p><pre><code class="language-none">input_file: an AbstractString specifying the path to the input file</code></pre><p>Outputs:</p><pre><code class="language-none">mesh: the AbstractMesh object used during the solve
sbp: the SBP operator used by the solver
eqn: the AbstractSolutionData object during the solve.  At exit,
     eqn.q_vec should have the final solution in it
opts: the options dictionary</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.call_nlsolver" href="#PDESolver.call_nlsolver"><code>PDESolver.call_nlsolver</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function takes in the 4 principle object, fully initialized, and calls   a nonlinear solver on them, according to the options in the dictionary.   The evalResidual function is passed to the nonlinear solver</p><p>Inputs:     mesh: a mesh object     sbp: an SBP operator     eqn: an equation object     opts: options dictionary, used to determine which nonlinear solver to call     pmesh: mesh used for calculating preconditioning jacobian in Newton&#39;s            method, default to using mesh if not specified</p><p>Outputs:     none</p><p>Aliasing restrictions: none (specificaly, mesh and pmesh <em>can</em> be the same                          object)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createMeshAndOperator-Tuple{Any,Any}" href="#PDESolver.createMeshAndOperator-Tuple{Any,Any}"><code>PDESolver.createMeshAndOperator</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Create a SBP operator and a mesh.  This is used by all physics modules   to create the right type of operator and mesh based on the input options.   It is type unstable, but that is ok.</p><p>If the options dictionary specifies a second SBP operator type, a second   mesh and SBP operator will be created and stored in the <code>mesh2</code> and <code>sbp2</code></p><p>Inputs:     opts: options dictonary     dofpernode: number of degrees of freedom on each node</p><p>Outputs     sbp : an AbstractSBP     mesh : an AbstractMesh     pmesh : an AbstractMesh, used for preconditioning, may be same object as             mesh     Tsol : DataType that should be used for eqn.q     Tres : DataType that should be used for eqn.res     Tmsh : DataType of mesh.dxidx and friends     mesh_time : time in seconds for creation of mesh (Float64)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createMesh" href="#PDESolver.createMesh"><code>PDESolver.createMesh</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function creates the mesh object and, optionally, a second mesh   used for preconditioning</p><p>Inputs:     opts: the options dictionary     sbp: an SBP operator     sbpface: an SBP face operator     topo: an ElementTopology describing the SBP reference element.  Only           needed for 3D DG, otherwise can be any value     Tmsh: the DataType of the elements of the mesh arrays (dxidx, jac, etc.)     dofpernode: number of degrees of freedom on every node     suffix: suffix added to options dictionary keys that describe the SBP             operator.  See <a href="pdesolver_structure.html#PDESolver.createSBPOperator"><code>createSBPOperator</code></a></p><p>All arguments except opts are typically provided by    <a href="pdesolver_structure.html#PDESolver.createSBPOperator"><code>createSBPOperator</code></a> and <a href="pdesolver_structure.html#PDESolver.getDataTypes-Tuple{Dict{K,V}}"><code>getDataTypes</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.createSBPOperator" href="#PDESolver.createSBPOperator"><code>PDESolver.createSBPOperator</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function constructs the SBP operator and the associated SBP face   operator, as specified by the options dictionary.  It also determines   the shape_type that PumiInterface uses to describe the SBP operator to   Pumi.</p><p>Inputs:     opts: the options dictionary     Tsbp: the DataType specifying the Tsbp passed to the SBP operator           constructor     suffix: this suffix is added to all keys accessed in the options dictionary.             Usually the suffix is either the empty string or an integer.  This             provides a convenient way for the input file to specify several             different SBP operator and have this operator construct them.             Default value is the empty string.</p><p>Outputs:     sbp: the SBP operator     sbpface: the SBP face operator     shape_type: an integer passed to the mesh constructor to describe the                 operator     topo: in the 3D DG case, an ElementTopology describing the SBP reference           element, otherwise the integer 0.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PDESolver.getDataTypes-Tuple{Dict{K,V}}" href="#PDESolver.getDataTypes-Tuple{Dict{K,V}}"><code>PDESolver.getDataTypes</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function determines the datatypes of the elements of the arrays of the   mesh quantities, sbp operator, solution variables and residual.</p><p>If the datatypes cannot be determined, an error is thrown.</p><p>Inputs:     opts: the options dictionary</p><p>Outputs     Tmsh     Tsbp     Tsol     Tres</p></div></section><h2><a class="nav-anchor" id="Physics-Module-Startup-1" href="#Physics-Module-Startup-1">Physics Module Startup</a></h2><p>TODO: does this belong here, or in the physics module section?</p><p>Each physics module is required to do some of the setup work needed to start a simulation. The functions above facilitate doing so. In particular, the physics module must</p><ul><li>read the input dictionary</li><li>create an <code>AbstractMesh</code> and <code>AbstractSBP</code></li><li>create an <code>AbstractSolutionData</code></li><li>Load an initial condition</li><li>Calculate various quantities</li><li>Invoke a NonlinearSolver</li><li>Do postprocessing</li></ul><h3><a class="nav-anchor" id="Input-Dictionary-1" href="#Input-Dictionary-1">Input Dictionary</a></h3><h3><a class="nav-anchor" id="Creating-Mesh-and-Operator-1" href="#Creating-Mesh-and-Operator-1">Creating Mesh and Operator</a></h3><h3><a class="nav-anchor" id="Create-an-Equation-Object-1" href="#Create-an-Equation-Object-1">Create an Equation Object</a></h3><h3><a class="nav-anchor" id="Load-an-initial-condition-1" href="#Load-an-initial-condition-1">Load an initial condition</a></h3><h3><a class="nav-anchor" id="Various-calculations-1" href="#Various-calculations-1">Various calculations</a></h3><h3><a class="nav-anchor" id="Invoke-a-NonlinearSolver-1" href="#Invoke-a-NonlinearSolver-1">Invoke a NonlinearSolver</a></h3><h3><a class="nav-anchor" id="Do-Postprocessing-1" href="#Do-Postprocessing-1">Do Postprocessing</a></h3><p>The functions here should be used by all physics modules to assist in creating the <code>AbstractMesh</code> and <code>AbstractSBP</code> objects and calling a nonlinear solver.</p><p>TODO: document what the physics module needs to implement for startup</p><footer><hr/><a class="previous" href="pdesolver_physics.html"><span class="direction">Previous</span><span class="title">PDESolver Physics Interface</span></a><a class="next" href="invocation/calling.html"><span class="direction">Next</span><span class="title">Calling PDESolver</span></a></footer></article></body></html>

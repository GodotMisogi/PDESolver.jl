{
    "docs": [
        {
            "location": "/", 
            "text": "PDESolver Documentation\n\n\nWelcome to the PDESolver documentation.  These documents provide an overview of PDESolver, a Julia based solver for partial differential equations. This page will describe the form of the equations and the Summation-By-Parts operators used to discretize them.  The \nTable of Contents\n links to the components of PDESolver that calculate each term.\n\n\n\n\nForm of the Equation\n\n\nPDESolver discretizes equation in the form:\n\n\n$\\frac{n!}{k!(n - k)!} = \\binom{n}{k}$\n\n\n$\\frac{\\partial q}{\\partial t} = \\mathcal{R}(u, t)$\n\n\n\n\nTable of Contents\n\n\n\n\nOverview of Physics Modules\n\n\nAdvection Physics Documentation\n\n\nEuler Physics Documentation\n\n\nSimple ODE Documentation\n\n\nNonlinearSolvers Documentation\n\n\nInput Module Documentation\n\n\nUtilties", 
            "title": "Home"
        }, 
        {
            "location": "/#pdesolver-documentation", 
            "text": "Welcome to the PDESolver documentation.  These documents provide an overview of PDESolver, a Julia based solver for partial differential equations. This page will describe the form of the equations and the Summation-By-Parts operators used to discretize them.  The  Table of Contents  links to the components of PDESolver that calculate each term.", 
            "title": "PDESolver Documentation"
        }, 
        {
            "location": "/#form-of-the-equation", 
            "text": "PDESolver discretizes equation in the form:  $\\frac{n!}{k!(n - k)!} = \\binom{n}{k}$  $\\frac{\\partial q}{\\partial t} = \\mathcal{R}(u, t)$", 
            "title": "Form of the Equation"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "Overview of Physics Modules  Advection Physics Documentation  Euler Physics Documentation  Simple ODE Documentation  NonlinearSolvers Documentation  Input Module Documentation  Utilties", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/pdesolver/", 
            "text": "Documentation of the PDESolver Module\n\n\n\n\nDocumentation of the PDESolver User Facing Interface\n\n\nDocumentation of the PDESolver Physics Module Interface", 
            "title": "PDESolver"
        }, 
        {
            "location": "/pdesolver/#documentation-of-the-pdesolver-module", 
            "text": "Documentation of the PDESolver User Facing Interface  Documentation of the PDESolver Physics Module Interface", 
            "title": "Documentation of the PDESolver Module"
        }, 
        {
            "location": "/pdesolver_user/", 
            "text": "Documentation of the PDESolver User Facing Interface", 
            "title": "PDESolver User Interface"
        }, 
        {
            "location": "/pdesolver_user/#documentation-of-the-pdesolver-user-facing-interface", 
            "text": "", 
            "title": "Documentation of the PDESolver User Facing Interface"
        }, 
        {
            "location": "/pdesolver_physics/", 
            "text": "Documentation of the PDESolver Physics Module Interface", 
            "title": "PDESolver Physics Interface"
        }, 
        {
            "location": "/pdesolver_physics/#documentation-of-the-pdesolver-physics-module-interface", 
            "text": "", 
            "title": "Documentation of the PDESolver Physics Module Interface"
        }, 
        {
            "location": "/solver/Readme/", 
            "text": "Overview of Physics Modules\n\n\n\n\nAbstractSolutionData\n and Physics Module Implementation\n\n\nThis document describes some best practices for implementing a physics module. These practices are not required, but have proven to be useful for producing organized, readable, and reusable code.\n\n\n\n\nLevels of Functions\n\n\nIt is useful to divide functions into 3 catagories, high, mid, and low level functions.  The purpose of high level functions is to decide which method of performing an operation should be used and call other functions to do it. For example, the Euler physics modules has \nevalVolumeIntegrals\n and \nevalBoundaryIntegrals\n as high level functions.  There are several different ways of calculating both the volume and boundary integrals.  The options dictionary is used to decide what mid level function to call.  Each mid level function implements a different way of doing the calculation.\n\n\nThe purpose of mid level functions is to loop over the mesh and call a low level function for each node.  For example, the function \ngetEulerFlux\n loops over the nodes of the mesh and calls a function to calculate the Euler flux at each node.  Mid level function names usually start with \nget\n to indicate that their purpose is to calculate some quantity but don't do the calculation themselves.\n\n\nLow level functions calculate a quantity at a node.  For example, \ncalcEulerFlux\n calculates the Euler flux at a single node.  Low level function names usually start with \ncalc\n to indicate that they perform a specific calculation. Often, different discretizations use the same structure of loops, but do a slightly different calculation at each node.  Low level functions are called inside the innermost loop of the code, so it would be too expensive to have if statements to select which low level function to call, so various tricks involving Julia's multiple dispatch system are used to get the compiler to decide which low level function to call.  These will be described later in this document.\n\n\nIt is often useful to dispatch to low level functions based on \nTdim\n and \nvar_type\n.  For this reason the Euler equation implementation of \nAbstractParamType\n is\n\n\ntype ParamType{Tdim, var_type, Tsol, Tres, Tmsh} \n: AbstractParamType{Tdim}\n\n\n\n\nThe other static parameters are necessary because \nParamType\n has fields of those datatypes.\n\n\n\n\nAbstractSolutionData\n implementation\n\n\nEach physics module should define and export a subtype of \nAbstractSolutionData{Tsol, Tres}\n. The implementation of \nAbstractSolutionData{Tsol, Tres}\n must inherit the \nTsol\n and \nTres\n static parameters, and may have additional static parameters as well. It may also be helpful to define additional abstract types within the physics module to provide different levels of abstractions. For example, the Euler physics module defines:\n\n\nabstract AbstractEulerData{Tsol, Tres} \n: AbstractSolutionData{Tsol, Tres}\nabstract EulerData {Tsol, Tdim, Tres, var_type} \n: AbstractEulerData{Tsol, Tres}\ntype EulerData_{Tsol, Tres, Tdim, Tmsh, var_type} \n: EulerData{Tsol, Tdim, Tres, var_type}\n\n\n\n\nThe first line is effectively just a name change and may not be necessary. The second line adds the static parameters \nTdim\n, and \nvar_type\n while inheriting the \nTsol\n and \nTres\n types from \nAbstractEulerData\n. \nTdim\n is the dimensionality of the equation, \nTres\n is the datatype of the residual variables, and \nvar_type\n is a symbol indicating whether the equation is being solved with conservative or entropy variables. The third line defines a concrete type that implements all the features required of an \nAbstractSolutionData\n, and adds a static parameter \nTmsh\n, the datatype of the mesh variables.   The additional static parameter is necessary because one field of \nEulerData_\n has type \nTmsh\n. Note that there could be multiple implementations of \nAbstractSolutionData\n for the Euler equations, perhaps with different fields to store certain data or not. All these implementations will need to have the static parameters \nTsol\n, \nTdim\n, \nTres\n, and \nvar_type\n, so \nEulerData\n is defined as an abstract type,  allowing all implementations to inherit from it. All high level functions involved in evaluating the residual will take in an argument of type \nEulerData\n. Only when low level functions need to dispatch based on which implementation is  used would it take in an \nEulerData_\n or another implementation.\n\n\n\n\nVariable Conversion\n\n\nSome equations can be written in different variables, and need to convert between them.  To do this, it is \nfunction convertFromNaturalToWorkingVars{Tsol}(params::ParamType{2, :var_type},                qc::AbstractArray{Tsol,1}, qe::AbstractArray{Tsol,1})\n\n\nthat converts from the \"natural\" variables in which to write an equation to some other set of variables at a node.  For the Euler equations, the \"natural\" variables would be the conservative variables, and one example of \"other\" variables would be the entropy variables.\n\n\nIt is also sometimes useful to define the opposite conversion, ie. from the working variables to the natural variables.\n\n\n\n\nInput Options\n\n\nMany of the components of PDESolver have different options that control how they work and what they do. In order to  provide a unified method of specifying these options, an dictionary  of type \nDict{ASCIIString, Any}\n is read in from a disk file. This dictionary (called \nopts\n in function signatures), is passed to all high and mid level function so they can use values in the dictionary to determine their  control flow. Low level functions need to be extremely efficient, so they cannot have conditional logic, therefore they are not passed the dictionary. Note that retrieving values from a dictionary is very slow compared to accessing the fields of a type, so all values that are accessed repeatedly should be stored  as the field of a type.\n\n\n\n\nFunctors\n\n\nFunctors are a trick used to get Julia's dispatch system to make decisions at compile time rather than runtime.  This is particularly useful for boundary conditions, where the list of mesh faces that have boundary conditions applied is determined at runtime, but having conditional statements that execute for every node on the mesh boundary would be slow.  Instead a construct is used as follows:\n\n\ntype myBC \n: BCType  # create a singleton type\nend\n\nfunction call(obj::myBC, q::AbstractVector, bndryflux::AbstractVector)\n  # calculate boundary flux here\nend\n\n\n\n\nThis defines a datatype and adds a method to the \ncall\n function for that type. The call function is what makes a datatype callable like a function.  This method is called as follows:\n\n\nfunctor = myBC()  # construct and object of type myBC\nq = rand(4)\nbndryflux = zeros(4)\nfunctor(q, bndryflux)  # the Julia compiler turns this into call(functor, q, bndryflux)  \n\n\n\n\nThe way this is used for boundary conditions is through a two level construct where an outer function passes a functor to an inner function.  Julia's JIT with generate a method of the inner function that is specialized to the functor (this is why it is important that the functor is a datatype).  For example:\n\n\n```julia function getBCFluxes(mesh, sbp, eqn, opts)\n\n\nfor i=1:mesh.numBC  # loop over different boundary conditions     functor_i = mesh.bndry_functor[i]  # get the functor for this boundary condition     start_index = mesh.bndry_offsets[i]     end_index = mesh.bndry_offsets[i+1] - 1     # get data for boundary faces start_index:end_index\n\n\ncalcBoundaryFlux(functor_i, data for boundary faces start_index:end_index)\n\n\n\n\nend end  # end function\n\n\nfunction calcBoundaryFlux(functor_i::BCType, data for boundary faces start_index:end_index)     for i=1:length(start_index:end_index)       for j=1:num_nodes_on_face         # get data for this boundary face node         functor_i(data for this boundary face node)       end     end\n\n\nend  # end function   ```\n\n\nThe benefit of this arrangement is that \nmesh.numBC\n different version of calcBoundaryFlux get compiled, one for each functor, and each version knows about the \ncall\n method that was defined for the functor it is passed.  This two level scheme allows the compiler to make all the decisions about what function to call (ie. the \ncall\n method of the functor), avoiding any conditional logic at runtime\n\n\nThis idea is also applicable to the flux functions used by DG methods.\n\n\nInitialization of a Simulation\n\n\nThis section lists an outline of how a simulation gets launched After step 4, the procedure becomes a bit more complicated because there are optional steps. Only the required steps are listed below.\n\n\n\n\n\n\nThe options dictionary is read in.  Default values are supplied for any key that is not specified, if a reasonable default value exists.\n\n\n\n\n\n\nSecond, the \nsbp\n operator is constructed.\n\n\n\n\n\n\nThe \nmesh\n object is constructed, using the options dictionary and the \nsbp\n operator.  Some of the options in the dictionary are used to determine how the mesh gets constructed.  For example, the options dictionary specifies what kind of mesh coloring to do.\n\n\n\n\n\n\nThe \neqn\n object is constructed, using the \nmesh\n, \nsbp\n, and \nopts\n objects.\n\n\n\n\n\n\nThe physics module \ninit\n function is called, which initializes the physics module and finishes any initialization that \nmesh\n and \neqn\n objects require.\n\n\n\n\n\n\nThe initial condition is applied to \neqn.q_vec\n.\n\n\n\n\n\n\nA nonlinear solver is called.  Which solver is called and what parameters it uses are determined by the options dictionary.\n\n\n\n\n\n\nPost-processing is done, if required by the options dictionary.", 
            "title": "Solver"
        }, 
        {
            "location": "/solver/Readme/#overview-of-physics-modules", 
            "text": "", 
            "title": "Overview of Physics Modules"
        }, 
        {
            "location": "/solver/Readme/#abstractsolutiondata-and-physics-module-implementation", 
            "text": "This document describes some best practices for implementing a physics module. These practices are not required, but have proven to be useful for producing organized, readable, and reusable code.", 
            "title": "AbstractSolutionData and Physics Module Implementation"
        }, 
        {
            "location": "/solver/Readme/#levels-of-functions", 
            "text": "It is useful to divide functions into 3 catagories, high, mid, and low level functions.  The purpose of high level functions is to decide which method of performing an operation should be used and call other functions to do it. For example, the Euler physics modules has  evalVolumeIntegrals  and  evalBoundaryIntegrals  as high level functions.  There are several different ways of calculating both the volume and boundary integrals.  The options dictionary is used to decide what mid level function to call.  Each mid level function implements a different way of doing the calculation.  The purpose of mid level functions is to loop over the mesh and call a low level function for each node.  For example, the function  getEulerFlux  loops over the nodes of the mesh and calls a function to calculate the Euler flux at each node.  Mid level function names usually start with  get  to indicate that their purpose is to calculate some quantity but don't do the calculation themselves.  Low level functions calculate a quantity at a node.  For example,  calcEulerFlux  calculates the Euler flux at a single node.  Low level function names usually start with  calc  to indicate that they perform a specific calculation. Often, different discretizations use the same structure of loops, but do a slightly different calculation at each node.  Low level functions are called inside the innermost loop of the code, so it would be too expensive to have if statements to select which low level function to call, so various tricks involving Julia's multiple dispatch system are used to get the compiler to decide which low level function to call.  These will be described later in this document.  It is often useful to dispatch to low level functions based on  Tdim  and  var_type .  For this reason the Euler equation implementation of  AbstractParamType  is  type ParamType{Tdim, var_type, Tsol, Tres, Tmsh}  : AbstractParamType{Tdim}  The other static parameters are necessary because  ParamType  has fields of those datatypes.", 
            "title": "Levels of Functions"
        }, 
        {
            "location": "/solver/Readme/#abstractsolutiondata-implementation", 
            "text": "Each physics module should define and export a subtype of  AbstractSolutionData{Tsol, Tres} . The implementation of  AbstractSolutionData{Tsol, Tres}  must inherit the  Tsol  and  Tres  static parameters, and may have additional static parameters as well. It may also be helpful to define additional abstract types within the physics module to provide different levels of abstractions. For example, the Euler physics module defines:  abstract AbstractEulerData{Tsol, Tres}  : AbstractSolutionData{Tsol, Tres}\nabstract EulerData {Tsol, Tdim, Tres, var_type}  : AbstractEulerData{Tsol, Tres}\ntype EulerData_{Tsol, Tres, Tdim, Tmsh, var_type}  : EulerData{Tsol, Tdim, Tres, var_type}  The first line is effectively just a name change and may not be necessary. The second line adds the static parameters  Tdim , and  var_type  while inheriting the  Tsol  and  Tres  types from  AbstractEulerData .  Tdim  is the dimensionality of the equation,  Tres  is the datatype of the residual variables, and  var_type  is a symbol indicating whether the equation is being solved with conservative or entropy variables. The third line defines a concrete type that implements all the features required of an  AbstractSolutionData , and adds a static parameter  Tmsh , the datatype of the mesh variables.   The additional static parameter is necessary because one field of  EulerData_  has type  Tmsh . Note that there could be multiple implementations of  AbstractSolutionData  for the Euler equations, perhaps with different fields to store certain data or not. All these implementations will need to have the static parameters  Tsol ,  Tdim ,  Tres , and  var_type , so  EulerData  is defined as an abstract type,  allowing all implementations to inherit from it. All high level functions involved in evaluating the residual will take in an argument of type  EulerData . Only when low level functions need to dispatch based on which implementation is  used would it take in an  EulerData_  or another implementation.", 
            "title": "AbstractSolutionData implementation"
        }, 
        {
            "location": "/solver/Readme/#variable-conversion", 
            "text": "Some equations can be written in different variables, and need to convert between them.  To do this, it is  function convertFromNaturalToWorkingVars{Tsol}(params::ParamType{2, :var_type},                qc::AbstractArray{Tsol,1}, qe::AbstractArray{Tsol,1})  that converts from the \"natural\" variables in which to write an equation to some other set of variables at a node.  For the Euler equations, the \"natural\" variables would be the conservative variables, and one example of \"other\" variables would be the entropy variables.  It is also sometimes useful to define the opposite conversion, ie. from the working variables to the natural variables.", 
            "title": "Variable Conversion"
        }, 
        {
            "location": "/solver/Readme/#input-options", 
            "text": "Many of the components of PDESolver have different options that control how they work and what they do. In order to  provide a unified method of specifying these options, an dictionary  of type  Dict{ASCIIString, Any}  is read in from a disk file. This dictionary (called  opts  in function signatures), is passed to all high and mid level function so they can use values in the dictionary to determine their  control flow. Low level functions need to be extremely efficient, so they cannot have conditional logic, therefore they are not passed the dictionary. Note that retrieving values from a dictionary is very slow compared to accessing the fields of a type, so all values that are accessed repeatedly should be stored  as the field of a type.", 
            "title": "Input Options"
        }, 
        {
            "location": "/solver/Readme/#functors", 
            "text": "Functors are a trick used to get Julia's dispatch system to make decisions at compile time rather than runtime.  This is particularly useful for boundary conditions, where the list of mesh faces that have boundary conditions applied is determined at runtime, but having conditional statements that execute for every node on the mesh boundary would be slow.  Instead a construct is used as follows:  type myBC  : BCType  # create a singleton type\nend\n\nfunction call(obj::myBC, q::AbstractVector, bndryflux::AbstractVector)\n  # calculate boundary flux here\nend  This defines a datatype and adds a method to the  call  function for that type. The call function is what makes a datatype callable like a function.  This method is called as follows:  functor = myBC()  # construct and object of type myBC\nq = rand(4)\nbndryflux = zeros(4)\nfunctor(q, bndryflux)  # the Julia compiler turns this into call(functor, q, bndryflux)    The way this is used for boundary conditions is through a two level construct where an outer function passes a functor to an inner function.  Julia's JIT with generate a method of the inner function that is specialized to the functor (this is why it is important that the functor is a datatype).  For example:  ```julia function getBCFluxes(mesh, sbp, eqn, opts)  for i=1:mesh.numBC  # loop over different boundary conditions     functor_i = mesh.bndry_functor[i]  # get the functor for this boundary condition     start_index = mesh.bndry_offsets[i]     end_index = mesh.bndry_offsets[i+1] - 1     # get data for boundary faces start_index:end_index  calcBoundaryFlux(functor_i, data for boundary faces start_index:end_index)  end end  # end function  function calcBoundaryFlux(functor_i::BCType, data for boundary faces start_index:end_index)     for i=1:length(start_index:end_index)       for j=1:num_nodes_on_face         # get data for this boundary face node         functor_i(data for this boundary face node)       end     end  end  # end function   ```  The benefit of this arrangement is that  mesh.numBC  different version of calcBoundaryFlux get compiled, one for each functor, and each version knows about the  call  method that was defined for the functor it is passed.  This two level scheme allows the compiler to make all the decisions about what function to call (ie. the  call  method of the functor), avoiding any conditional logic at runtime  This idea is also applicable to the flux functions used by DG methods.", 
            "title": "Functors"
        }, 
        {
            "location": "/solver/Readme/#initialization-of-a-simulation", 
            "text": "This section lists an outline of how a simulation gets launched After step 4, the procedure becomes a bit more complicated because there are optional steps. Only the required steps are listed below.    The options dictionary is read in.  Default values are supplied for any key that is not specified, if a reasonable default value exists.    Second, the  sbp  operator is constructed.    The  mesh  object is constructed, using the options dictionary and the  sbp  operator.  Some of the options in the dictionary are used to determine how the mesh gets constructed.  For example, the options dictionary specifies what kind of mesh coloring to do.    The  eqn  object is constructed, using the  mesh ,  sbp , and  opts  objects.    The physics module  init  function is called, which initializes the physics module and finishes any initialization that  mesh  and  eqn  objects require.    The initial condition is applied to  eqn.q_vec .    A nonlinear solver is called.  Which solver is called and what parameters it uses are determined by the options dictionary.    Post-processing is done, if required by the options dictionary.", 
            "title": "Initialization of a Simulation"
        }, 
        {
            "location": "/solver/advection/advection/", 
            "text": "Advection Physics Documentation\n\n\nDescribe the equation being solved here\n\n\n\n\nAdvection Physics Documentation\n\n\nAdvection Types\n\n\nAdvection Volume Integrals\n\n\nAdvection Face Integrals\n\n\nAdvection Boundary Integrals\n\n\nAdvection Initial Conditions\n\n\nAdvection Source Term\n\n\nAdvection Common Functions\n\n\nAdvection Adjoint\n\n\nAdvection Boundary Functional", 
            "title": "Advection"
        }, 
        {
            "location": "/solver/advection/advection/#advection-physics-documentation", 
            "text": "Describe the equation being solved here   Advection Physics Documentation  Advection Types  Advection Volume Integrals  Advection Face Integrals  Advection Boundary Integrals  Advection Initial Conditions  Advection Source Term  Advection Common Functions  Advection Adjoint  Advection Boundary Functional", 
            "title": "Advection Physics Documentation"
        }, 
        {
            "location": "/solver/advection/types/", 
            "text": "Advection Types", 
            "title": "Datatypes"
        }, 
        {
            "location": "/solver/advection/types/#advection-types", 
            "text": "", 
            "title": "Advection Types"
        }, 
        {
            "location": "/solver/advection/volume/", 
            "text": "Advection Volume Integrals", 
            "title": "Volume Integrals"
        }, 
        {
            "location": "/solver/advection/volume/#advection-volume-integrals", 
            "text": "", 
            "title": "Advection Volume Integrals"
        }, 
        {
            "location": "/solver/advection/flux/", 
            "text": "Advection Face Integrals", 
            "title": "Face Integrals"
        }, 
        {
            "location": "/solver/advection/flux/#advection-face-integrals", 
            "text": "", 
            "title": "Advection Face Integrals"
        }, 
        {
            "location": "/solver/advection/bc/", 
            "text": "Advection Boundary Integrals", 
            "title": "Boundary Integrals"
        }, 
        {
            "location": "/solver/advection/bc/#advection-boundary-integrals", 
            "text": "", 
            "title": "Advection Boundary Integrals"
        }, 
        {
            "location": "/solver/advection/ic/", 
            "text": "Advection Initial Conditions", 
            "title": "Initial Conditions"
        }, 
        {
            "location": "/solver/advection/ic/#advection-initial-conditions", 
            "text": "", 
            "title": "Advection Initial Conditions"
        }, 
        {
            "location": "/solver/advection/source/", 
            "text": "Advection Source Term", 
            "title": "Source Term"
        }, 
        {
            "location": "/solver/advection/source/#advection-source-term", 
            "text": "", 
            "title": "Advection Source Term"
        }, 
        {
            "location": "/solver/advection/common/", 
            "text": "Advection Common Functions", 
            "title": "Common Functions"
        }, 
        {
            "location": "/solver/advection/common/#advection-common-functions", 
            "text": "", 
            "title": "Advection Common Functions"
        }, 
        {
            "location": "/solver/advection/adjoint/", 
            "text": "Advection Adjoint", 
            "title": "Adjoint"
        }, 
        {
            "location": "/solver/advection/adjoint/#advection-adjoint", 
            "text": "", 
            "title": "Advection Adjoint"
        }, 
        {
            "location": "/solver/advection/boundary_functional/", 
            "text": "Advection Boundary Functional", 
            "title": "Boundary Functional"
        }, 
        {
            "location": "/solver/advection/boundary_functional/#advection-boundary-functional", 
            "text": "", 
            "title": "Advection Boundary Functional"
        }, 
        {
            "location": "/solver/euler/euler/", 
            "text": "Euler Physics Documentation\n\n\nDescribe the equation being solved here\n\n\n\n\nEuler Datatype Documentation\n\n\nVolume Integrals\n\n\nFace Integral\n\n\nBoundary Integrals\n\n\nInitial Conditions\n\n\nSource Term\n\n\nCommon Functions\n\n\nConversion Between Different Variables\n\n\nNumerical Flux Functions\n\n\nStabilization Documentation\n\n\nAdjoint\n\n\nBoundary Functional\n\n\nMiscellaneous Function", 
            "title": "Euler"
        }, 
        {
            "location": "/solver/euler/euler/#euler-physics-documentation", 
            "text": "Describe the equation being solved here   Euler Datatype Documentation  Volume Integrals  Face Integral  Boundary Integrals  Initial Conditions  Source Term  Common Functions  Conversion Between Different Variables  Numerical Flux Functions  Stabilization Documentation  Adjoint  Boundary Functional  Miscellaneous Function", 
            "title": "Euler Physics Documentation"
        }, 
        {
            "location": "/solver/euler/types/", 
            "text": "Euler Datatype Documentation", 
            "title": "Datatypes"
        }, 
        {
            "location": "/solver/euler/types/#euler-datatype-documentation", 
            "text": "", 
            "title": "Euler Datatype Documentation"
        }, 
        {
            "location": "/solver/euler/volume/", 
            "text": "Volume Integrals", 
            "title": "Volume Integrals"
        }, 
        {
            "location": "/solver/euler/volume/#volume-integrals", 
            "text": "", 
            "title": "Volume Integrals"
        }, 
        {
            "location": "/solver/euler/flux/", 
            "text": "Face Integral", 
            "title": "Face Integrals"
        }, 
        {
            "location": "/solver/euler/flux/#face-integral", 
            "text": "", 
            "title": "Face Integral"
        }, 
        {
            "location": "/solver/euler/bc/", 
            "text": "Boundary Integrals", 
            "title": "Boundary Integrals"
        }, 
        {
            "location": "/solver/euler/bc/#boundary-integrals", 
            "text": "", 
            "title": "Boundary Integrals"
        }, 
        {
            "location": "/solver/euler/ic/", 
            "text": "Initial Conditions", 
            "title": "Initial Conditions"
        }, 
        {
            "location": "/solver/euler/ic/#initial-conditions", 
            "text": "", 
            "title": "Initial Conditions"
        }, 
        {
            "location": "/solver/euler/source/", 
            "text": "Source Term", 
            "title": "Source Term"
        }, 
        {
            "location": "/solver/euler/source/#source-term", 
            "text": "", 
            "title": "Source Term"
        }, 
        {
            "location": "/solver/euler/common/", 
            "text": "Common Functions", 
            "title": "Common Functions"
        }, 
        {
            "location": "/solver/euler/common/#common-functions", 
            "text": "", 
            "title": "Common Functions"
        }, 
        {
            "location": "/solver/euler/conversion/", 
            "text": "Conversion Between Different Variables", 
            "title": "Conversion"
        }, 
        {
            "location": "/solver/euler/conversion/#conversion-between-different-variables", 
            "text": "", 
            "title": "Conversion Between Different Variables"
        }, 
        {
            "location": "/solver/euler/flux_functions/", 
            "text": "Numerical Flux Functions\n\n\nbc_solvers.jl should be renamed to this", 
            "title": "Numerical Flux Functions"
        }, 
        {
            "location": "/solver/euler/flux_functions/#numerical-flux-functions", 
            "text": "bc_solvers.jl should be renamed to this", 
            "title": "Numerical Flux Functions"
        }, 
        {
            "location": "/solver/euler/stabilization/", 
            "text": "Stabilization Documentation", 
            "title": "Stabilization"
        }, 
        {
            "location": "/solver/euler/stabilization/#stabilization-documentation", 
            "text": "", 
            "title": "Stabilization Documentation"
        }, 
        {
            "location": "/solver/euler/adjoint/", 
            "text": "Adjoint", 
            "title": "Adjoint"
        }, 
        {
            "location": "/solver/euler/adjoint/#adjoint", 
            "text": "", 
            "title": "Adjoint"
        }, 
        {
            "location": "/solver/euler/boundary_functional/", 
            "text": "Boundary Functional", 
            "title": "Boundary Functional"
        }, 
        {
            "location": "/solver/euler/boundary_functional/#boundary-functional", 
            "text": "", 
            "title": "Boundary Functional"
        }, 
        {
            "location": "/solver/euler/misc/", 
            "text": "Miscellaneous Function\n\n\nA bunch of the things in euler_funcs.jl", 
            "title": "Misc"
        }, 
        {
            "location": "/solver/euler/misc/#miscellaneous-function", 
            "text": "A bunch of the things in euler_funcs.jl", 
            "title": "Miscellaneous Function"
        }, 
        {
            "location": "/solver/simpleODE/simpleODE/", 
            "text": "Simple ODE Documentation", 
            "title": "Simple ODE"
        }, 
        {
            "location": "/solver/simpleODE/simpleODE/#simple-ode-documentation", 
            "text": "", 
            "title": "Simple ODE Documentation"
        }, 
        {
            "location": "/input/input/", 
            "text": "Input Module Documentation", 
            "title": "Input"
        }, 
        {
            "location": "/input/input/#input-module-documentation", 
            "text": "", 
            "title": "Input Module Documentation"
        }, 
        {
            "location": "/NonlinearSolvers/nonlinearsolvers/", 
            "text": "NonlinearSolvers Documentation", 
            "title": "NonlinearSolvers"
        }, 
        {
            "location": "/NonlinearSolvers/nonlinearsolvers/#nonlinearsolvers-documentation", 
            "text": "", 
            "title": "NonlinearSolvers Documentation"
        }, 
        {
            "location": "/NonlinearSolvers/steady/", 
            "text": "Steady NonlinearSolver Documentation", 
            "title": "Steady"
        }, 
        {
            "location": "/NonlinearSolvers/steady/#steady-nonlinearsolver-documentation", 
            "text": "", 
            "title": "Steady NonlinearSolver Documentation"
        }, 
        {
            "location": "/NonlinearSolvers/unsteady/", 
            "text": "Unsteady NonlinearSolver Documentation", 
            "title": "Unsteady"
        }, 
        {
            "location": "/NonlinearSolvers/unsteady/#unsteady-nonlinearsolver-documentation", 
            "text": "", 
            "title": "Unsteady NonlinearSolver Documentation"
        }, 
        {
            "location": "/Utils/Utils/", 
            "text": "Utilties\n\n\nThis module contains functions and types that are useful for the solver but independent the equation being solved. Additional utility functions are located in the \nODLCommontools\n. The functions defined in the \nUtils\n module are useful in the context of \nPDESolver\n and depend on the functions and datatypes defined in the other parts of the solver. The functions defined in \nODLCommonTools\n are more general in nature and usable independent of \nPDESolver\n.\n\n\n\n\nInput/Output\n\n\nLogging Documentation\n\n\nProjections documentation", 
            "title": "Utils"
        }, 
        {
            "location": "/Utils/Utils/#utilties", 
            "text": "This module contains functions and types that are useful for the solver but independent the equation being solved. Additional utility functions are located in the  ODLCommontools . The functions defined in the  Utils  module are useful in the context of  PDESolver  and depend on the functions and datatypes defined in the other parts of the solver. The functions defined in  ODLCommonTools  are more general in nature and usable independent of  PDESolver .   Input/Output  Logging Documentation  Projections documentation", 
            "title": "Utilties"
        }, 
        {
            "location": "/Utils/parallel/", 
            "text": "Parallel Constructs Documentations\n\n\nThese function define the primative operations used by the physics modules to exchange data in parallel. When using these functions, the should not have to make any MPI calls directly, they should all be encapsulated within the provided functions.\n\n\nTODO: crossref to physics module documentation\n\n\nThe \nTypes and Basic API\n section describes the \nSharedFaceData\n datatype and the basic functions that operate on it. The \nParallel Data Exchange\n section describes the functions used by the physics modules that start and finish parallel parallel communication.\n\n\n\n\nTypes and Basic API\n\n\n#\n\n\nUtils.SharedFaceData\n \n \nType\n.\n\n\nThis type holds all the data necessary to perform MPI communication with   a given peer process that shared mesh edges (2D) or faces (3D) with the   current process.\n\n\nFields:\n\n\npeernum: the MPI rank of the peer process\npeeridx: the index of this peer in mesh.peer_parts\nmyrank: MPI rank of the current process\ncomm: MPI communicator used to define the above\n\nq_send: the send buffer, a 3D array of n x m x d.  While these dimensions\n        are arbitrary, there are two commonly used case.  If\n        opts[\nparallel_type\n] == face, then m is mesh.numNodesPerFace and\n        d is the number of faces shared with peernum.\n        If opts[\nparallel_type\n] == element, then \n        m = mesh.numNodesPerElement and d is the number of elements that\n        share faces with peernum.\nq_recv: the receive buffer.  Similar to q_send, except the size needs to\n        to be the number of entities on the *remote* process.\n\nsend_waited: has someone called MPI.Wait() on send_req yet?  Some MPI\n             implementations complain if Wait() is called on a Request\n             more than once, so use this field to avoid doing so.\nsend_req: the MPI.Request object for the Send/Isend/whatever other type of\n          Send\nsend_status: the MPI.Status object returned by calling Wait() on send_req\n\nrecv_waited: like send_waited, but for the receive\nrecv_req: like send_req, but for the receive\nrecv_status: like send_status, but for the receive\n\nbndries_local: Vector of Boundaries describing the faces from the local\n               side of the interface\nbndries_remote: Vector of Boundaries describing the facaes from the remote\n                side (see the documentation for PdePumiInterface before\n                using this field)\ninterfaces: Vector of Interfaces describing the faces from both sides (see\n            the documentation for PdePumiInterfaces, particularly the\n            mesh.shared_interfaces field, before using this field\n\n\n\n\n#\n\n\nUtils.SharedFaceData\n \n \nMethod\n.\n\n\nOuter constructor for SharedFaceData.\n\n\nInputs:\n\n\nmesh: a mesh object\npeeridx: the index of a peer in mesh.peer_parts\nq_send: the send buffer\nq_recv: the receive buffer\n\n\n\n\n#\n\n\nUtils.getSharedFaceData\n \n \nMethod\n.\n\n\nThis function returns a vector of SharedFaceData objects, one for each   peer processes the current process shares mesh edge (2D) or face (3D) with.   This function is intended to be used by the AbstractSolutionData constructors,   although it can be used to create additional vectors of SharedFaceData   objects.\n\n\nif opts[\"parallel_data\"] == \"face\", then the send and receive buffers   are numDofPerNode x numNodesPerFace x number of shared faces.\n\n\nif opts[\"parallel_data\"] == \"element\", the send and receive buffers are     numDofPerNode x numNodesPerElement x number of elements that share the     faces.  Note that the number of elements that share the faces can be     different for the send and receive buffers.\n\n\nInputs:\n\n\nTsol: element type of the arrays\nmesh: an AbstractMesh object\nsbp: an SBP operator\nopts: the options dictonary\n\n\n\n\nOutputs:\n\n\ndata_vec: Vector{SharedFaceData}.  data_vec[i] corresponds to \n          mesh.peer_parts[i]\n\n\n\n\n#\n\n\nBase.copy!\n \n \nMethod\n.\n\n\nIn-place copy for SharedFaceData.  This copies the buffers, but does not   retain the state of the Request and Status fields.  Instead they are   initialized the same as the constructor.\n\n\nThis function may only be called after receiving is complete,   otherwise an exception is thrown.\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\nCopy function for SharedFaceData.  Note that this does \nnot\n retain the   send_req/send_status (and similarly for the recceive) state   of the original object.  Instead, they are initialized the same as the   constructor.\n\n\nThis function may only be called after receiving is complete,   otherwise an exception is thrown.\n\n\n#\n\n\nUtils.assertReceivesConsistent\n \n \nMethod\n.\n\n\nLike assertSendsConsistent, but for the receives\n\n\n#\n\n\nUtils.assertReceivesWaited\n \n \nMethod\n.\n\n\nThis function verifies all the receives have been waited on for the    supplied SharedFaceData objects\n\n\n#\n\n\nUtils.assertSendsConsistent\n \n \nMethod\n.\n\n\nVerify either all or none of the sends have been waited on.  Throw an   exception otherwise.\n\n\nInputs:\n\n\nshared_data: Vector of SharedFaceData objects\n\n\n\n\nOutput:\n\n\nval: number of receives that have been waited on\n\n\n\n\n#\n\n\nUtils.waitAllReceives\n \n \nMethod\n.\n\n\nThis function is like MPI.Waitall, operating on the recvs of a vector of    SharedFaceData objects\n\n\n#\n\n\nUtils.waitAllSends\n \n \nMethod\n.\n\n\nThis function is like MPI.Waitall, operating on the sends of a vector of    SharedFaceData objects\n\n\n#\n\n\nUtils.waitAnyReceive\n \n \nMethod\n.\n\n\nLike MPI.WaitAny, but operates on the receives of  a vector of SharedFaceData.   Only the index of the Request that was waited on is returned,    the Status and recv_waited fields of hte SharedFaceData are updated internally\n\n\n\n\nParallel Data Exchange\n\n\nThe functions in this section are used to start sending data in parallel and finish receiving it. All functions operate on a \nVector\n of \nSharedFaceData\n that define what data to send to which peer processes.  See \nParallel Overview\n for a high-level overview of how the code is parallelized.\n\n\nSending the data to the other processes is straight-forward.  Receiving it (efficiently) is not. In particular, [\nfinishExchangeData\n] waits to receive data from one peer process, calls a user supplied callback function to do calculations involving the received data, and then waits for the next receive to finish. This is significantly more efficient than waiting for all receives to finish and then doing computations on all the data.\n\n\nThis section describes the API the physics modules use to do parallel  communication.  The \nInternals\n section describes the helper functions used in the implementation.\n\n\n#\n\n\nUtils.startSolutionExchange\n \n \nFunction\n.\n\n\nThis function is a thin wrapper around exchangeData().  It is used for the   common case of sending and receiving the solution variables to other processes.   It uses eqn.shared_data to do the parallel communication.   eqn.shared_data \nmust\n be passed into the corresponding finishDataExchange   call.\n\n\nInputs:     mesh: an AbstractMesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictionary\n\n\nKeyword arguments:     tag: MPI tag to use for communication, defaults to TAG_DEFAULT     wait: wait for sends and receives to finish before exiting\n\n\n#\n\n\nUtils.exchangeData\n \n \nFunction\n.\n\n\nThis function posts the MPI sends and receives for a vector of SharedFaceData.  It works for both opts[\"parallel_data\"] == \"face\" or \"element\".  The only   difference between these two cases is the populate_buffer() function.\n\n\nThe previous receives using these SharedFaceData objects should have   completed by the time this function is called.  An exception is throw   if this is not the case.\n\n\nThe previous sends are likely to have completed by the time this function   is called, but they are waited on if not.  This function might not perform   well if the previous sends have not completed.   #TODO: fix this using WaitAny\n\n\nInputs:     mesh: an AbstractMesh     sbp: an SBPOperator     eqn: an AbstractSolutionData     opts: the options dictionary     populate_buffer: function with the signature:                      populate_buffer(mesh, sbp, eqn, opts, data::SharedFaceData)                      that populates data.q_send   Inputs/Outputs:     shared_data: vector of SharedFaceData objects representing the parallel                  communication to be done\n\n\nKeyword Arguments:     tag: MPI tag to use for this communication, defaults to TAG_DEFAULT          This tag is typically used by the communication of the solution          variables to other processes.  Other users of this function should          provide their own tag\n\n\nwait: wait for the sends and receives to finish before returning.  This\n      is a debugging option only.  It will kill parallel performance.\n\n\n\n\n#\n\n\nUtils.finishExchangeData\n \n \nFunction\n.\n\n\nThis is the counterpart of exchangeData.  This function finishes the   receives started in exchangeData.\n\n\nThis function (efficiently) waits for a receive to finish and calls   a function to do calculations for on that data. If opts[\"parallel_data\"]   == \"face\", it also permutes the data in the receive buffers to agree   with the ordering of elementL.  For opts[\"parallel_data\"] == \"element\",   users should call SummationByParts.interiorFaceInterpolate to interpolate   the data to the face while ensuring proper permutation.\n\n\nInputs:     mesh: an AbstractMesh     sbp: an SBPOperator     eqn: an AbstractSolutionData     opts: the options dictonary     calc_func: function that does calculations for a set of shared faces                described by a single SharedFaceData.  It must have the signature                calc_func(mesh, sbp, eqn, opts, data::SharedFaceData)\n\n\nInputs/Outputs:     shared_data: vector of SharedFaceData, one for each peer process that                  needs to be communicated with.  By the time calc_func is                  called, the SharedFaceData passed to it has its q_recv field                  populated.  See note above about data permutation.\n\n\n#\n\n\nUtils.TAG_DEFAULT\n \n \nConstant\n.\n\n\nDefault MPI tag used for sending and receiving solution variables.\n\n\n\n\nInternals\n\n\nThese helper functions are used by the functions in \nParallel Data Exchange\n.\n\n\n#\n\n\nUtils.verifyReceiveCommunication\n \n \nFunction\n.\n\n\nUtils.verifyCommunication\n\n\nThis function checks the data provided by the Status object to verify a    communication completed successfully.  The sender's rank and the number of   elements is checked agains the expected sender and the buffer size\n\n\nInputs:     data: a SharedFaceData\n\n\n#\n\n\nUtils.getSendDataFace\n \n \nFunction\n.\n\n\nThis function populates the send buffer from eqn.q for    opts[\"parallle_data\"]  == \"face\"\n\n\nInputs:     mesh: a mesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictonary\n\n\nInputs/Outputs:     data: a SharedFaceData.  data.q_send will be overwritten\n\n\n#\n\n\nUtils.getSendDataElement\n \n \nFunction\n.\n\n\nThis function populates the send buffer from eqn.q for    opts[\"parallle_data\"]  == \"element\"\n\n\nInputs:     mesh: a mesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictonary\n\n\nInputs/Outputs:     data: a SharedFaceData.  data.q_send will be overwritten\n\n\n#\n\n\nUtils.@mpi_master\n \n \nMacro\n.\n\n\nUtils.mpi_master\n\n\nThis macro introduces an if statement that causes the expression to be    executed only if the variable myrank is equal to zero.  myrank must exist   in the scope of the caller\n\n\n#\n\n\nUtils.@time_all\n \n \nMacro\n.\n\n\nUtils.time_all\n\n\nThis macro returns the value produced by the expression as well as    the execution time, the GC time, and the amount of memory allocated", 
            "title": "Parallel Constructs"
        }, 
        {
            "location": "/Utils/parallel/#parallel-constructs-documentations", 
            "text": "These function define the primative operations used by the physics modules to exchange data in parallel. When using these functions, the should not have to make any MPI calls directly, they should all be encapsulated within the provided functions.  TODO: crossref to physics module documentation  The  Types and Basic API  section describes the  SharedFaceData  datatype and the basic functions that operate on it. The  Parallel Data Exchange  section describes the functions used by the physics modules that start and finish parallel parallel communication.", 
            "title": "Parallel Constructs Documentations"
        }, 
        {
            "location": "/Utils/parallel/#types-and-basic-api", 
            "text": "#  Utils.SharedFaceData     Type .  This type holds all the data necessary to perform MPI communication with   a given peer process that shared mesh edges (2D) or faces (3D) with the   current process.  Fields:  peernum: the MPI rank of the peer process\npeeridx: the index of this peer in mesh.peer_parts\nmyrank: MPI rank of the current process\ncomm: MPI communicator used to define the above\n\nq_send: the send buffer, a 3D array of n x m x d.  While these dimensions\n        are arbitrary, there are two commonly used case.  If\n        opts[ parallel_type ] == face, then m is mesh.numNodesPerFace and\n        d is the number of faces shared with peernum.\n        If opts[ parallel_type ] == element, then \n        m = mesh.numNodesPerElement and d is the number of elements that\n        share faces with peernum.\nq_recv: the receive buffer.  Similar to q_send, except the size needs to\n        to be the number of entities on the *remote* process.\n\nsend_waited: has someone called MPI.Wait() on send_req yet?  Some MPI\n             implementations complain if Wait() is called on a Request\n             more than once, so use this field to avoid doing so.\nsend_req: the MPI.Request object for the Send/Isend/whatever other type of\n          Send\nsend_status: the MPI.Status object returned by calling Wait() on send_req\n\nrecv_waited: like send_waited, but for the receive\nrecv_req: like send_req, but for the receive\nrecv_status: like send_status, but for the receive\n\nbndries_local: Vector of Boundaries describing the faces from the local\n               side of the interface\nbndries_remote: Vector of Boundaries describing the facaes from the remote\n                side (see the documentation for PdePumiInterface before\n                using this field)\ninterfaces: Vector of Interfaces describing the faces from both sides (see\n            the documentation for PdePumiInterfaces, particularly the\n            mesh.shared_interfaces field, before using this field  #  Utils.SharedFaceData     Method .  Outer constructor for SharedFaceData.  Inputs:  mesh: a mesh object\npeeridx: the index of a peer in mesh.peer_parts\nq_send: the send buffer\nq_recv: the receive buffer  #  Utils.getSharedFaceData     Method .  This function returns a vector of SharedFaceData objects, one for each   peer processes the current process shares mesh edge (2D) or face (3D) with.   This function is intended to be used by the AbstractSolutionData constructors,   although it can be used to create additional vectors of SharedFaceData   objects.  if opts[\"parallel_data\"] == \"face\", then the send and receive buffers   are numDofPerNode x numNodesPerFace x number of shared faces.  if opts[\"parallel_data\"] == \"element\", the send and receive buffers are     numDofPerNode x numNodesPerElement x number of elements that share the     faces.  Note that the number of elements that share the faces can be     different for the send and receive buffers.  Inputs:  Tsol: element type of the arrays\nmesh: an AbstractMesh object\nsbp: an SBP operator\nopts: the options dictonary  Outputs:  data_vec: Vector{SharedFaceData}.  data_vec[i] corresponds to \n          mesh.peer_parts[i]  #  Base.copy!     Method .  In-place copy for SharedFaceData.  This copies the buffers, but does not   retain the state of the Request and Status fields.  Instead they are   initialized the same as the constructor.  This function may only be called after receiving is complete,   otherwise an exception is thrown.  #  Base.copy     Method .  Copy function for SharedFaceData.  Note that this does  not  retain the   send_req/send_status (and similarly for the recceive) state   of the original object.  Instead, they are initialized the same as the   constructor.  This function may only be called after receiving is complete,   otherwise an exception is thrown.  #  Utils.assertReceivesConsistent     Method .  Like assertSendsConsistent, but for the receives  #  Utils.assertReceivesWaited     Method .  This function verifies all the receives have been waited on for the    supplied SharedFaceData objects  #  Utils.assertSendsConsistent     Method .  Verify either all or none of the sends have been waited on.  Throw an   exception otherwise.  Inputs:  shared_data: Vector of SharedFaceData objects  Output:  val: number of receives that have been waited on  #  Utils.waitAllReceives     Method .  This function is like MPI.Waitall, operating on the recvs of a vector of    SharedFaceData objects  #  Utils.waitAllSends     Method .  This function is like MPI.Waitall, operating on the sends of a vector of    SharedFaceData objects  #  Utils.waitAnyReceive     Method .  Like MPI.WaitAny, but operates on the receives of  a vector of SharedFaceData.   Only the index of the Request that was waited on is returned,    the Status and recv_waited fields of hte SharedFaceData are updated internally", 
            "title": "Types and Basic API"
        }, 
        {
            "location": "/Utils/parallel/#parallel-data-exchange", 
            "text": "The functions in this section are used to start sending data in parallel and finish receiving it. All functions operate on a  Vector  of  SharedFaceData  that define what data to send to which peer processes.  See  Parallel Overview  for a high-level overview of how the code is parallelized.  Sending the data to the other processes is straight-forward.  Receiving it (efficiently) is not. In particular, [ finishExchangeData ] waits to receive data from one peer process, calls a user supplied callback function to do calculations involving the received data, and then waits for the next receive to finish. This is significantly more efficient than waiting for all receives to finish and then doing computations on all the data.  This section describes the API the physics modules use to do parallel  communication.  The  Internals  section describes the helper functions used in the implementation.  #  Utils.startSolutionExchange     Function .  This function is a thin wrapper around exchangeData().  It is used for the   common case of sending and receiving the solution variables to other processes.   It uses eqn.shared_data to do the parallel communication.   eqn.shared_data  must  be passed into the corresponding finishDataExchange   call.  Inputs:     mesh: an AbstractMesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictionary  Keyword arguments:     tag: MPI tag to use for communication, defaults to TAG_DEFAULT     wait: wait for sends and receives to finish before exiting  #  Utils.exchangeData     Function .  This function posts the MPI sends and receives for a vector of SharedFaceData.  It works for both opts[\"parallel_data\"] == \"face\" or \"element\".  The only   difference between these two cases is the populate_buffer() function.  The previous receives using these SharedFaceData objects should have   completed by the time this function is called.  An exception is throw   if this is not the case.  The previous sends are likely to have completed by the time this function   is called, but they are waited on if not.  This function might not perform   well if the previous sends have not completed.   #TODO: fix this using WaitAny  Inputs:     mesh: an AbstractMesh     sbp: an SBPOperator     eqn: an AbstractSolutionData     opts: the options dictionary     populate_buffer: function with the signature:                      populate_buffer(mesh, sbp, eqn, opts, data::SharedFaceData)                      that populates data.q_send   Inputs/Outputs:     shared_data: vector of SharedFaceData objects representing the parallel                  communication to be done  Keyword Arguments:     tag: MPI tag to use for this communication, defaults to TAG_DEFAULT          This tag is typically used by the communication of the solution          variables to other processes.  Other users of this function should          provide their own tag  wait: wait for the sends and receives to finish before returning.  This\n      is a debugging option only.  It will kill parallel performance.  #  Utils.finishExchangeData     Function .  This is the counterpart of exchangeData.  This function finishes the   receives started in exchangeData.  This function (efficiently) waits for a receive to finish and calls   a function to do calculations for on that data. If opts[\"parallel_data\"]   == \"face\", it also permutes the data in the receive buffers to agree   with the ordering of elementL.  For opts[\"parallel_data\"] == \"element\",   users should call SummationByParts.interiorFaceInterpolate to interpolate   the data to the face while ensuring proper permutation.  Inputs:     mesh: an AbstractMesh     sbp: an SBPOperator     eqn: an AbstractSolutionData     opts: the options dictonary     calc_func: function that does calculations for a set of shared faces                described by a single SharedFaceData.  It must have the signature                calc_func(mesh, sbp, eqn, opts, data::SharedFaceData)  Inputs/Outputs:     shared_data: vector of SharedFaceData, one for each peer process that                  needs to be communicated with.  By the time calc_func is                  called, the SharedFaceData passed to it has its q_recv field                  populated.  See note above about data permutation.  #  Utils.TAG_DEFAULT     Constant .  Default MPI tag used for sending and receiving solution variables.", 
            "title": "Parallel Data Exchange"
        }, 
        {
            "location": "/Utils/parallel/#internals", 
            "text": "These helper functions are used by the functions in  Parallel Data Exchange .  #  Utils.verifyReceiveCommunication     Function .  Utils.verifyCommunication  This function checks the data provided by the Status object to verify a    communication completed successfully.  The sender's rank and the number of   elements is checked agains the expected sender and the buffer size  Inputs:     data: a SharedFaceData  #  Utils.getSendDataFace     Function .  This function populates the send buffer from eqn.q for    opts[\"parallle_data\"]  == \"face\"  Inputs:     mesh: a mesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictonary  Inputs/Outputs:     data: a SharedFaceData.  data.q_send will be overwritten  #  Utils.getSendDataElement     Function .  This function populates the send buffer from eqn.q for    opts[\"parallle_data\"]  == \"element\"  Inputs:     mesh: a mesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictonary  Inputs/Outputs:     data: a SharedFaceData.  data.q_send will be overwritten  #  Utils.@mpi_master     Macro .  Utils.mpi_master  This macro introduces an if statement that causes the expression to be    executed only if the variable myrank is equal to zero.  myrank must exist   in the scope of the caller  #  Utils.@time_all     Macro .  Utils.time_all  This macro returns the value produced by the expression as well as    the execution time, the GC time, and the amount of memory allocated", 
            "title": "Internals"
        }, 
        {
            "location": "/Utils/projections/", 
            "text": "Projections documentation\n\n\nThe functions here project the vector of conservative variables back and  forth between x-y-z and n-t-b (normal-tangential-binormal) cordinates.\n\n\n\n\nDetailed Documentation\n\n\n#\n\n\nUtils.calcLength\n \n \nMethod\n.\n\n\nCalculates the length of a vector, using a manually unrolled loop.   Methods are available for 2D and 3D.\n\n\nInputs:\n\n\nparams: an AbstractParamType{Tdim}, used to dispatch to the right method\nnrm: the vector to calculate the length of.  Must have length 2 in 2D\n     and 3 in 3D\n\n\n\n\nOutputs:\n\n\nlength of nrm\n\n\n\n\n#\n\n\nUtils.getProjectionMatrix\n \n \nMethod\n.\n\n\nThis function populates the matrix P that project from x-y-z to n-t-b.   Methods are available for 2D and 3D, determined from the AbstractParamType   object.  This is a somewhat specialized routine in that it only works for   vectors like the state vector of the Euler or Navier-Stokes equations,   where the first and last equations are coordinate system invarient and   only the middle 2 (in 2D) or 3 (in 3D) equations need to be rotated.   Specialized multiplication routines are provied as projectToXY and   projectToNT.\n\n\nInputs:\n\n\nparams:  An AbstractParamType{Tdim}\nnrm: the normal direction in x-y coordinate system.  Must be a unit vector\n\n\n\n\nInputs/Outputs\n\n\nP:  matrix to be populated with projection matrix\n\n\n\n\nAliasing restrictions: none\n\n\n#\n\n\nUtils.projectToNT\n \n \nMethod\n.\n\n\nThis function projects a vector x from x-y coordinates to normal-tangential   (n-t) coordinates, where A is a projection matrix from x-y to n-t, obtained   from getProjectionMatrix.  This function is a specialized matrix-vector   multiplication routine and only works for matrices with the particular   sparsity pattern created by getProjectionMatrix.   Methods are available for 2D and 3D\n\n\nInputs:\n\n\nparams: an AbstractParamType{{Tdim} used to dispatch to the 2D or 3D\n        method\nP: the projection matrix\nx: vector to be projected\n\n\n\n\nInputs/Outputs:\n\n\nb: the result of the projection\n\n\n\n\nAliasing restrictions: x and b cannot alias\n\n\n#\n\n\nUtils.projectToXY\n \n \nMethod\n.\n\n\nThis function is similar to projectToNT, except it project from n-t   to x-y.  Note that P is still the projection matrix from getProjectionMatrix   that projects from x-y to n-t.\n\n\n#\n\n\nUtils.getBinormalVector\n \n \nMethod\n.\n\n\nThis function computes a vector normal to the 2 supplied vectors and   returns the components.\n\n\nInputs:\n\n\nn1, n2, n3: the components of the first vector\nt1, t2, t3: the components of the second vector\n\n\n\n\nOutputs:\n\n\nb1, b2, b3: the components of the binormal vector\n\n\n\n\nAliasing restrictions: none\n\n\n#\n\n\nUtils.getOrthogonalVector\n \n \nMethod\n.\n\n\nThis function generates a unit vector orthogonal to the input vector nrm and    returns its components.  Methods are availble for 2D and 3D\n\n\nInputs:\n\n\nparams: an AbstractParamType, used to dispatch to the 2D or 3D method\nnrm: the input vector\n\n\n\n\nOutputs:\n\n\nt1, t2, (and t3 in 3D): the components of the unit vector orthogonal to\n                        nrm\n\n\n\n\nAliasing restrictions: none", 
            "title": "Projections"
        }, 
        {
            "location": "/Utils/projections/#projections-documentation", 
            "text": "The functions here project the vector of conservative variables back and  forth between x-y-z and n-t-b (normal-tangential-binormal) cordinates.", 
            "title": "Projections documentation"
        }, 
        {
            "location": "/Utils/projections/#detailed-documentation", 
            "text": "#  Utils.calcLength     Method .  Calculates the length of a vector, using a manually unrolled loop.   Methods are available for 2D and 3D.  Inputs:  params: an AbstractParamType{Tdim}, used to dispatch to the right method\nnrm: the vector to calculate the length of.  Must have length 2 in 2D\n     and 3 in 3D  Outputs:  length of nrm  #  Utils.getProjectionMatrix     Method .  This function populates the matrix P that project from x-y-z to n-t-b.   Methods are available for 2D and 3D, determined from the AbstractParamType   object.  This is a somewhat specialized routine in that it only works for   vectors like the state vector of the Euler or Navier-Stokes equations,   where the first and last equations are coordinate system invarient and   only the middle 2 (in 2D) or 3 (in 3D) equations need to be rotated.   Specialized multiplication routines are provied as projectToXY and   projectToNT.  Inputs:  params:  An AbstractParamType{Tdim}\nnrm: the normal direction in x-y coordinate system.  Must be a unit vector  Inputs/Outputs  P:  matrix to be populated with projection matrix  Aliasing restrictions: none  #  Utils.projectToNT     Method .  This function projects a vector x from x-y coordinates to normal-tangential   (n-t) coordinates, where A is a projection matrix from x-y to n-t, obtained   from getProjectionMatrix.  This function is a specialized matrix-vector   multiplication routine and only works for matrices with the particular   sparsity pattern created by getProjectionMatrix.   Methods are available for 2D and 3D  Inputs:  params: an AbstractParamType{{Tdim} used to dispatch to the 2D or 3D\n        method\nP: the projection matrix\nx: vector to be projected  Inputs/Outputs:  b: the result of the projection  Aliasing restrictions: x and b cannot alias  #  Utils.projectToXY     Method .  This function is similar to projectToNT, except it project from n-t   to x-y.  Note that P is still the projection matrix from getProjectionMatrix   that projects from x-y to n-t.  #  Utils.getBinormalVector     Method .  This function computes a vector normal to the 2 supplied vectors and   returns the components.  Inputs:  n1, n2, n3: the components of the first vector\nt1, t2, t3: the components of the second vector  Outputs:  b1, b2, b3: the components of the binormal vector  Aliasing restrictions: none  #  Utils.getOrthogonalVector     Method .  This function generates a unit vector orthogonal to the input vector nrm and    returns its components.  Methods are availble for 2D and 3D  Inputs:  params: an AbstractParamType, used to dispatch to the 2D or 3D method\nnrm: the input vector  Outputs:  t1, t2, (and t3 in 3D): the components of the unit vector orthogonal to\n                        nrm  Aliasing restrictions: none", 
            "title": "Detailed Documentation"
        }, 
        {
            "location": "/Utils/logging/", 
            "text": "Logging Documentation\n\n\nThe functions define here assist with debugging by logging some results to disk.\n\n\n\n\nDetailed Documentation\n\n\n#\n\n\nUtils.sharedFaceLogging\n \n \nMethod\n.\n\n\nUtils.sharedFaceLogging\n\n\nThis function writes files for the function that evalutes the shared face   integrals.  This function should only be called in debug mode.\n\n\nIf opts[\"writeqface\"] is true,  writes the q values at the face to a file    q_sharedface_i_myrank.dat, where i is the peer process index (not MPI rank)   and myrank is the MPI rank of the current process. \n\n\nIf opts[\"write_fluxface\"] is true, it writes eqn.flux_sharedface to a file   flux_sharedface_i_myrank.dat\n\n\nInputs:     mesh     sbp     eqn: and AbstractSolutionData     opts: options dictonary     data: SharedFaceData object     qL_arr: an array holding solution values at face nodes on the              left side of the interface,  numDofPerNode x numfacenodes x              numsharedfaces on this partition boundary     qR_arr: solution values at face nodes on the right side of the interface.             same shape as qL_arr\n\n\nalso, the eqn.flux_shared is used to write the face flux.  It is the same   shape as qL_arr\n\n\nAliasing restrictions: qL_arr, qR_arr, and eqn.flux_sharedface must not alias.", 
            "title": "Logging"
        }, 
        {
            "location": "/Utils/logging/#logging-documentation", 
            "text": "The functions define here assist with debugging by logging some results to disk.", 
            "title": "Logging Documentation"
        }, 
        {
            "location": "/Utils/logging/#detailed-documentation", 
            "text": "#  Utils.sharedFaceLogging     Method .  Utils.sharedFaceLogging  This function writes files for the function that evalutes the shared face   integrals.  This function should only be called in debug mode.  If opts[\"writeqface\"] is true,  writes the q values at the face to a file    q_sharedface_i_myrank.dat, where i is the peer process index (not MPI rank)   and myrank is the MPI rank of the current process.   If opts[\"write_fluxface\"] is true, it writes eqn.flux_sharedface to a file   flux_sharedface_i_myrank.dat  Inputs:     mesh     sbp     eqn: and AbstractSolutionData     opts: options dictonary     data: SharedFaceData object     qL_arr: an array holding solution values at face nodes on the              left side of the interface,  numDofPerNode x numfacenodes x              numsharedfaces on this partition boundary     qR_arr: solution values at face nodes on the right side of the interface.             same shape as qL_arr  also, the eqn.flux_shared is used to write the face flux.  It is the same   shape as qL_arr  Aliasing restrictions: qL_arr, qR_arr, and eqn.flux_sharedface must not alias.", 
            "title": "Detailed Documentation"
        }, 
        {
            "location": "/Utils/io/", 
            "text": "Input/Output\n\n\nThe functions and types defined here facilitate writing to \nSTDOUT\n and \nSTDERR\n as well as files. In particular, performance tests have shown that buffering is important when running in parallel. To this end, the \nBufferedIO\n type is introduced that stores output in an in-memory buffer before writing to an underlying stream. This can create some difficulty when debuging, because output written to a buffered stream is not immediately written to the underlying stream. In cases where precise control of output is needed, users should call \nflush\n to make sure all output is written to the underlying stream\n\n\n\n\nDetailed Documentation\n\n\n#\n\n\nUtils.BSTDERR\n \n \nConstant\n.\n\n\nBuffered version of STDERR.  This should \nalways\n be used instead of STDERR\n\n\n#\n\n\nUtils.BSTDOUT\n \n \nConstant\n.\n\n\nBuffered version of STDOUT.  This should \nalways\n be used instead of STDOUT\n\n\n#\n\n\nUtils.BufferedIO\n \n \nType\n.\n\n\nUtils.BufferedIO\n\n\nThis type provides a means to buffer IO in memory before writing it to a file.   Data written to the object is stored in the IOBuffer until flush() is called,    when the buffer is (efficiently) dumped into the file\n\n\n#\n\n\nUtils.BufferedIO\n \n \nType\n.\n\n\nUtils.BufferedIO\n\n\nConstructor for BufferedIO type.  Takes an IOStream and creates an IOBuffer.   If no IOStream is given, a dummy stream is created.  If a dummy stream is   used, flush must never be called on the returned BufferedIO object\n\n\nInputs:\n\n\nf: an IOStream object, defaults to a dummy stream\n\n\n\n\nOutputs:\n\n\na BufferedIO object\n\n\n\n\n#\n\n\nUtils.BufferedIO\n \n \nType\n.\n\n\nAlternative constructor for BufferedIO, emulating the open() function.   This function creates the underlying file using open() and then creates   a BufferedIO around it.\n\n\nInputs:\n\n\nfname: AbstractString, name of file to open\nmode: file open mode, see documentation of open(), defaults to append\n\n\n\n\nOutputs:\n\n\na BufferedIO object\n\n\n\n\n#\n\n\nBase.close\n \n \nMethod\n.\n\n\nBase\n function \nclose\n extended for BufferedIO\n\n\n#\n\n\nBase.flush\n \n \nMethod\n.\n\n\nBase\n function \nflush\n extended for BufferedIO", 
            "title": "Input/Output"
        }, 
        {
            "location": "/Utils/io/#inputoutput", 
            "text": "The functions and types defined here facilitate writing to  STDOUT  and  STDERR  as well as files. In particular, performance tests have shown that buffering is important when running in parallel. To this end, the  BufferedIO  type is introduced that stores output in an in-memory buffer before writing to an underlying stream. This can create some difficulty when debuging, because output written to a buffered stream is not immediately written to the underlying stream. In cases where precise control of output is needed, users should call  flush  to make sure all output is written to the underlying stream", 
            "title": "Input/Output"
        }, 
        {
            "location": "/Utils/io/#detailed-documentation", 
            "text": "#  Utils.BSTDERR     Constant .  Buffered version of STDERR.  This should  always  be used instead of STDERR  #  Utils.BSTDOUT     Constant .  Buffered version of STDOUT.  This should  always  be used instead of STDOUT  #  Utils.BufferedIO     Type .  Utils.BufferedIO  This type provides a means to buffer IO in memory before writing it to a file.   Data written to the object is stored in the IOBuffer until flush() is called,    when the buffer is (efficiently) dumped into the file  #  Utils.BufferedIO     Type .  Utils.BufferedIO  Constructor for BufferedIO type.  Takes an IOStream and creates an IOBuffer.   If no IOStream is given, a dummy stream is created.  If a dummy stream is   used, flush must never be called on the returned BufferedIO object  Inputs:  f: an IOStream object, defaults to a dummy stream  Outputs:  a BufferedIO object  #  Utils.BufferedIO     Type .  Alternative constructor for BufferedIO, emulating the open() function.   This function creates the underlying file using open() and then creates   a BufferedIO around it.  Inputs:  fname: AbstractString, name of file to open\nmode: file open mode, see documentation of open(), defaults to append  Outputs:  a BufferedIO object  #  Base.close     Method .  Base  function  close  extended for BufferedIO  #  Base.flush     Method .  Base  function  flush  extended for BufferedIO", 
            "title": "Detailed Documentation"
        }
    ]
}
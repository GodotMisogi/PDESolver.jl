<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Constructs · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="Utils.html">Main</a></li><li class="current"><a class="toctext" href="parallel.html">Parallel Constructs</a><ul class="internal"><li><a class="toctext" href="#Types-and-Basic-API-1">Types and Basic API</a></li><li><a class="toctext" href="#Parallel-Data-Exchange-1">Parallel Data Exchange</a></li></ul></li><li><a class="toctext" href="projections.html">Projections</a></li><li><a class="toctext" href="logging.html">Logging</a></li><li><a class="toctext" href="io.html">Input/Output</a></li><li><a class="toctext" href="checkpoint.html">Checkpointing</a></li><li><a class="toctext" href="misc.html">Misccellaneous</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Utils</li><li><a href="parallel.html">Parallel Constructs</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/6cd5bf9fae313f05b0c64c3424dbf0f6bd2b0ed7/docs/src/Utils/parallel.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Parallel-Constructs-Documentations-1" href="#Parallel-Constructs-Documentations-1">Parallel Constructs Documentations</a></h1><p>These function define the primative operations used by the physics modules to exchange data in parallel. When using these functions, the should not have to make any MPI calls directly, they should all be encapsulated within the provided functions.</p><p>TODO: crossref to physics module documentation</p><p>The <a href="parallel.html#Types-and-Basic-API-1">Types and Basic API</a> section describes the <a href="parallel.html#Utils.SharedFaceData"><code>SharedFaceData</code></a> datatype and the basic functions that operate on it. The <a href="parallel.html#Parallel-Data-Exchange-1">Parallel Data Exchange</a> section describes the functions used by the physics modules that start and finish parallel parallel communication.</p><h2><a class="nav-anchor" id="Types-and-Basic-API-1" href="#Types-and-Basic-API-1">Types and Basic API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.SharedFaceData" href="#Utils.SharedFaceData"><code>Utils.SharedFaceData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type holds all the data necessary to perform MPI communication with   a given peer process that shared mesh edges (2D) or faces (3D) with the   current process.</p><p>Fields:</p><pre><code class="language-none">peernum: the MPI rank of the peer process
peeridx: the index of this peer in mesh.peer_parts
myrank: MPI rank of the current process
comm: MPI communicator used to define the above

q_send: the send buffer, a 3D array of n x m x d.  While these dimensions
        are arbitrary, there are two commonly used case.  If
        opts[&quot;parallel_type&quot;] == face, then m is mesh.numNodesPerFace and
        d is the number of faces shared with peernum.
        If opts[&quot;parallel_type&quot;] == element, then 
        m = mesh.numNodesPerElement and d is the number of elements that
        share faces with peernum.
q_recv: the receive buffer.  Similar to q_send, except the size needs to
        to be the number of entities on the *remote* process.

send_waited: has someone called MPI.Wait() on send_req yet?  Some MPI
             implementations complain if Wait() is called on a Request
             more than once, so use this field to avoid doing so.
send_req: the MPI.Request object for the Send/Isend/whatever other type of
          Send
send_status: the MPI.Status object returned by calling Wait() on send_req

recv_waited: like send_waited, but for the receive
recv_req: like send_req, but for the receive
recv_status: like send_status, but for the receive

bndries_local: Vector of Boundaries describing the faces from the local
               side of the interface
bndries_remote: Vector of Boundaries describing the facaes from the remote
                side (see the documentation for PdePumiInterface before
                using this field)
interfaces: Vector of Interfaces describing the faces from both sides (see
            the documentation for PdePumiInterfaces, particularly the
            mesh.shared_interfaces field, before using this field</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.SharedFaceData-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Int64,Array{T,3},Array{T,3}}" href="#Utils.SharedFaceData-Tuple{ODLCommonTools.AbstractMesh{Tmsh},Int64,Array{T,3},Array{T,3}}"><code>Utils.SharedFaceData</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Outer constructor for SharedFaceData.</p><p>Inputs:</p><pre><code class="language-none">mesh: a mesh object
peeridx: the index of a peer in mesh.peer_parts
q_send: the send buffer
q_recv: the receive buffer</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getSharedFaceData-Tuple{Type{Tsol},ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},Any}" href="#Utils.getSharedFaceData-Tuple{Type{Tsol},ODLCommonTools.AbstractMesh{Tmsh},SummationByParts.AbstractSBP{T<:Number},Any}"><code>Utils.getSharedFaceData</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function returns a vector of SharedFaceData objects, one for each   peer processes the current process shares mesh edge (2D) or face (3D) with.   This function is intended to be used by the AbstractSolutionData constructors,   although it can be used to create additional vectors of SharedFaceData   objects.</p><p>if opts[&quot;parallel_data&quot;] == &quot;face&quot;, then the send and receive buffers   are numDofPerNode x numNodesPerFace x number of shared faces.</p><p>if opts[&quot;parallel_data&quot;] == &quot;element&quot;, the send and receive buffers are     numDofPerNode x numNodesPerElement x number of elements that share the     faces.  Note that the number of elements that share the faces can be     different for the send and receive buffers.</p><p>Inputs:</p><pre><code class="language-none">Tsol: element type of the arrays
mesh: an AbstractMesh object
sbp: an SBP operator
opts: the options dictonary</code></pre><p>Outputs:</p><pre><code class="language-none">data_vec: Vector{SharedFaceData}.  data_vec[i] corresponds to 
          mesh.peer_parts[i]</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy!-Tuple{Utils.SharedFaceData{T},Utils.SharedFaceData{T}}" href="#Base.copy!-Tuple{Utils.SharedFaceData{T},Utils.SharedFaceData{T}}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span>.</div><div><p>In-place copy for SharedFaceData.  This copies the buffers, but does not   retain the state of the Request and Status fields.  Instead they are   initialized the same as the constructor.</p><p>This function may only be called after receiving is complete,   otherwise an exception is thrown.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{Utils.SharedFaceData{T}}" href="#Base.copy-Tuple{Utils.SharedFaceData{T}}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Copy function for SharedFaceData.  Note that this does <em>not</em> retain the   send_req/send_status (and similarly for the recceive) state   of the original object.  Instead, they are initialized the same as the   constructor.</p><p>This function may only be called after receiving is complete,   otherwise an exception is thrown.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.assertReceivesConsistent-Tuple{Array{Utils.SharedFaceData{T},1}}" href="#Utils.assertReceivesConsistent-Tuple{Array{Utils.SharedFaceData{T},1}}"><code>Utils.assertReceivesConsistent</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like assertSendsConsistent, but for the receives</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.assertReceivesWaited-Tuple{Array{Utils.SharedFaceData{T},1}}" href="#Utils.assertReceivesWaited-Tuple{Array{Utils.SharedFaceData{T},1}}"><code>Utils.assertReceivesWaited</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function verifies all the receives have been waited on for the    supplied SharedFaceData objects</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.assertSendsConsistent-Tuple{Array{Utils.SharedFaceData{T},1}}" href="#Utils.assertSendsConsistent-Tuple{Array{Utils.SharedFaceData{T},1}}"><code>Utils.assertSendsConsistent</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Verify either all or none of the sends have been waited on.  Throw an   exception otherwise.</p><p>Inputs:</p><pre><code class="language-none">shared_data: Vector of SharedFaceData objects</code></pre><p>Output:</p><pre><code class="language-none">val: number of receives that have been waited on</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.waitAllReceives-Tuple{Array{Utils.SharedFaceData{T},1}}" href="#Utils.waitAllReceives-Tuple{Array{Utils.SharedFaceData{T},1}}"><code>Utils.waitAllReceives</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is like MPI.Waitall, operating on the recvs of a vector of    SharedFaceData objects</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.waitAllSends-Tuple{Array{Utils.SharedFaceData{T},1}}" href="#Utils.waitAllSends-Tuple{Array{Utils.SharedFaceData{T},1}}"><code>Utils.waitAllSends</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This function is like MPI.Waitall, operating on the sends of a vector of    SharedFaceData objects</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.waitAnyReceive-Tuple{Array{Utils.SharedFaceData{T},1}}" href="#Utils.waitAnyReceive-Tuple{Array{Utils.SharedFaceData{T},1}}"><code>Utils.waitAnyReceive</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Like MPI.WaitAny, but operates on the receives of  a vector of SharedFaceData.   Only the index of the Request that was waited on is returned,    the Status and recv_waited fields of hte SharedFaceData are updated internally</p></div></section><h2><a class="nav-anchor" id="Parallel-Data-Exchange-1" href="#Parallel-Data-Exchange-1">Parallel Data Exchange</a></h2><p>The functions in this section are used to start sending data in parallel and finish receiving it. All functions operate on a <code>Vector</code> of <a href="parallel.html#Utils.SharedFaceData"><code>SharedFaceData</code></a> that define what data to send to which peer processes.  See <a href="../parallel.html#Parallel-Overview-1">Parallel Overview</a> for a high-level overview of how the code is parallelized.</p><p>Sending the data to the other processes is straight-forward.  Receiving it (efficiently) is not. In particular, [<code>finishExchangeData</code>] waits to receive data from one peer process, calls a user supplied callback function to do calculations involving the received data, and then waits for the next receive to finish. This is significantly more efficient than waiting for all receives to finish and then doing computations on all the data.</p><p>This section describes the API the physics modules use to do parallel  communication.  The <a href="parallel.html#utils_parallel_internals-1">Internals</a> section describes the helper functions used in the implementation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.startSolutionExchange" href="#Utils.startSolutionExchange"><code>Utils.startSolutionExchange</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function is a thin wrapper around exchangeData().  It is used for the   common case of sending and receiving the solution variables to other processes.   It uses eqn.shared_data to do the parallel communication.   eqn.shared_data <em>must</em> be passed into the corresponding finishDataExchange   call.</p><p>Inputs:     mesh: an AbstractMesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictionary</p><p>Keyword arguments:     tag: MPI tag to use for communication, defaults to TAG_DEFAULT     wait: wait for sends and receives to finish before exiting</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.exchangeData" href="#Utils.exchangeData"><code>Utils.exchangeData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function posts the MPI sends and receives for a vector of SharedFaceData.  It works for both opts[&quot;parallel_data&quot;] == &quot;face&quot; or &quot;element&quot;.  The only   difference between these two cases is the populate_buffer() function.</p><p>The previous receives using these SharedFaceData objects should have   completed by the time this function is called.  An exception is throw   if this is not the case.</p><p>The previous sends are likely to have completed by the time this function   is called, but they are waited on if not.  This function might not perform   well if the previous sends have not completed.   #TODO: fix this using WaitAny</p><p>Inputs:     mesh: an AbstractMesh     sbp: an SBPOperator     eqn: an AbstractSolutionData     opts: the options dictionary     populate_buffer: function with the signature:                      populate_buffer(mesh, sbp, eqn, opts, data::SharedFaceData)                      that populates data.q_send   Inputs/Outputs:     shared_data: vector of SharedFaceData objects representing the parallel                  communication to be done</p><p>Keyword Arguments:     tag: MPI tag to use for this communication, defaults to TAG_DEFAULT          This tag is typically used by the communication of the solution          variables to other processes.  Other users of this function should          provide their own tag</p><pre><code class="language-none">wait: wait for the sends and receives to finish before returning.  This
      is a debugging option only.  It will kill parallel performance.</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.finishExchangeData" href="#Utils.finishExchangeData"><code>Utils.finishExchangeData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This is the counterpart of exchangeData.  This function finishes the   receives started in exchangeData.</p><p>This function (efficiently) waits for a receive to finish and calls   a function to do calculations for on that data. If opts[&quot;parallel_data&quot;]   == &quot;face&quot;, it also permutes the data in the receive buffers to agree   with the ordering of elementL.  For opts[&quot;parallel_data&quot;] == &quot;element&quot;,   users should call SummationByParts.interiorFaceInterpolate to interpolate   the data to the face while ensuring proper permutation.</p><p>Inputs:     mesh: an AbstractMesh     sbp: an SBPOperator     eqn: an AbstractSolutionData     opts: the options dictonary     calc_func: function that does calculations for a set of shared faces                described by a single SharedFaceData.  It must have the signature                calc_func(mesh, sbp, eqn, opts, data::SharedFaceData)</p><p>Inputs/Outputs:     shared_data: vector of SharedFaceData, one for each peer process that                  needs to be communicated with.  By the time calc_func is                  called, the SharedFaceData passed to it has its q_recv field                  populated.  See note above about data permutation.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.TAG_DEFAULT" href="#Utils.TAG_DEFAULT"><code>Utils.TAG_DEFAULT</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Default MPI tag used for sending and receiving solution variables.</p></div></section><h3><a class="nav-anchor" id="utils_parallel_internals-1" href="#utils_parallel_internals-1">Internals</a></h3><p>These helper functions are used by the functions in <a href="parallel.html#Parallel-Data-Exchange-1">Parallel Data Exchange</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.verifyReceiveCommunication" href="#Utils.verifyReceiveCommunication"><code>Utils.verifyReceiveCommunication</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Utils.verifyCommunication</strong></p><p>This function checks the data provided by the Status object to verify a    communication completed successfully.  The sender&#39;s rank and the number of   elements is checked agains the expected sender and the buffer size</p><p>Inputs:     data: a SharedFaceData</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getSendDataFace" href="#Utils.getSendDataFace"><code>Utils.getSendDataFace</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function populates the send buffer from eqn.q for    opts[&quot;parallle_data&quot;]  == &quot;face&quot;</p><p>Inputs:     mesh: a mesh     sbp: an SBP operator     eqn: an AbstractSolutionData     opts: options dictonary</p><p>Inputs/Outputs:     data: a SharedFaceData.  data.q_send will be overwritten</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getSendDataElement" href="#Utils.getSendDataElement"><code>Utils.getSendDataElement</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function populates the send buffer from eqn.q for    opts[&quot;parallle_data&quot;]  == &quot;element&quot;</p><p>Inputs:</p><pre><code class="language-none">mesh: a mesh
sbp: an SBP operator
eqn: an AbstractSolutionData
opts: options dictonary</code></pre><p>Inputs/Outputs:</p><pre><code class="language-none">data: a SharedFaceData.  data.q_send will be overwritten</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.@mpi_master" href="#Utils.@mpi_master"><code>Utils.@mpi_master</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><strong>Utils.mpi_master</strong></p><p>This macro introduces an if statement that causes the expression to be    executed only if the variable myrank is equal to zero.  myrank must exist   in the scope of the caller</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.@time_all" href="#Utils.@time_all"><code>Utils.@time_all</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><strong>Utils.time_all</strong></p><p>This macro returns the value produced by the expression as well as    the execution time, the GC time, and the amount of memory allocated</p></div></section><footer><hr/><a class="previous" href="Utils.html"><span class="direction">Previous</span><span class="title">Main</span></a><a class="next" href="projections.html"><span class="direction">Next</span><span class="title">Projections</span></a></footer></article></body></html>

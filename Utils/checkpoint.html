<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Checkpointing · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="Utils.html">Main</a></li><li><a class="toctext" href="parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="projections.html">Projections</a></li><li><a class="toctext" href="logging.html">Logging</a></li><li><a class="toctext" href="io.html">Input/Output</a></li><li class="current"><a class="toctext" href="checkpoint.html">Checkpointing</a><ul class="internal"><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Internal-Functions-1">Internal Functions</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Utils</li><li><a href="checkpoint.html">Checkpointing</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/3cd40b12c60e956b9f60cdebb6548a91433e2fd4/docs/src/Utils/checkpoint.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Checkpointing-1" href="#Checkpointing-1">Checkpointing</a></h1><p>Checkpointing has two use cases: saving the state of the solver to be loaded later (for example, in unsteady adjoint calculations), and to restart the solver after a crash. This checkpointing functionality described here is useful for both of these functions. Its purpose is to provide an interface for writing the current state to a file that can be read back later. As long as at least 2 checkpoints are saved, the implementation guarantees that at least one checkpoint is loadable at any time, even if the code is terminated while writing a checkpoint.</p><p>TODO: write a little how-to</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.Checkpointer" href="#Utils.Checkpointer"><code>Utils.Checkpointer</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type keeps track of which checkpoints are in use and has an API   for loading and saving checkpoints</p><p>The fields of the type should <em>never</em> be directly accessed.  Use the API   instead.</p><p>Every commit must be in its own directory.</p><p>Checkpointing has two uses: loading a previous state and restarting.   The first one is rather easy, all that needs to happen is the solution   variables get loaded.  Restarting is more involved because all the local   data of the NonlinearSolver that was running needs to be stored and then   loaded again in a new session.</p><p><strong>Fields</strong></p><ul><li>ncheckpoints: total number of checkpoints</li><li>paths: absolute paths to the checkpoints (array of strings)</li><li>status: status of each checkpoint (used or free), (array of Ints)</li><li>history: list of checkpoints from most recently used to least recently               used, unused entries set to -1</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.Checkpointer-Tuple{Integer,ASCIIString}" href="#Utils.Checkpointer-Tuple{Integer,ASCIIString}"><code>Utils.Checkpointer</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Constructs a Checkpointer with a given number of checkpoints.</p><p>The checkpoints are put into directories called &quot;checkpoint<em>&quot;, where the   &quot;</em>&quot; is replaced by the index of the checkpoint (from 1 to ncheckpoints).   This constructor does not error if the directories already exist, however   any data in the checkpoints may be overwritten.</p><p><strong>Inputs</strong></p><ul><li>ncheckpoints: number of checkpoints, defaults to 2.  Using fewer than                    2 is not recommended (there will be a moment in time during                    which the old checkpoint has been partially overwritten but                    the new checkpoint is not complete yet)</li></ul><ul><li>prefix: added to directory names (with an underscore added in-between).               Defaults to empty string. This is useful if there are multiple               sets of checkpoints (and therefore multiple Checkpointer objects).</li></ul><p><strong>Outputs</strong></p><ul><li>a Checkpointer object, fully initialized</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.Checkpointer-Tuple{Dict{K,V}}" href="#Utils.Checkpointer-Tuple{Dict{K,V}}"><code>Utils.Checkpointer</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This constructor loads a Checkpointer object from a file.  This should   be used for restarting.  Do <em>not</em> use the other constructor for restarting.   It will load the most recently written checkpoint that is complete (an   important distinction if the code was killed in the middle of writing   a checkpoint)</p><p><strong>Inputs</strong></p><ul><li>opts: the options dictionary.  </li></ul><p><strong>Outputs</strong></p><ul><li>a Checkpointer object, fully initialized and aware of which checkpoints      are in use and which are free</li></ul><p>This function only loads the Checkpointer from the checkpoint.   See <a href="checkpoint.html#Utils.loadLastCheckpoint"><code>loadLastCheckpoint</code></a> and <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a> to   load the rest of checkpoint data.   The checkpoint that was loaded can be accessed via <a href="checkpoint.html#Utils.getLastCheckpoint"><code>getLastCheckpoint</code></a></p><p>Implementation notes:</p><pre><code class="language-none">Uses 4 keys in the options dictionary:

  * &quot;writing checkpoint&quot;: index of checkpoint that might be complete
  * &quot;writing_checkpoint_path&quot;: absolute path of checkpoint
  * &quot;most_recent_checkpoint&quot;: index of checkpoint that is definitely
                              complete, but might be older than the above
  * &quot;most_recent_checkpoint_path&quot;: absolute path of checkpoint

This system ensure it is possible to restart even if the code is
killed in the middle of writing a checkpoint.

The Checkpointer object is the same on all processes.</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{Utils.Checkpointer}" href="#Base.copy-Tuple{Utils.Checkpointer}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Recursively copies all fields to make a new Checkpointer object.   Note that changes to one Checkpointer object will not affect the other   (ie. the record of which checkpoints are used and which are not).   This could easily lead to corrupting a checkpoint.   For this reason, this function should rarely be used.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy!-Tuple{Utils.Checkpointer,Utils.Checkpointer}" href="#Base.copy!-Tuple{Utils.Checkpointer,Utils.Checkpointer}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">copy!(dest, src)</code></pre><p>Copy all elements from collection <code>src</code> to array <code>dest</code>. Returns <code>dest</code>.</p></div><div><p>2 argument version of copy().  See that function for details.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.AbstractCheckpointData" href="#Utils.AbstractCheckpointData"><code>Utils.AbstractCheckpointData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Every function that wants to checkpoint must implement an   AbstractCheckpointData containing all the data that needs to be loaded   when the code restarts.  The values in the AbstractSolutionData can be   different for each MPI process.</p><p>This type must contain only &quot;julia&quot; data, ie. objects that are managed   by Julia and have deterministic values.  No pointers, MPI communicators etc.</p><p>File IO is expensive, so include only as much data as needed in the   AbstractCheckpointData.  Anything that can be recalculated should be.</p><p>Generally, only the outermost function (ie. the time stepper or the   nonlinear solver for steady problems) will need to checkpoint.</p><p>There are no required fields for this type</p></div></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><p>These function provide the basic operations required for checkpointing</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.saveNextFreeCheckpoint" href="#Utils.saveNextFreeCheckpoint"><code>Utils.saveNextFreeCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function saves to the next free checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>mesh: an AbstractMesh</li><li>sbp: an SBP operator</li><li>eqn: an AbstractSolutionData object</li><li>checkpoint_data: the users AbstractCheckpointData implementation</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>opts: the options dictionary</li></ul><p><strong>Outputs</strong></p><ul><li>checkpoint: the index of the checkpoint saved.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.loadLastCheckpoint" href="#Utils.loadLastCheckpoint"><code>Utils.loadLastCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function loads the most recently saved checkpoint.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the CheckPointer object</li><li>mesh: an AbstractMesh</li><li>sbp: an SBP operator</li><li>opts: the options dictionary</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>eqn: an AbstractSolutionData object</li></ul><p><strong>Outputs</strong></p><ul><li>the checkpoint index that was loaded</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.readCheckpointData" href="#Utils.readCheckpointData"><code>Utils.readCheckpointData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function reads an object of type AbstractCheckpointData from a file   and reuturns the object.  This is type unstable, so every AbstractSolutionData   implementation should create a constructor that calls this function and   uses a type assertion to specify that the object must be of their concrete   type.</p><p><strong>Inputs</strong></p><ul><li>chkpointer: a Checkpointer</li><li>chkpoint: the index of hte checkpoint</li><li>comm_rank: the MPI rank of this process</li></ul><p><strong>Outputs</strong></p><ul><li>the <a href="checkpoint.html#Utils.AbstractCheckpointData"><code>AbstractCheckpointData</code></a> loaded from the checkpoint</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.countFreeCheckpoints" href="#Utils.countFreeCheckpoints"><code>Utils.countFreeCheckpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the number of free checkpoints</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpoint object</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getNextFreeCheckpoint" href="#Utils.getNextFreeCheckpoint"><code>Utils.getNextFreeCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the index of the next free checkpoint,  or 0 if   there are no free checkpoints</p><p><strong>Input</strong></p><ul><li>checkpointer: a Checkpointer</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getLastCheckpoint" href="#Utils.getLastCheckpoint"><code>Utils.getLastCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the index of the most recently written checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li></ul><p><strong>Outputs</strong></p><ul><li>the index of the most recently saved checkpoint</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getOldestCheckpoint" href="#Utils.getOldestCheckpoint"><code>Utils.getOldestCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Get the least recently written checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer</li></ul><p><strong>Outputs</strong></p><ul><li>the index of the least recently written checkpoint</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.freeOldestCheckpoint" href="#Utils.freeOldestCheckpoint"><code>Utils.freeOldestCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Frees the least recently written checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer</li></ul><p><strong>Outputs</strong></p><ul><li>returns the checkpoint freed</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.freeCheckpoint" href="#Utils.freeCheckpoint"><code>Utils.freeCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function frees a checkpoint (marks it as available to be overwritten)   Unlike certain algorithms that use free lists (cough, cough, malloc)   freeing an already free checkpoint is allowed.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the index of the checkpoint to free   The user must explictly free checkpoints</li></ul></div></section><h2><a class="nav-anchor" id="Internal-Functions-1" href="#Internal-Functions-1">Internal Functions</a></h2><p>The internal functions used for checkpointing are documented here. Users should not call these functions directly.  Improper use can cause checkpoint corruption.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.writeCheckpointer" href="#Utils.writeCheckpointer"><code>Utils.writeCheckpointer</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Call on master process only</p><p>Does <em>not</em> check if the checkpoint is already used (for reading the   state back after restart, this checkpoint should already be marked as   used)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.saveCheckpoint" href="#Utils.saveCheckpoint"><code>Utils.saveCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Save to a specified checkpoint.  Throw error if checkpoint is not free.   Users should not generally call this function directly.  Instead, they   should prefer <a href="checkpoint.html#Utils.saveNextFreeCheckpoint"><code>saveNextFreeCheckpoint</code></a>.</p><p>This function automatically saves eqn.q_vec and the checkpointer to   a file.  Any additional data should be in checkpoint_data.</p><p>Note: mesh adaptation is not compatable with checkpointing   #TODO; add a field to the mesh to record that it has been modified</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the CheckPointer</li><li>checkpoint: the index of the checkpoint</li><li>mesh: an AbstractMesh object</li><li>sbp: SBP operator</li><li>eqn: an AbstractSolutionData</li><li>checkpoint_data: an AbstractCheckpointData.  This is the random bag                       of data the user needs saved.</li></ul><p>**Inputs/Outputs*</p><pre><code class="language-none">* opts: options dictionary</code></pre><p>Implementation Notes:</p><p>Uses options dictionary keys described by <a href="checkpoint.html#Utils.Checkpointer"><code>Checkpointer</code></a>   Note that the checkpoint is eagerly marked as used, before finishing writing   the checkpoint.  Upon restart the code needs to check if this checkpoint   is really finished.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.loadCheckpoint" href="#Utils.loadCheckpoint"><code>Utils.loadCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Loads a specified checkpoint.  Only loads eqn.q_vec.  Does not load   the checkpointer (because this is loading a checkpoint and not a restart).   Also does not load the AbstractCheckpointData.   See <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a> for loading of the AbstractCheckpointData.   Users should generally not call this function directly.  Users should   prefer <a href="checkpoint.html#Utils.loadLastCheckpoint"><code>loadLastCheckpoint</code></a> whenever possible.</p><p>Note that loading a checkpoint does not mark it as free.  Users must   explictly call <a href="checkpoint.html#Utils.freeCheckpoint"><code>freeCheckpoint</code></a>.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the index of the checkpoint</li><li>mesh: an AbstractMesh object</li><li>sbp: the SBP operator</li><li>opts: the options dictionary</li></ul><p><strong>Inputs/Output</strong></p><ul><li>eqn: an AbstractSolutionData, eqn.q_vec is overwritten</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.writeFlagFile" href="#Utils.writeFlagFile"><code>Utils.writeFlagFile</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Write the flag file that signifies a checkpoint is complete   Call on master process only!</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.checkFlagFile" href="#Utils.checkFlagFile"><code>Utils.checkFlagFile</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Returns true if the flag file exists and is consistent, returns false   otherwise</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div><div><p>Sometimes need to check the flag file before the Checkpointer is available.   See the other method ofr details.</p><p>**Inputs*</p><ul><li>fpath: path to the checkpoint directory</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.deleteFlagFile" href="#Utils.deleteFlagFile"><code>Utils.deleteFlagFile</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Deletes the flag file if it exists.  Does not error if flag file does not   exist.   Call on master process only</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.writeCheckpointData" href="#Utils.writeCheckpointData"><code>Utils.writeCheckpointData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Writes the AbstractCheckpointData to a file.  The file can be read by   <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a>.</p><p>**Inputs*</p><ul><li>checkpoint: Checkpointer object</li><li>checkpoint: the checkpoint index</li><li>obj: the AbstractCheckpointData object</li><li>comm_rank: the MPI rank of this process</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.markCheckpointUsed" href="#Utils.markCheckpointUsed"><code>Utils.markCheckpointUsed</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Marks a checkpoint as unused.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div></section><footer><hr/><a class="previous" href="io.html"><span class="direction">Previous</span><span class="title">Input/Output</span></a></footer></article></body></html>

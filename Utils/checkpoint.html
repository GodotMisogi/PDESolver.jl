<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Checkpointing · PDESolver.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script></head><body><nav class="toc"><h1>PDESolver.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">PDESolver Introduction</a></li><li><span class="toctext">PDESolver Concepts</span><ul><li><a class="toctext" href="../concepts/intro.html">Intro</a></li><li><a class="toctext" href="../concepts/pumi.html">PUMI</a></li><li><a class="toctext" href="../concepts/sbp.html">SBP</a></li></ul></li><li><span class="toctext">Building PDESolver</span><ul><li><a class="toctext" href="../build.html">Building PDESolver</a></li><li><a class="toctext" href="../deps_readme.html">Build Options</a></li></ul></li><li><span class="toctext">DOC To be broken up or organized</span><ul><li><a class="toctext" href="../interfaces.html">Code Interfaces</a></li><li><a class="toctext" href="../parallel.html">Code Parallelization</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/isentropic.html">Isentropic Vortex</a></li><li><a class="toctext" href="../examples/unsteady.html">Unsteady Vortex</a></li></ul></li><li><span class="toctext">Frontend</span><ul><li><a class="toctext" href="../pdesolver.html">Introduction</a></li><li><a class="toctext" href="../pdesolver_user.html">PDESolver User Interface</a></li><li><a class="toctext" href="../pdesolver_physics.html">PDESolver Physics Interface</a></li><li><a class="toctext" href="../pdesolver_structure.html">PDESolver Structure</a></li></ul></li><li><span class="toctext">Invocation</span><ul><li><a class="toctext" href="../invocation/calling.html">Calling PDESolver</a></li><li><a class="toctext" href="../invocation/interactive.html">Interactive Session (experimental)</a></li></ul></li><li><span class="toctext">Solver</span><ul><li><a class="toctext" href="../solver/Readme.html">Overview of Physics Modules</a></li><li><a class="toctext" href="../solver/misc.html">Assorted Function and Types</a></li><li><a class="toctext" href="../solver/SolverCommon.html">Solver Common</a></li><li><span class="toctext">Advection</span><ul><li><a class="toctext" href="../solver/advection/advection.html">Introduction</a></li><li><a class="toctext" href="../solver/advection/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/advection/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/advection/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/advection/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/advection/ic.html">Initial Condition</a></li><li><a class="toctext" href="../solver/advection/source.html">Source Term</a></li><li><a class="toctext" href="../solver/advection/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/advection/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/advection/boundary_functional.html">Boundary Functional</a></li></ul></li><li><span class="toctext">Euler</span><ul><li><a class="toctext" href="../solver/euler/euler.html">Introduction</a></li><li><a class="toctext" href="../solver/euler/types.html">Datatypes</a></li><li><a class="toctext" href="../solver/euler/volume.html">Volume Integrals</a></li><li><a class="toctext" href="../solver/euler/volume_diff.html">Volume Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/flux.html">Face Integrals</a></li><li><a class="toctext" href="../solver/euler/flux_diff.html">Face Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/faceElementIntegrals.html">Face Element Integrals</a></li><li><a class="toctext" href="../solver/euler/bc.html">Boundary Integrals</a></li><li><a class="toctext" href="../solver/euler/bc_diff.html">Boundary Integrals Jacobian</a></li><li><a class="toctext" href="../solver/euler/ic.html">Initial Conditions</a></li><li><a class="toctext" href="../solver/euler/source.html">Source Term</a></li><li><a class="toctext" href="../solver/euler/common.html">Common Functions</a></li><li><a class="toctext" href="../solver/euler/conversion.html">Conversion</a></li><li><a class="toctext" href="../solver/euler/flux_functions.html">Numerical Flux Functions</a></li><li><a class="toctext" href="../solver/euler/flux_functions_diff.html">Numerical Flux Functions Jacobian</a></li><li><a class="toctext" href="../solver/euler/stabilization.html">Stabilization</a></li><li><a class="toctext" href="../solver/euler/adjoint.html">Adjoint</a></li><li><a class="toctext" href="../solver/euler/boundary_functional.html">Boundary Functional</a></li><li><a class="toctext" href="../solver/euler/misc.html">Misc</a></li><li><a class="toctext" href="../solver/euler/homotopy.html">Homotopy</a></li><li><a class="toctext" href="../solver/euler/homotopy_diff.html">Homotopy Jacobian</a></li><li><a class="toctext" href="../solver/euler/eigensystem.html">Eigensystem</a></li><li><a class="toctext" href="../solver/euler/startup.html">Startup</a></li></ul></li><li><span class="toctext">Simple ODE</span><ul><li><a class="toctext" href="../solver/simpleODE/simpleODE.html">Main</a></li></ul></li></ul></li><li><span class="toctext">Input</span><ul><li><a class="toctext" href="../input/input.html">Introduction</a></li><li><a class="toctext" href="../input/keys.html">Important Keys</a></li></ul></li><li><span class="toctext">LinearSolvers</span><ul><li><a class="toctext" href="../linearsolvers/linearsolvers.html">Introduction</a></li><li><a class="toctext" href="../linearsolvers/pc.html">Preconditioners</a></li><li><a class="toctext" href="../linearsolvers/lo.html">Linear Operators</a></li><li><a class="toctext" href="../linearsolvers/ls.html">Linear Solvers</a></li></ul></li><li><span class="toctext">NonlinearSolvers</span><ul><li><a class="toctext" href="../NonlinearSolvers/nonlinearsolvers.html">Introduction</a></li><li><a class="toctext" href="../NonlinearSolvers/steady.html">Steady</a></li><li><span class="toctext">Unsteady</span><ul><li><a class="toctext" href="../NonlinearSolvers/unsteady/intro.html">Intro</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/rk4.html">Runge-Kutta</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/lserk.html">LSERK</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn.html">Crank-Nicolson</a></li><li><a class="toctext" href="../NonlinearSolvers/unsteady/cn_uadj.html">Crank-Nicolson: Unsteady Adjoint</a></li></ul></li><li><a class="toctext" href="../NonlinearSolvers/newton.html">Newton&#39;s Method</a></li><li><a class="toctext" href="../NonlinearSolvers/jacobian.html">Jacobian Calculation</a></li><li><a class="toctext" href="../NonlinearSolvers/jac_recalc.html">Jacobian Freezing</a></li><li><a class="toctext" href="../NonlinearSolvers/residual_evaluation.html">Residual Evalution</a></li><li><a class="toctext" href="../NonlinearSolvers/matrix.html">Matrix Interface</a></li><li><a class="toctext" href="../NonlinearSolvers/newton_inner.html">Newton Inner</a></li></ul></li><li><span class="toctext">Utils</span><ul><li><a class="toctext" href="Utils.html">Main</a></li><li><a class="toctext" href="parallel.html">Parallel Constructs</a></li><li><a class="toctext" href="projections.html">Projections</a></li><li><a class="toctext" href="logging.html">Logging</a></li><li><a class="toctext" href="io.html">Input/Output</a></li><li class="current"><a class="toctext" href="checkpoint.html">Checkpointing</a><ul class="internal"><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Internal-Functions-1">Internal Functions</a></li></ul></li><li><a class="toctext" href="misc.html">Misccellaneous</a></li></ul></li><li><span class="toctext">Testing</span><ul><li><a class="toctext" href="../test/Testing.html">Introduction</a></li><li><a class="toctext" href="../test/Readme.html">Local Testing</a></li><li><a class="toctext" href="../test/Travis.html">CI Testing</a></li><li><a class="toctext" href="../test/TestSystem.html">Test API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Utils</li><li><a href="checkpoint.html">Checkpointing</a></li></ul><a class="edit-page" href="https://github.com/OptimalDesignLab/PDESolver.jl/tree/21d1ed1e98a27b1109072fdac351bf63d3833b08/docs/src/Utils/checkpoint.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Checkpointing-1" href="#Checkpointing-1">Checkpointing</a></h1><p>Checkpointing has two use cases: saving the state of the solver to be loaded later (for example, in unsteady adjoint calculations), and to restart the solver after a crash. This checkpointing functionality described here is useful for both of these functions. Its purpose is to provide an interface for writing the current state to a file that can be read back later. As long as at least 2 checkpoints are saved, the implementation guarantees that at least one checkpoint is loadable at any time, even if the code is terminated while writing a checkpoint.</p><p>Log files require special handling when restarting. Log files should be opened in append mode when restarting (in fact, the code usually opens log files in append mode even when not restarting). One of the consequences of restarting is that there may be duplicate lines in log files.  For example, if a code is doing a run of 10,000 timesteps, checkpointing every 1,000 timesteps, and gets terminated at timestep 6,500, it can be restarted from the checkpoint at timestep 6,000 and run to the end.  This means any output written between timesteps 6,000 and 6,500 will  appear twice in the log files. To deal with this problem, the script <code>log_cleaner.jl</code> (located in <code>src/scripts</code>) can be used to post-process delimited data files (space, comma, tab, etc.) and remove duplicate entries in favor of the entry appearing last in the log file. It also checks removed entries to make sure they are the same (to floating point tolerance) as the entries that are preserved.</p><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.Checkpointer" href="#Utils.Checkpointer"><code>Utils.Checkpointer</code></a> — <span class="docstring-category">Type</span>.</div><div><p>This type keeps track of which checkpoints are in use and has an API   for loading and saving checkpoints</p><p>The fields of the type should <em>never</em> be directly accessed.  Use the API   instead.</p><p>Every checkpoint must be in its own directory.</p><p>Checkpointing has two uses: loading a previous state and restarting.   The first one is rather easy, all that needs to happen is the solution   variables get loaded.  Restarting is more involved because all the local   data of the NonlinearSolver that was running needs to be stored and then   loaded again in a new session.</p><p>An input file called input_vals_restart is created in the current directory   that can be used to restart the code.</p><p><strong>Fields</strong></p><ul><li>ncheckpoints: total number of checkpoints</li><li>paths: absolute paths to the checkpoints (array of strings)</li><li>status: status of each checkpoint (used or free), (array of Ints)</li><li>history: list of checkpoints from most recently used to least recently               used, unused entries set to -1</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.Checkpointer-Tuple{Integer,Integer,ASCIIString}" href="#Utils.Checkpointer-Tuple{Integer,Integer,ASCIIString}"><code>Utils.Checkpointer</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Constructs a Checkpointer with a given number of checkpoints.</p><p>The checkpoints are put into directories called &quot;checkpoint<em>&quot;, where the   &quot;</em>&quot; is replaced by the index of the checkpoint (from 1 to ncheckpoints).   This constructor does not error if the directories already exist, however   any data in the checkpoints may be overwritten.</p><p><strong>Inputs</strong></p><ul><li>myrank: MPI rank of this process</li></ul><ul><li>ncheckpoints: number of checkpoints, defaults to 2.  Using fewer than                    2 is not recommended (there will be a moment in time during                    which the old checkpoint has been partially overwritten but                    the new checkpoint is not complete yet)</li></ul><ul><li>prefix: added to directory names (with an underscore added in-between).               Defaults to empty string. This is useful if there are multiple               sets of checkpoints (and therefore multiple Checkpointer objects).</li></ul><p><strong>Outputs</strong></p><ul><li>a Checkpointer object, fully initialized</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.Checkpointer-Tuple{Dict{K,V},Integer}" href="#Utils.Checkpointer-Tuple{Dict{K,V},Integer}"><code>Utils.Checkpointer</code></a> — <span class="docstring-category">Method</span>.</div><div><p>This constructor loads a Checkpointer object from a file.  This should   be used for restarting.  Do <em>not</em> use the other constructor for restarting.   It will load the most recently written checkpoint that is complete (an   important distinction if the code was killed in the middle of writing   a checkpoint)</p><p><strong>Inputs</strong></p><ul><li>opts: the options dictionary.  </li></ul><p><strong>Outputs</strong></p><ul><li>a Checkpointer object, fully initialized and aware of which checkpoints      are in use and which are free</li></ul><p>This function only loads the Checkpointer from the checkpoint.   See <a href="checkpoint.html#Utils.loadLastCheckpoint"><code>loadLastCheckpoint</code></a> and <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a> to   load the rest of checkpoint data.   The checkpoint that was loaded can be accessed via <a href="checkpoint.html#Utils.getLastCheckpoint"><code>getLastCheckpoint</code></a></p><p><strong>Implementation notes:</strong></p><p>Uses 4 keys in the options dictionary:</p><ul><li>&quot;writing checkpoint&quot;: index of checkpoint that might be complete</li><li>&quot;writing_checkpoint_path&quot;: absolute path of checkpoint</li><li>&quot;most_recent_checkpoint&quot;: index of checkpoint that is definitely                                 complete, but might be older than the above</li><li>&quot;most_recent_checkpoint_path&quot;: absolute path of checkpoint</li></ul><p>This system ensure it is possible to restart even if the code is   killed in the middle of writing a checkpoint.</p><p>The Checkpointer object is the same on all processes.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy-Tuple{Utils.Checkpointer}" href="#Base.copy-Tuple{Utils.Checkpointer}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span>.</div><div><p>Recursively copies all fields to make a new Checkpointer object.   Note that changes to one Checkpointer object will not affect the other   (ie. the record of which checkpoints are used and which are not).   This could easily lead to corrupting a checkpoint.   For this reason, this function should rarely be used.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copy!-Tuple{Utils.Checkpointer,Utils.Checkpointer}" href="#Base.copy!-Tuple{Utils.Checkpointer,Utils.Checkpointer}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">copy!(dest, src)</code></pre><p>Copy all elements from collection <code>src</code> to array <code>dest</code>. Returns <code>dest</code>.</p></div><div><p>2 argument version of copy().  See that function for details.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.AbstractCheckpointData" href="#Utils.AbstractCheckpointData"><code>Utils.AbstractCheckpointData</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Every function that wants to checkpoint must implement an   AbstractCheckpointData containing all the data that needs to be loaded   when the code restarts.  The values in the AbstractSolutionData can be   different for each MPI process.</p><p>This type must contain only &quot;julia&quot; data, ie. objects that are managed   by Julia and have deterministic values.  No pointers, MPI communicators etc.</p><p>File IO is expensive, so include only as much data as needed in the   AbstractCheckpointData.  Anything that can be recalculated should be.</p><p>Generally, only the outermost function (ie. the time stepper or the   nonlinear solver for steady problems) will need to checkpoint.</p><p>There are no required fields for this type</p></div></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><p>These function provide the basic operations required for checkpointing</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.saveNextFreeCheckpoint" href="#Utils.saveNextFreeCheckpoint"><code>Utils.saveNextFreeCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function saves to the next free checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>mesh: an AbstractMesh</li><li>sbp: an SBP operator</li><li>eqn: an AbstractSolutionData object</li><li>checkpoint_data: the users AbstractCheckpointData implementation</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>opts: the options dictionary</li></ul><p><strong>Outputs</strong></p><ul><li>checkpoint: the index of the checkpoint saved.</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.loadLastCheckpoint" href="#Utils.loadLastCheckpoint"><code>Utils.loadLastCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function loads the most recently saved checkpoint.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the CheckPointer object</li><li>mesh: an AbstractMesh</li><li>sbp: an SBP operator</li><li>opts: the options dictionary</li></ul><p><strong>Inputs/Outputs</strong></p><ul><li>eqn: an AbstractSolutionData object</li></ul><p><strong>Outputs</strong></p><ul><li>the checkpoint index that was loaded</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.readLastCheckpointData" href="#Utils.readLastCheckpointData"><code>Utils.readLastCheckpointData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Simple wrapper around <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a> to loading the most   recently saved checkpoint data</p><p><strong>Inputs</strong></p><ul><li>chkpointer: a Checkpointer</li><li>comm_rank: MPI rank of this process</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.readCheckpointData" href="#Utils.readCheckpointData"><code>Utils.readCheckpointData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function reads an object of type AbstractSolutionData from a file   and reuturns the object.  This is type unstable, so every AbstractCheckpointData   implementation should create a constructor that calls this function and   uses a type assertion to specify that the object must be of their concrete   type.</p><p><strong>Inputs</strong></p><ul><li>chkpointer: a Checkpointer</li><li>chkpoint: the index of hte checkpoint</li><li>comm_rank: the MPI rank of this process</li></ul><p><strong>Outputs</strong></p><ul><li>the <a href="checkpoint.html#Utils.AbstractCheckpointData"><code>AbstractCheckpointData</code></a> loaded from the checkpoint</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.countFreeCheckpoints" href="#Utils.countFreeCheckpoints"><code>Utils.countFreeCheckpoints</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the number of free checkpoints</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpoint object</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getNextFreeCheckpoint" href="#Utils.getNextFreeCheckpoint"><code>Utils.getNextFreeCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the index of the next free checkpoint,  or 0 if   there are no free checkpoints</p><p><strong>Input</strong></p><ul><li>checkpointer: a Checkpointer</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getLastCheckpoint" href="#Utils.getLastCheckpoint"><code>Utils.getLastCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function returns the index of the most recently written checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li></ul><p><strong>Outputs</strong></p><ul><li>the index of the most recently saved checkpoint</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.getOldestCheckpoint" href="#Utils.getOldestCheckpoint"><code>Utils.getOldestCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Get the least recently written checkpoint</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer</li></ul><p><strong>Outputs</strong></p><ul><li>the index of the least recently written checkpoint</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.freeOldestCheckpoint" href="#Utils.freeOldestCheckpoint"><code>Utils.freeOldestCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Frees the least recently written checkpoint. Calling this function when   all checkpoints are free is allowed.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer</li></ul><p><strong>Outputs</strong></p><ul><li>returns the checkpoint freed (0 all checkpoints were free on entry)</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.freeCheckpoint" href="#Utils.freeCheckpoint"><code>Utils.freeCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>This function frees a checkpoint (marks it as available to be overwritten)   Unlike certain algorithms that use free lists (cough, cough, malloc)   freeing an already free checkpoint is allowed.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the index of the checkpoint to free</li></ul><p>The user must explictly free checkpoints (loading a checkpoint does not   free it).   Note that a free checkpoint can still be loaded for restarting if it has   not been saved to yet.</p></div></section><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>This section provides a simple example of how to use checkpointing for an explicit time marching scheme. The original scheme (without checkpointing) looks like:</p><pre><code class="language-julia">function explicit_timemarching_example(mesh, sbp, eqn, opts, func::Function)

  nsteps = round(Int, opts[&quot;tmax&quot;]/opts[&quot;delta_t&quot;])
  t = 0.0

  for step=1:nsteps

    t = (step - 1)*delta_t
    # q_vec -&gt; q
    disassembleSolution(mesh, sbp, eqn, opts, eqn.q, eqn.q_vec)
    func(mesh, sbp, eqn, opts, t)

    # res -&gt; res_vec
    assembleSolution(mesh, sbp, eqn, opts, eqn.res, eqn.res_vec)

    for i=1:mesh.numDof
      eqn.q_vec[i] = ... # some function of eqn.res_vec[i]
    end
  end  # end loop over timesteps

  return nothing
end</code></pre><p>With checkpointing, it becomes:</p><pre><code class="language-julia">
type ExampleCheckpointData &lt;: AbstractCheckpointData
  step::Int  # for this method, the only thing that needs to be stored is the
             # current time step, everything else can be recalculated
end

# this constructor is used when restarting, see below
function ExampleCheckpointData(chkpointer::Checkpointer, comm_rank)

  chkpoint_data = readLastCheckpointData(chkpointer, comm_rank)

  return chkpoint_data::ExampleCheckpointData
end

function explicit_timemarching_example(mesh, sbp, eqn, opts, func::Function)

  nsteps = round(Int, opts[&quot;tmax&quot;]/opts[&quot;delta_t&quot;])
  t = 0.0

  if !opts[&quot;is_restart&quot;]
    # regular starting of a run
    stepstart = 1
    chkpointdata = ExampleCheckpointData(stepstart)
    # this is valid even if we don&#39;t intend to checkpoint (ncheckpoints = 0)
    chkpointer = Checkpointer(mesh.myrank, opts[&quot;ncheckpoints&quot;]
    skip_checkpoint = false
  else
    chkpointer = Checkpointer(opts, myrank)  # read Checkpointer from most recent
                                             # checkpoint
    # now get the checkpoint data telling which timestep we are on
    # eqn.q_vec already holds the state saved in the checkpoint.  This is handled
    # during the initialization of the equation object
    chkpointdata = ExampleCheckpointData(chkpoinnter, mesh.myrank)
    stepstart = chkpointdata.step
    skip_checkpoint = true  # skip writing the first checkpoint.  Without this, a
                            # checkpoint would be written immediately.
                            # Writing the checkpoint is not harmful, but not useful
                            # either.
   end
    
  for step=stepstart:nsteps  # start the loop from stepstart

    t = (step - 1)*delta_t   # t is recalculated from step, which was set using
                             # stepstart, thus only stepstart needs to be saved

    # save checkpoint, if needed
    if opts[&quot;use_checkpointing&quot;] &amp;&amp; step % opts[&quot;checkpoint_freq&quot;] == 0 &amp;&amp; !skip_checkpoint
      skip_checkpoint = false

      # save all needed variables to the ExampleCheckpointData object
      # For simple time marching schemes, step is the only needed data
      chkpointdata.step = step

      if countFreeCheckpoints(chkpointer) == 0
        freeOldestCheckpoint(chkpointer)  # make room for a new checkpoint
      end

      saveNextFreeCheckpoint(chkpointer, mesh, sbp, eqn, opts, chkpointdata)
    end

    # q_vec -&gt; q
    disassembleSolution(mesh, sbp, eqn, opts, eqn.q, eqn.q_vec)
    func(mesh, sbp, eqn, opts, t)

    # res -&gt; res_vec
    assembleSolution(mesh, sbp, eqn, opts, eqn.res, eqn.res_vec)

    for i=1:mesh.numDof
      eqn.q_vec[i] = ... # some function of eqn.res_vec[i]
    end
  end  # end loop over timesteps

  return nothing
end</code></pre><h2><a class="nav-anchor" id="Internal-Functions-1" href="#Internal-Functions-1">Internal Functions</a></h2><p>The internal functions used for checkpointing are documented here. Users should not call these functions directly.  Improper use can cause checkpoint corruption.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.writeCheckpointer" href="#Utils.writeCheckpointer"><code>Utils.writeCheckpointer</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Call on master process only</p><p>Does <em>not</em> check if the checkpoint is already used (for reading the   state back after restart, this checkpoint should already be marked as   used)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.saveCheckpoint" href="#Utils.saveCheckpoint"><code>Utils.saveCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Save to a specified checkpoint.  Throw error if checkpoint is not free.   Users should not generally call this function directly.  Instead, they   should prefer <a href="checkpoint.html#Utils.saveNextFreeCheckpoint"><code>saveNextFreeCheckpoint</code></a>.</p><p>This function automatically saves eqn.q_vec and the checkpointer to   a file.  Any additional data should be in checkpoint_data.</p><p>Note: mesh adaptation is not compatable with checkpointing   #TODO; add a field to the mesh to record that it has been modified</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the CheckPointer</li><li>checkpoint: the index of the checkpoint</li><li>mesh: an AbstractMesh object</li><li>sbp: SBP operator</li><li>eqn: an AbstractSolutionData</li><li>checkpoint_data: an AbstractCheckpointData.  This is the random bag                       of data the user needs saved.</li></ul><p><strong>Inputs/Outputs</strong></p><pre><code class="language-none">* opts: options dictionary</code></pre><p>Implementation Notes:</p><p>Uses options dictionary keys described by <a href="checkpoint.html#Utils.Checkpointer"><code>Checkpointer</code></a>   Note that the checkpoint is eagerly marked as used, before finishing writing   the checkpoint.  Upon restart the code needs to check if this checkpoint   is really finished.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.loadCheckpoint" href="#Utils.loadCheckpoint"><code>Utils.loadCheckpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Loads a specified checkpoint.  Only loads eqn.q_vec.  Does not load   the checkpointer (because this is loading a checkpoint and not a restart).   Also does not load the AbstractCheckpointData.   See <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a> for loading of the AbstractCheckpointData.   Users should generally not call this function directly.  Users should   prefer <a href="checkpoint.html#Utils.loadLastCheckpoint"><code>loadLastCheckpoint</code></a> whenever possible.</p><p>Note that loading a checkpoint does not mark it as free.  Users must   explictly call <a href="checkpoint.html#Utils.freeCheckpoint"><code>freeCheckpoint</code></a>.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the index of the checkpoint</li><li>mesh: an AbstractMesh object</li><li>sbp: the SBP operator</li><li>opts: the options dictionary</li></ul><p><strong>Inputs/Output</strong></p><ul><li>eqn: an AbstractSolutionData, eqn.q_vec is overwritten</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.writeFlagFile" href="#Utils.writeFlagFile"><code>Utils.writeFlagFile</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Write the flag file that signifies a checkpoint is complete   Call on master process only!</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.checkFlagFile" href="#Utils.checkFlagFile"><code>Utils.checkFlagFile</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Returns true if the flag file exists and is consistent, returns false   otherwise</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div><div><p>Sometimes need to check the flag file before the Checkpointer is available.   See the other method ofr details.</p><p><strong>Inputs</strong></p><ul><li>fpath: path to the checkpoint directory</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.deleteFlagFile" href="#Utils.deleteFlagFile"><code>Utils.deleteFlagFile</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Deletes the flag file if it exists.  Does not error if flag file does not   exist.   Call on master process only</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.writeCheckpointData" href="#Utils.writeCheckpointData"><code>Utils.writeCheckpointData</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Writes the AbstractCheckpointData to a file.  The file can be read by   <a href="checkpoint.html#Utils.readCheckpointData"><code>readCheckpointData</code></a>.</p><p><strong>Inputs</strong></p><ul><li>checkpoint: Checkpointer object</li><li>checkpoint: the checkpoint index</li><li>obj: the AbstractCheckpointData object</li><li>comm_rank: the MPI rank of this process</li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Utils.markCheckpointUsed" href="#Utils.markCheckpointUsed"><code>Utils.markCheckpointUsed</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Marks a checkpoint as unused.</p><p><strong>Inputs</strong></p><ul><li>checkpointer: the Checkpointer object</li><li>checkpoint: the checkpoint index</li></ul></div></section><footer><hr/><a class="previous" href="io.html"><span class="direction">Previous</span><span class="title">Input/Output</span></a><a class="next" href="misc.html"><span class="direction">Next</span><span class="title">Misccellaneous</span></a></footer></article></body></html>
